[
  {
    "objectID": "lectures/wyklad_sql_sekcje4_5.html",
    "href": "lectures/wyklad_sql_sekcje4_5.html",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL â€“ Sekcje 4 i 5",
    "section": "",
    "text": "Indeksy to podstawowe narzÄ™dzie optymalizacji zapytaÅ„, ktÃ³re pozwala bazie danych szybko znaleÅºÄ‡ potrzebne wiersze, bez koniecznoÅ›ci skanowania caÅ‚ej tabeli.\nMoÅ¼na je porÃ³wnaÄ‡ do spisu treÅ›ci w ksiÄ…Å¼ce â€” zamiast czytaÄ‡ kaÅ¼dy rozdziaÅ‚, patrzymy od razu na wÅ‚aÅ›ciwÄ… stronÄ™.\n\n\nBez indeksu baza danych musi sprawdziÄ‡ kaÅ¼dy wiersz tabeli, by znaleÅºÄ‡ pasujÄ…ce rekordy (sequential scan).\nZ indeksem, silnik moÅ¼e odczytaÄ‡ tylko te dane, ktÃ³re speÅ‚niajÄ… warunek â€” znacznie szybciej i przy mniejszym zuÅ¼yciu zasobÃ³w.\nKorzyÅ›ci z indeksÃ³w:\n\nâ±ï¸ Szybsze wyszukiwanie danych, szczegÃ³lnie w duÅ¼ych tabelach\n\nğŸ’¾ Ograniczenie operacji I/O, bo baza czyta mniej blokÃ³w z dysku\n\nğŸ”„ Przyspieszenie sortowania i Å‚Ä…czenia tabel (JOIN), jeÅ›li indeks obejmuje kolumny uÅ¼ywane w warunkach\n\n\n\n\nNajczÄ™Å›ciej spotykane:\n\nB-Tree (balanced tree) â€“ najpopularniejszy typ, sprawdza siÄ™ w wiÄ™kszoÅ›ci wyszukiwaÅ„, zakresÃ³w i sortowaÅ„\n\nHash â€“ szybki dostÄ™p po dokÅ‚adnej wartoÅ›ci (nie obsÅ‚uguje zakresÃ³w)\n\nBitmap â€“ efektywny dla kolumn o maÅ‚ej liczbie unikalnych wartoÅ›ci, np. pÅ‚eÄ‡ lub status\n\nKompozytowe â€“ obejmujÄ… kilka kolumn, przydatne przy filtrach i sortowaniach wielokolumnowych\n\n\n\n\n\nKolumny uÅ¼ywane w WHERE â€“ aby szybciej wyszukaÄ‡ dane\n\nKolumny uÅ¼ywane w JOIN â€“ przyspiesza Å‚Ä…czenie tabel\n\nKolumny w ORDER BY lub GROUP BY â€“ pomaga szybciej sortowaÄ‡ i grupowaÄ‡ wyniki\n\nKolumny unikalne lub klucze gÅ‚Ã³wne â€“ zapewnia integralnoÅ›Ä‡ danych i przyspiesza wyszukiwanie\n\n\n\n\nIndeksy przyspieszajÄ… odczyt, ale majÄ… teÅ¼ koszty:\n\nğŸ”„ Spowolnienie operacji INSERT/UPDATE/DELETE, bo indeksy trzeba aktualizowaÄ‡\n\nğŸ’¾ ZwiÄ™kszone zuÅ¼ycie pamiÄ™ci i przestrzeni dyskowej\n\nâš–ï¸ Trzeba wybraÄ‡ optymalny zestaw indeksÃ³w, Å¼eby nie pogorszyÄ‡ ogÃ³lnej wydajnoÅ›ci"
  },
  {
    "objectID": "lectures/wyklad_sql_sekcje4_5.html#sekcja-4-indeksy-w-sql",
    "href": "lectures/wyklad_sql_sekcje4_5.html#sekcja-4-indeksy-w-sql",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL â€“ Sekcje 4 i 5",
    "section": "",
    "text": "Indeksy to podstawowe narzÄ™dzie optymalizacji zapytaÅ„, ktÃ³re pozwala bazie danych szybko znaleÅºÄ‡ potrzebne wiersze, bez koniecznoÅ›ci skanowania caÅ‚ej tabeli.\nMoÅ¼na je porÃ³wnaÄ‡ do spisu treÅ›ci w ksiÄ…Å¼ce â€” zamiast czytaÄ‡ kaÅ¼dy rozdziaÅ‚, patrzymy od razu na wÅ‚aÅ›ciwÄ… stronÄ™.\n\n\nBez indeksu baza danych musi sprawdziÄ‡ kaÅ¼dy wiersz tabeli, by znaleÅºÄ‡ pasujÄ…ce rekordy (sequential scan).\nZ indeksem, silnik moÅ¼e odczytaÄ‡ tylko te dane, ktÃ³re speÅ‚niajÄ… warunek â€” znacznie szybciej i przy mniejszym zuÅ¼yciu zasobÃ³w.\nKorzyÅ›ci z indeksÃ³w:\n\nâ±ï¸ Szybsze wyszukiwanie danych, szczegÃ³lnie w duÅ¼ych tabelach\n\nğŸ’¾ Ograniczenie operacji I/O, bo baza czyta mniej blokÃ³w z dysku\n\nğŸ”„ Przyspieszenie sortowania i Å‚Ä…czenia tabel (JOIN), jeÅ›li indeks obejmuje kolumny uÅ¼ywane w warunkach\n\n\n\n\nNajczÄ™Å›ciej spotykane:\n\nB-Tree (balanced tree) â€“ najpopularniejszy typ, sprawdza siÄ™ w wiÄ™kszoÅ›ci wyszukiwaÅ„, zakresÃ³w i sortowaÅ„\n\nHash â€“ szybki dostÄ™p po dokÅ‚adnej wartoÅ›ci (nie obsÅ‚uguje zakresÃ³w)\n\nBitmap â€“ efektywny dla kolumn o maÅ‚ej liczbie unikalnych wartoÅ›ci, np. pÅ‚eÄ‡ lub status\n\nKompozytowe â€“ obejmujÄ… kilka kolumn, przydatne przy filtrach i sortowaniach wielokolumnowych\n\n\n\n\n\nKolumny uÅ¼ywane w WHERE â€“ aby szybciej wyszukaÄ‡ dane\n\nKolumny uÅ¼ywane w JOIN â€“ przyspiesza Å‚Ä…czenie tabel\n\nKolumny w ORDER BY lub GROUP BY â€“ pomaga szybciej sortowaÄ‡ i grupowaÄ‡ wyniki\n\nKolumny unikalne lub klucze gÅ‚Ã³wne â€“ zapewnia integralnoÅ›Ä‡ danych i przyspiesza wyszukiwanie\n\n\n\n\nIndeksy przyspieszajÄ… odczyt, ale majÄ… teÅ¼ koszty:\n\nğŸ”„ Spowolnienie operacji INSERT/UPDATE/DELETE, bo indeksy trzeba aktualizowaÄ‡\n\nğŸ’¾ ZwiÄ™kszone zuÅ¼ycie pamiÄ™ci i przestrzeni dyskowej\n\nâš–ï¸ Trzeba wybraÄ‡ optymalny zestaw indeksÃ³w, Å¼eby nie pogorszyÄ‡ ogÃ³lnej wydajnoÅ›ci"
  },
  {
    "objectID": "lectures/wyklad_sql_sekcje4_5.html#sekcja-5-praktyczne-przykÅ‚ady-uÅ¼ycia-indeksÃ³w",
    "href": "lectures/wyklad_sql_sekcje4_5.html#sekcja-5-praktyczne-przykÅ‚ady-uÅ¼ycia-indeksÃ³w",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL â€“ Sekcje 4 i 5",
    "section": "ğŸ§ª Sekcja 5 â€“ Praktyczne przykÅ‚ady uÅ¼ycia indeksÃ³w",
    "text": "ğŸ§ª Sekcja 5 â€“ Praktyczne przykÅ‚ady uÅ¼ycia indeksÃ³w\nW tej sekcji pokaÅ¼emy, jak indeksy wpÅ‚ywajÄ… na plan wykonania zapytania i rzeczywisty czas wykonania.\n\nğŸ”¹ PrzykÅ‚ad w PostgreSQL\nMamy tabelÄ™ orders:\nCREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  customer_id INTEGER,\n  order_date DATE,\n  total DECIMAL\n);\n\nScenariusz A â€“ brak indeksu\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\nWynik moÅ¼e wyglÄ…daÄ‡ tak:\nSeq Scan on orders  (cost=0.00..450.00 rows=3 width=48)\n  Filter: (customer_id = 42)\nExecution Time: 22.5 ms\n\nBaza przeszukuje caÅ‚Ä… tabelÄ™ (Seq Scan), co jest kosztowne przy duÅ¼ej liczbie rekordÃ³w.\n\n\n\nScenariusz B â€“ z indeksem\nDodajemy indeks na kolumnie customer_id:\nCREATE INDEX idx_orders_customer ON orders(customer_id);\nPo wykonaniu tego samego zapytania:\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\nPlan wykonania:\nIndex Scan using idx_orders_customer on orders  (cost=0.29..8.50 rows=3 width=48)\n  Index Cond: (customer_id = 42)\nExecution Time: 0.030 ms\nâ¡ï¸ WidaÄ‡ ogromnÄ… poprawÄ™ wydajnoÅ›ci: baza odczytuje tylko pasujÄ…ce wiersze zamiast caÅ‚ej tabeli.\n\n\n\nğŸ”¹ Indeksy a JOIN\nPrzy Å‚Ä…czeniu tabel:\nSELECT o.id, c.name\nFROM orders o\nJOIN customers c ON o.customer_id = c.id\nWHERE c.region = 'Europe';\n\nIndeks na customers.id i orders.customer_id przyspiesza JOIN\n\nIndeks na customers.region przyspiesza filtrowanie po regionie\n\n\n\nğŸ”¹ WskazÃ³wki praktyczne\n\nTwÃ³rz indeksy tylko na kolumnach, ktÃ³re sÄ… czÄ™sto filtrowane lub sortowane\n\nAnalizuj plany wykonania przy uÅ¼yciu EXPLAIN i EXPLAIN ANALYZE\n\nZwracaj uwagÄ™ na koszt operacji (cost=â€¦) i liczbÄ™ wierszy (rows=...)\n\nPamiÄ™taj o balansie: zbyt wiele indeksÃ³w moÅ¼e spowolniÄ‡ zapis danych"
  },
  {
    "objectID": "lectures/wyklad6.html",
    "href": "lectures/wyklad6.html",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "",
    "text": "Optymalizacja zapytaÅ„ SQL to jeden z najwaÅ¼niejszych elementÃ³w pracy z bazami danych.\nDotyczy zarÃ³wno programistÃ³w aplikacji, jak i administratorÃ³w baz danych (DBA).\nCelem jest takie przygotowanie zapytaÅ„, struktur danych i indeksÃ³w, aby uzyskaÄ‡ maksymalnÄ… wydajnoÅ›Ä‡ przy minimalnym obciÄ…Å¼eniu systemu.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#dlaczego-optymalizacja-jest-waÅ¼na",
    "href": "lectures/wyklad6.html#dlaczego-optymalizacja-jest-waÅ¼na",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "ğŸ’¡ Dlaczego optymalizacja jest waÅ¼na?",
    "text": "ğŸ’¡ Dlaczego optymalizacja jest waÅ¼na?\nKaÅ¼de zapytanie SQL, nawet najprostsze, wymaga od silnika bazy danych wykonania okreÅ›lonych operacji: odczytu danych z dysku, przetworzenia warunkÃ³w WHERE, wykonania JOIN, GROUP BY, ORDER BY, a nastÄ™pnie zwrÃ³cenia wynikÃ³w uÅ¼ytkownikowi.\nJeÅ›li baza danych zawiera miliony rekordÃ³w, to nawet niewielkie rÃ³Å¼nice w sposobie wykonania zapytania mogÄ… oznaczaÄ‡:\n\nrÃ³Å¼nicÄ™ miÄ™dzy milisekundami a sekundami,\n\nobciÄ…Å¼enie jednego wÄ…tku zamiast caÅ‚ego serwera,\n\nlub zuÅ¼ycie gigabajtÃ³w pamiÄ™ci i I/O bez potrzeby.\n\n\nğŸ§  â€Optymalizacja zapytaÅ„ SQL to nie sztuka pisania krÃ³tszego kodu,\nlecz umiejÄ™tnoÅ›Ä‡ zmuszenia silnika bazy danych do pracy mÄ…drze, a nie ciÄ™Å¼ko.â€",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#jak-dziaÅ‚a-zapytanie-w-silniku-bazy-danych",
    "href": "lectures/wyklad6.html#jak-dziaÅ‚a-zapytanie-w-silniku-bazy-danych",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "âš™ï¸ Jak dziaÅ‚a zapytanie w silniku bazy danych?",
    "text": "âš™ï¸ Jak dziaÅ‚a zapytanie w silniku bazy danych?\nAby zrozumieÄ‡ optymalizacjÄ™, musimy wiedzieÄ‡, co dzieje siÄ™ z zapytaniem od momentu jego wysÅ‚ania do bazy danych.\nSilnik SQL analizuje skÅ‚adniÄ™ zapytania, przepisuje je logicznie, wybiera najtaÅ„szy plan wykonania i dopiero wtedy odczytuje dane.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#co-wpÅ‚ywa-na-wydajnoÅ›Ä‡-zapytaÅ„-sql",
    "href": "lectures/wyklad6.html#co-wpÅ‚ywa-na-wydajnoÅ›Ä‡-zapytaÅ„-sql",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "ğŸ§© Co wpÅ‚ywa na wydajnoÅ›Ä‡ zapytaÅ„ SQL?",
    "text": "ğŸ§© Co wpÅ‚ywa na wydajnoÅ›Ä‡ zapytaÅ„ SQL?\nWydajnoÅ›Ä‡ zapytaÅ„ zaleÅ¼y zarÃ³wno od tego, jak zapytanie jest napisane, jak i od tego, jak zorganizowane sÄ… dane w bazie:\n\nğŸ”¹ Struktura zapytania\n\nZÅ‚oÅ¼onoÅ›Ä‡ klauzul WHERE, JOIN, ORDER BY\nZagnieÅ¼dÅ¼one podzapytania (subqueries)\nUÅ¼ycie funkcji agregujÄ…cych (COUNT, SUM, AVG)\n\n\n\nğŸ”¹ Architektura danych\n\nIloÅ›Ä‡ danych w tabelach\n\nIndeksy (ich liczba, rodzaj i aktualnoÅ›Ä‡)\n\nKlucze gÅ‚Ã³wne i obce (PRIMARY KEY, FOREIGN KEY)\n\nStopieÅ„ normalizacji lub denormalizacji danych\n\n\n\nğŸ”¹ Stan Å›rodowiska bazy\n\nDostÄ™pna pamiÄ™Ä‡ RAM\n\nBuforowanie i cache dyskowy\n\nStatystyki tabel (ANALYZE, UPDATE STATISTICS)\n\nObciÄ…Å¼enie serwera (inne procesy, sesje, transakcje)",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#przykÅ‚ad-znaczenia-optymalizacji",
    "href": "lectures/wyklad6.html#przykÅ‚ad-znaczenia-optymalizacji",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "ğŸ“Š PrzykÅ‚ad znaczenia optymalizacji",
    "text": "ğŸ“Š PrzykÅ‚ad znaczenia optymalizacji\nWyobraÅºmy sobie tabelÄ™ orders z 10 milionami zamÃ³wieÅ„.\nChcemy znaleÅºÄ‡ wszystkie zamÃ³wienia z ostatnich 30 dni:\nSELECT * FROM orders WHERE order_date &gt;= CURRENT_DATE - INTERVAL '30 days';\n\nScenariusz A â€“ brak indeksu\nSilnik musi przeskanowaÄ‡ caÅ‚Ä… tabelÄ™ (tzw. Seq Scan). KaÅ¼dy wiersz jest sprawdzany, czy speÅ‚nia warunek order_date &gt;= ....\n\nâ±ï¸ Czas wykonania: ~3.2 s\n\nğŸ’¾ Operacje I/O: wysokie\n\n\n\nScenariusz B â€“ z indeksem\nDodajemy indeks:\nCREATE INDEX idx_orders_date ON orders(order_date);\nSilnik teraz korzysta z Index Scan, czyli odczytu tylko fragmentu danych pasujÄ…cych do warunku.\n\nâ±ï¸ Czas wykonania: ~0.03 s\n\nğŸ’¾ Operacje I/O: minimalne\n\nâ¡ï¸ 100Ã— szybsze zapytanie â€“ bez zmiany jednej linijki logiki, tylko dziÄ™ki optymalizacji struktury danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#czym-jest-optymalizator-zapytaÅ„",
    "href": "lectures/wyklad6.html#czym-jest-optymalizator-zapytaÅ„",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "ğŸ§  Czym jest optymalizator zapytaÅ„?",
    "text": "ğŸ§  Czym jest optymalizator zapytaÅ„?\nOptymalizator analizuje zapytanie i decyduje, w jaki sposÃ³b najlepiej pobraÄ‡ dane.\nNie zmienia logiki zapytania, ale moÅ¼e caÅ‚kowicie zmieniÄ‡:\n\nkolejnoÅ›Ä‡ operacji,\n\nsposÃ³b Å‚Ä…czenia tabel (JOIN order),\n\nwybÃ³r indeksÃ³w,\n\nmetodÄ™ sortowania lub agregacji.\n\n\nğŸ’¡ Optymalizator to planista â€” nie wykonuje zapytania sam,\nale ukÅ‚ada plan dziaÅ‚ania tak, by wynik uzyskaÄ‡ jak najszybciej i najtaniej.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#etapy-przetwarzania-zapytania",
    "href": "lectures/wyklad6.html#etapy-przetwarzania-zapytania",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "ğŸ”„ Etapy przetwarzania zapytania",
    "text": "ğŸ”„ Etapy przetwarzania zapytania\nDla przykÅ‚adu:\nSELECT name, salary \nFROM employees \nWHERE department_id = 10 AND salary &gt; 5000;\nSilnik przechodzi przez kilka logicznych etapÃ³w:\n\n1. Parsing (analiza skÅ‚adniowa)\n\nsprawdza poprawnoÅ›Ä‡ skÅ‚adni SQL,\n\nweryfikuje istnienie tabel i kolumn,\n\ntworzy drzewo zapytania (parse tree).\n\n\n\n2. Rewriting (przepisanie logiczne)\n\nupraszcza warunki (WHERE TRUE, podwÃ³jne filtry),\n\nzamienia IN na EXISTS,\n\nÅ‚Ä…czy filtry logiczne (AND, OR),\n\nmoÅ¼e przenosiÄ‡ warunki do podzapytaÅ„ (predicate pushdown).\n\n\n\n3. Optimization (planowanie kosztowe)\nOptymalizator analizuje rÃ³Å¼ne plany wykonania: - ktÃ³ry indeks uÅ¼yÄ‡,\n- w jakiej kolejnoÅ›ci Å‚Ä…czyÄ‡ tabele,\n- jakiego algorytmu uÅ¼yÄ‡ (hash join, merge join, nested loop).\nKaÅ¼dy plan ma przypisany koszt (cost estimate) oparty na: - liczbie wierszy,\n- selektywnoÅ›ci warunkÃ³w,\n- dostÄ™pnych indeksach,\n- statystykach i kosztach I/O oraz CPU.\n\nğŸ§® Optymalizator nie wykonuje zapytaÅ„ â€” symuluje scenariusze i wybiera ten o najniÅ¼szym koszcie.\n\n\n\n4. Execution Plan (plan wykonania)\nPo wyborze najlepszego planu, optymalizator przekazuje go do moduÅ‚u wykonawczego.\nPlan opisuje krok po kroku, jak dane zostanÄ… pobrane i przetworzone.\nMoÅ¼emy go podejrzeÄ‡ poleceniem:\nEXPLAIN SELECT ...\nlub\nEXPLAIN ANALYZE SELECT ...",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#co-to-jest-plan-zapytania",
    "href": "lectures/wyklad6.html#co-to-jest-plan-zapytania",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "âš™ï¸ Co to jest plan zapytania?",
    "text": "âš™ï¸ Co to jest plan zapytania?\nPlan zapytania to opis krokÃ³w, jakie silnik bazy danych musi wykonaÄ‡, by uzyskaÄ‡ wynik.\nKaÅ¼dy krok reprezentuje konkretnÄ… operacjÄ™ â€” np.: - Scan (odczyt danych z tabeli lub indeksu), - Join (Å‚Ä…czenie danych z kilku tabel), - Sort (sortowanie wynikÃ³w), - Aggregate (sumowanie, grupowanie, liczenie).\nKaÅ¼dy z tych krokÃ³w ma przypisany szacowany koszt â€” liczbowÄ… wartoÅ›Ä‡ okreÅ›lajÄ…cÄ…, ile operacji CPU, I/O lub pamiÄ™ci wymaga jego wykonanie.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#skÅ‚adnia-polecenia-explain",
    "href": "lectures/wyklad6.html#skÅ‚adnia-polecenia-explain",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "ğŸ§© SkÅ‚adnia polecenia EXPLAIN",
    "text": "ğŸ§© SkÅ‚adnia polecenia EXPLAIN\nW wiÄ™kszoÅ›ci systemÃ³w baz danych moÅ¼na uÅ¼yÄ‡ EXPLAIN na poczÄ…tku dowolnego zapytania:\nEXPLAIN SELECT * FROM employees WHERE department_id = 10;\nAby uzyskaÄ‡ wiÄ™cej szczegÃ³Å‚Ã³w, moÅ¼na dodaÄ‡:\nEXPLAIN ANALYZE SELECT * FROM employees WHERE department_id = 10;\nğŸ“Š RÃ³Å¼nica:\n\nEXPLAIN â€” pokazuje plan teoretyczny (na podstawie statystyk i kosztÃ³w),\nEXPLAIN ANALYZE â€” faktycznie wykonuje zapytanie i pokazuje rzeczywisty czas oraz liczbÄ™ przetworzonych wierszy.\n\n\nğŸ§  PrzykÅ‚ad w PostgreSQL\nZaÅ‚Ã³Å¼my, Å¼e mamy tabelÄ™:\nCREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  customer_id INTEGER,\n  order_date DATE,\n  total DECIMAL\n);\n\nCREATE INDEX idx_orders_customer ON orders(customer_id);\ni wykonujemy zapytanie:\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\n\n\nğŸ”¹ Wynik (plan zapytania):\nIndex Scan using idx_orders_customer on orders  (cost=0.29..8.50 rows=3 width=48)\n  Index Cond: (customer_id = 42)\nPlanning Time: 0.100 ms\nExecution Time: 0.030 ms\n\n\n\n\n\n\n\nElement\nZnaczenie\n\n\n\n\nIndex Scan\nBaza odczytuje dane przy uÅ¼yciu indeksu (nie peÅ‚ny skan tabeli).\n\n\nidx_orders_customer\nNazwa uÅ¼ytego indeksu.\n\n\ncost=0.29..8.50\nSzacowany koszt (startowy i caÅ‚kowity). Im mniejszy, tym lepiej.\n\n\nrows=3\nSzacowana liczba wierszy, ktÃ³re speÅ‚niÄ… warunek.\n\n\nwidth=48\nÅšredni rozmiar jednego wiersza (w bajtach).\n\n\nIndex Cond\nWarunek, ktÃ³ry zostaÅ‚ uÅ¼yty do przeszukania indeksu.\n\n\nExecution Time\nFaktyczny czas wykonania (tylko w EXPLAIN ANALYZE).\n\n\n\n\n\nğŸ” PorÃ³wnanie: brak indeksu\nJeÅ›li usuniemy indeks i uruchomimy to samo zapytanie:\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\notrzymamy:\nSeq Scan on orders  (cost=0.00..450.00 rows=3 width=48)\n  Filter: (customer_id = 42)\nExecution Time: 22.5 ms\nğŸ“‰ RÃ³Å¼nica:\n\nBaza musi przeskanowaÄ‡ caÅ‚Ä… tabelÄ™ (Seq Scan),\nPomimo tego, Å¼e wynik jest ten sam, wykonanie jest znacznie wolniejsze.\n\nğŸ’¬ EXPLAIN pokazuje, Å¼e problemem nie jest zapytanie, lecz brak indeksu.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#jak-korzystaÄ‡-z-explain-w-praktyce",
    "href": "lectures/wyklad6.html#jak-korzystaÄ‡-z-explain-w-praktyce",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "ğŸ§® Jak korzystaÄ‡ z EXPLAIN w praktyce",
    "text": "ğŸ§® Jak korzystaÄ‡ z EXPLAIN w praktyce\n\nSprawdzaj, czy uÅ¼ywany jest indeks\n\nJeÅ›li widzisz Seq Scan lub SCAN TABLE, to znak, Å¼e indeks nie jest wykorzystywany.\n\nZwracaj uwagÄ™ na kolejnoÅ›Ä‡ JOINÃ³w\n\nCzasami odwrÃ³cenie kolejnoÅ›ci tabel w zapytaniu moÅ¼e daÄ‡ inny plan i lepszy czas.\n\nAnalizuj koszty (cost=â€¦)\n\nPorÃ³wnuj plany z rÃ³Å¼nymi indeksami i filtrami â€” wybieraj ten o niÅ¼szym koszcie.\n\nUÅ¼ywaj EXPLAIN ANALYZE tylko testowo\n\nW Å›rodowisku produkcyjnym EXPLAIN ANALYZE faktycznie wykonuje zapytanie, wiÄ™c moÅ¼e byÄ‡ kosztowne.\n\nPorÃ³wnuj teoretyczny i rzeczywisty plan\n\nJeÅ›li szacunki (rows, cost) mocno rÃ³Å¼niÄ… siÄ™ od rzeczywistego czasu, oznacza to:\n\nbrak aktualnych statystyk,\nzÅ‚y indeks,\nlub bÅ‚Ä™dne zaÅ‚oÅ¼enia optymalizatora.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#indeksy-w-sql",
    "href": "lectures/wyklad6.html#indeksy-w-sql",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "ğŸ—‚ï¸ Indeksy w SQL",
    "text": "ğŸ—‚ï¸ Indeksy w SQL\nIndeksy to podstawowe narzÄ™dzie optymalizacji zapytaÅ„, ktÃ³re pozwala bazie danych szybko znaleÅºÄ‡ potrzebne wiersze, bez koniecznoÅ›ci skanowania caÅ‚ej tabeli.\nMoÅ¼na je porÃ³wnaÄ‡ do spisu treÅ›ci w ksiÄ…Å¼ce â€” zamiast czytaÄ‡ kaÅ¼dy rozdziaÅ‚, patrzymy od razu na wÅ‚aÅ›ciwÄ… stronÄ™.\n\nğŸ”¹ Dlaczego indeksy sÄ… waÅ¼ne?\nBez indeksu baza danych musi sprawdziÄ‡ kaÅ¼dy wiersz tabeli, by znaleÅºÄ‡ pasujÄ…ce rekordy (sequential scan).\nZ indeksem, silnik moÅ¼e odczytaÄ‡ tylko te dane, ktÃ³re speÅ‚niajÄ… warunek â€” znacznie szybciej i przy mniejszym zuÅ¼yciu zasobÃ³w.\nKorzyÅ›ci z indeksÃ³w:\n\nâ±ï¸ Szybsze wyszukiwanie danych, szczegÃ³lnie w duÅ¼ych tabelach\n\nğŸ’¾ Ograniczenie operacji I/O, bo baza czyta mniej blokÃ³w z dysku\n\nğŸ”„ Przyspieszenie sortowania i Å‚Ä…czenia tabel (JOIN), jeÅ›li indeks obejmuje kolumny uÅ¼ywane w warunkach\n\n\n\nğŸ”¹ Rodzaje indeksÃ³w\nNajczÄ™Å›ciej spotykane:\n\nB-Tree (balanced tree) â€“ najpopularniejszy typ, sprawdza siÄ™ w wiÄ™kszoÅ›ci wyszukiwaÅ„, zakresÃ³w i sortowaÅ„\n\nHash â€“ szybki dostÄ™p po dokÅ‚adnej wartoÅ›ci (nie obsÅ‚uguje zakresÃ³w)\n\nBitmap â€“ efektywny dla kolumn o maÅ‚ej liczbie unikalnych wartoÅ›ci, np. pÅ‚eÄ‡ lub status\n\nKompozytowe â€“ obejmujÄ… kilka kolumn, przydatne przy filtrach i sortowaniach wielokolumnowych\n\n\n\nğŸ”¹ Co indeksuje?\n\nKolumny uÅ¼ywane w WHERE â€“ aby szybciej wyszukaÄ‡ dane\n\nKolumny uÅ¼ywane w JOIN â€“ przyspiesza Å‚Ä…czenie tabel\n\nKolumny w ORDER BY lub GROUP BY â€“ pomaga szybciej sortowaÄ‡ i grupowaÄ‡ wyniki\n\nKolumny unikalne lub klucze gÅ‚Ã³wne â€“ zapewnia integralnoÅ›Ä‡ danych i przyspiesza wyszukiwanie\n\n\n\nğŸ”¹ Wady nadmiaru indeksÃ³w\nIndeksy przyspieszajÄ… odczyt, ale majÄ… teÅ¼ koszty:\n\nğŸ”„ Spowolnienie operacji INSERT/UPDATE/DELETE, bo indeksy trzeba aktualizowaÄ‡\n\nğŸ’¾ ZwiÄ™kszone zuÅ¼ycie pamiÄ™ci i przestrzeni dyskowej\n\nâš–ï¸ Trzeba wybraÄ‡ optymalny zestaw indeksÃ³w, Å¼eby nie pogorszyÄ‡ ogÃ³lnej wydajnoÅ›ci",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#praktyczne-aspekty-uÅ¼ycia-indeksÃ³w",
    "href": "lectures/wyklad6.html#praktyczne-aspekty-uÅ¼ycia-indeksÃ³w",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "Praktyczne aspekty uÅ¼ycia indeksÃ³w",
    "text": "Praktyczne aspekty uÅ¼ycia indeksÃ³w\nW tej sekcji rozszerzamy temat indeksÃ³w, unikajÄ…c powtÃ³rzenia wczeÅ›niejszych przykÅ‚adÃ³w z SELECT po customer_id.\nPrzy Å‚Ä…czeniu tabel indeksy znaczÄ…co przyspieszajÄ… zapytania:\nSELECT o.id, c.name\nFROM orders o\nJOIN customers c ON o.customer_id = c.id\nWHERE c.region = 'Europe';\n\nIndeks na customers.id i orders.customer_id przyspiesza JOIN\nIndeks na customers.region przyspiesza filtrowanie po regionie",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#indeksy-a-sortowanie-i-grupowanie",
    "href": "lectures/wyklad6.html#indeksy-a-sortowanie-i-grupowanie",
    "title": "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL",
    "section": "Indeksy a sortowanie i grupowanie",
    "text": "Indeksy a sortowanie i grupowanie\nIndeksy na kolumnach uÅ¼ywanych w ORDER BY lub GROUP BY pozwalajÄ… uniknÄ…Ä‡ kosztownych operacji sortowania w pamiÄ™ci:\nSELECT customer_id, SUM(total) \nFROM orders \nGROUP BY customer_id \nORDER BY SUM(total) DESC;\n\nIndeks na customer_id moÅ¼e przyspieszyÄ‡ agregacjÄ™\nIndeks kompozytowy z kolumnÄ… uÅ¼ywanÄ… w ORDER BY moÅ¼e wyeliminowaÄ‡ dodatkowe sortowanie\n\nğŸ”¹ WpÅ‚yw indeksÃ³w na modyfikacje danych\n\nOperacje INSERT, UPDATE, DELETE wymagajÄ… aktualizacji indeksÃ³w\nZbyt wiele indeksÃ³w moÅ¼e spowolniÄ‡ zapis danych\nW praktyce wybieramy najbardziej potrzebne indeksy i monitorujemy ich wpÅ‚yw\n\nğŸ”¹ WskazÃ³wki praktyczne\n\nTwÃ³rz indeksy tylko na kolumnach czÄ™sto filtrowanych lub sortowanych\nAnalizuj plany wykonania (EXPLAIN, EXPLAIN ANALYZE)\nZwracaj uwagÄ™ na koszt operacji (cost=â€¦) i liczbÄ™ wierszy (rows=â€¦)\nRÃ³wnowaÅ¼ czas odczytu i zapis danych â€“ nie kaÅ¼dy indeks jest opÅ‚acalny",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html",
    "href": "lectures/wyklad5.html",
    "title": "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?",
    "section": "",
    "text": "ZÅ‚e zaprojektowanie struktury bazy danych prowadzi do wielu problemÃ³w:\n\n\nTo powielanie tych samych informacji w rÃ³Å¼nych miejscach bazy.\nPrzykÅ‚ad: jeÅ›li w kaÅ¼dej tabeli z zamÃ³wieniami przechowujemy peÅ‚ne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordÃ³w.\n\n\n\nBÅ‚Ä™dy i niekonsekwencje wynikajÄ…ce z nadmiarowej struktury danych.\n\nAnomalia aktualizacji â€“ zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykÅ‚adowcy w kilku wierszach tabeli.\nAnomalia wstawiania â€“ brak moÅ¼liwoÅ›ci dodania danych bez istnienia innych.\nNp. nie moÅ¼na dodaÄ‡ nowego kursu, dopÃ³ki nie zapisze siÄ™ na niego student.\nAnomalia usuwania â€“ usuniÄ™cie rekordu powoduje utratÄ™ innych informacji.\nNp. usuniÄ™cie ostatniego studenta z kursu powoduje utratÄ™ danych o samym kursie.\n\nğŸ‘‰ Wniosek: bÅ‚Ä™dy projektowe utrudniajÄ… utrzymanie spÃ³jnoÅ›ci danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#problemy-zÅ‚ego-projektu-bazy-danych",
    "href": "lectures/wyklad5.html#problemy-zÅ‚ego-projektu-bazy-danych",
    "title": "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?",
    "section": "",
    "text": "ZÅ‚e zaprojektowanie struktury bazy danych prowadzi do wielu problemÃ³w:\n\n\nTo powielanie tych samych informacji w rÃ³Å¼nych miejscach bazy.\nPrzykÅ‚ad: jeÅ›li w kaÅ¼dej tabeli z zamÃ³wieniami przechowujemy peÅ‚ne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordÃ³w.\n\n\n\nBÅ‚Ä™dy i niekonsekwencje wynikajÄ…ce z nadmiarowej struktury danych.\n\nAnomalia aktualizacji â€“ zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykÅ‚adowcy w kilku wierszach tabeli.\nAnomalia wstawiania â€“ brak moÅ¼liwoÅ›ci dodania danych bez istnienia innych.\nNp. nie moÅ¼na dodaÄ‡ nowego kursu, dopÃ³ki nie zapisze siÄ™ na niego student.\nAnomalia usuwania â€“ usuniÄ™cie rekordu powoduje utratÄ™ innych informacji.\nNp. usuniÄ™cie ostatniego studenta z kursu powoduje utratÄ™ danych o samym kursie.\n\nğŸ‘‰ Wniosek: bÅ‚Ä™dy projektowe utrudniajÄ… utrzymanie spÃ³jnoÅ›ci danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#zaleÅ¼noÅ›ci-funkcjonalne",
    "href": "lectures/wyklad5.html#zaleÅ¼noÅ›ci-funkcjonalne",
    "title": "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?",
    "section": "2. ZaleÅ¼noÅ›ci funkcjonalne",
    "text": "2. ZaleÅ¼noÅ›ci funkcjonalne\n\nğŸ”¹ Definicja\nZaleÅ¼noÅ›Ä‡ funkcjonalna (ang. functional dependency) opisuje relacjÄ™ miÄ™dzy atrybutami w tabeli.\nMÃ³wimy, Å¼e atrybut B jest funkcyjnie zaleÅ¼ny od atrybutu A (zapis:\nA â†’ B), jeÅ›li kaÅ¼dej wartoÅ›ci A odpowiada dokÅ‚adnie jedna wartoÅ›Ä‡ B.\n\n\nğŸ”¹ PrzykÅ‚ady\n\nNrIndeksu â†’ ImiÄ™, Nazwisko, Kierunek\n(kaÅ¼dy numer indeksu jednoznacznie identyfikuje studenta)\nKurs â†’ Sala, ProwadzÄ…cy\n(dany kurs odbywa siÄ™ zawsze w tej samej sali, prowadzony przez tÄ™ samÄ… osobÄ™)\n\n\n\nğŸ”¹ Klucze\n\nKlucz gÅ‚Ã³wny (primary key) â€“ jednoznacznie identyfikuje wiersz tabeli.\n\nKlucz kandydujÄ…cy (candidate key) â€“ minimalny zestaw atrybutÃ³w, ktÃ³ry moÅ¼e byÄ‡ kluczem.\n\nKlucz obcy (foreign key) â€“ wskazuje na klucz gÅ‚Ã³wny w innej tabeli i tworzy powiÄ…zanie miÄ™dzy tabelami.\n\n\n\nğŸ”¹ Typy zaleÅ¼noÅ›ci\n\nZaleÅ¼noÅ›Ä‡ peÅ‚na â€“ atrybut zaleÅ¼y od caÅ‚ego klucza zÅ‚oÅ¼onego.\n\nZaleÅ¼noÅ›Ä‡ czÄ™Å›ciowa â€“ atrybut zaleÅ¼y tylko od czÄ™Å›ci klucza.\n\nZaleÅ¼noÅ›Ä‡ przechodnia â€“ atrybut zaleÅ¼y poÅ›rednio od klucza (A â†’ B â†’ C).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#formy-normalne-1nf-3nf-bcnf",
    "href": "lectures/wyklad5.html#formy-normalne-1nf-3nf-bcnf",
    "title": "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?",
    "section": "3. Formy normalne (1NF â€“ 3NF, BCNF)",
    "text": "3. Formy normalne (1NF â€“ 3NF, BCNF)\nNormalizacja to proces przeksztaÅ‚cania tabel w taki sposÃ³b, aby usunÄ…Ä‡ redundancjÄ™ i zapobiec anomaliom.\n\nğŸ§© Pierwsza postaÄ‡ normalna (1NF)\n\nWszystkie wartoÅ›ci w tabeli sÄ… atomowe (niepodzielne).\n\nBrak list, zbiorÃ³w lub kolumn powtarzajÄ…cych siÄ™.\n\nâœ… KaÅ¼da kolumna ma jednÄ… wartoÅ›Ä‡ w komÃ³rce.\nPrzykÅ‚ad (naruszenie 1NF):\n\n\n\nStudent\nNrIndeksu\nKursy\n\n\n\n\nJan Nowak\n12345\nBazy danych, Programowanie\n\n\n\nâœ… Poprawnie:\nTworzymy osobnÄ… tabelÄ™ STUDENT_KURS, gdzie kaÅ¼dy kurs to osobny rekord.\n\n\n\nğŸ§© Druga postaÄ‡ normalna (2NF)\n\nTabela jest w 1NF i wszystkie atrybuty niekluczowe zaleÅ¼Ä… w peÅ‚ni od caÅ‚ego klucza gÅ‚Ã³wnego.\n\nDotyczy tabel z kluczem zÅ‚oÅ¼onym.\n\nPrzykÅ‚ad:\nTabela ZAPISY(StudentID, KursID, Sala)\nâ†’ atrybut Sala zaleÅ¼y tylko od KursID, a nie od caÅ‚ego klucza (StudentID, KursID).\nRozwiÄ…zanie: wydziel tabelÄ™ KURS(KursID, Sala).\n\n\n\nğŸ§© Trzecia postaÄ‡ normalna (3NF)\n\nTabela jest w 2NF i nie zawiera zaleÅ¼noÅ›ci przechodnich.\n\nKaÅ¼dy atrybut niekluczowy zaleÅ¼y bezpoÅ›rednio od klucza gÅ‚Ã³wnego.\n\nPrzykÅ‚ad:\nNrIndeksu â†’ Kierunek, Kierunek â†’ Dziekan\nâ¡ï¸ Dziekan zaleÅ¼y poÅ›rednio od NrIndeksu.\nRozwiÄ…zanie: osobna tabela KIERUNEK(Dziekan, Kierunek).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#diagramy-erd-entityrelationship-diagram",
    "href": "lectures/wyklad5.html#diagramy-erd-entityrelationship-diagram",
    "title": "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?",
    "section": "4. Diagramy ERD (Entityâ€“Relationship Diagram)",
    "text": "4. Diagramy ERD (Entityâ€“Relationship Diagram)\nDiagram ERD jest graficznym sposobem przedstawienia modelu konceptualnego bazy danych.\n\nğŸ”¹ GÅ‚Ã³wne elementy ERD\n\nEncja (Entity) â€“ obiekt, o ktÃ³rym przechowujemy dane (np. Student, Kurs).\n\nAtrybut (Attribute) â€“ wÅ‚aÅ›ciwoÅ›Ä‡ encji (np. ImiÄ™, Nazwisko, NrIndeksu).\n\nRelacja (Relationship) â€“ powiÄ…zanie miÄ™dzy encjami (np. Student zapisuje siÄ™ na Kurs).\n\nKardynalnoÅ›Ä‡ (Cardinality) â€“ okreÅ›la licznoÅ›Ä‡ relacji:\n\n1:1 (jeden do jednego)\n\n1:N (jeden do wielu)\n\nN:M (wielu do wielu)\n\n\nIdentyfikator (Primary Key) â€“ atrybut jednoznacznie identyfikujÄ…cy encjÄ™.\n\n\n\nğŸ”¹ PrzykÅ‚ad:\nSTUDENT (NrIndeksu, ImiÄ™, Nazwisko, Kierunek)\nKURS (KursID, Nazwa, ProwadzÄ…cy)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nRelacja miÄ™dzy STUDENT a KURS: N:M poprzez encjÄ™ poÅ›redniczÄ…cÄ… ZAPIS.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#proces-projektowania-bazy-danych",
    "href": "lectures/wyklad5.html#proces-projektowania-bazy-danych",
    "title": "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?",
    "section": "5. Proces projektowania bazy danych",
    "text": "5. Proces projektowania bazy danych\nProjektowanie bazy to proces etapowy:\n\nAnaliza wymagaÅ„ â€“ zrozumienie, jakie dane sÄ… potrzebne i jakie operacje bÄ™dÄ… wykonywane.\n\nModel konceptualny â€“ opis danych w postaci ERD.\n\nModel logiczny â€“ zamiana modelu ERD na relacyjny schemat tabel.\n\nModel fizyczny â€“ implementacja w konkretnym systemie DBMS (np. PostgreSQL, MySQL).\n\n\nDokumentacja SQLite\nDokumentacja PostgreSQL\nA. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Celem wykÅ‚adu jest zapoznanie siÄ™ z podstawami relacyjnych baz danych â€” ich historiÄ…, pojÄ™ciami, architekturÄ…, strukturÄ… danych oraz zasadami integralnoÅ›ci. Po tym wykÅ‚adzie student powinien rozumieÄ‡, czym jest baza danych, jak dziaÅ‚a DBMS, co oznacza model relacyjny oraz jakie sÄ… klucze i reguÅ‚y spÃ³jnoÅ›ci danych.\n\n\n\nBazy danych nie sÄ… wynalazkiem XXI wieku â€” ich poczÄ…tki siÄ™gajÄ… lat 60. XX wieku, gdy organizacje zaczÄ™Å‚y gromadziÄ‡ coraz wiÄ™ksze iloÅ›ci danych.\n\n\nPierwsze systemy przechowywaÅ‚y dane w plikach na dyskach. ChoÄ‡ byÅ‚y proste, miaÅ‚y powaÅ¼ne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudnoÅ›Ä‡ w utrzymaniu spÃ³jnoÅ›ci\nBrak uniwersalnych narzÄ™dzi do wyszukiwania\n\nğŸ’¡ Zadanie: Na jakich innych obiektach, oprÃ³cz plikÃ³w, moÅ¼na pracowaÄ‡ w systemach operacyjnych?\n\n\n\nW latach 60. i 70. pojawiÅ‚y siÄ™ pierwsze systemy zarzÄ…dzania bazami danych (DBMS). ZapewniaÅ‚y:\n\ncentralnÄ… kontrolÄ™ danych,\nintegralnoÅ›Ä‡ i bezpieczeÅ„stwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n\nWczesne systemy wykorzystywaÅ‚y struktury drzewiaste lub grafowe. ByÅ‚y skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n\nW 1970 roku Edgar F. Codd zaproponowaÅ‚ model relacyjny danych, w ktÃ³rym:\n\ndane sÄ… przechowywane w tabelach (relacjach),\nkaÅ¼da tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystoÅ›Ä‡,\nelastycznoÅ›Ä‡ (Å‚atwo dodawaÄ‡ nowe tabele),\nbezpieczeÅ„stwo i spÃ³jnoÅ›Ä‡ danych.\n\n\n\n\nWraz z rozwojem modelu relacyjnego powstaÅ‚ SQL (Structured Query Language) â€“ jÄ™zyk do tworzenia, modyfikowania i pobierania danych.\nDziÅ› SQL jest fundamentem wiÄ™kszoÅ›ci systemÃ³w: od aplikacji biurowych po duÅ¼e systemy korporacyjne. Nawet wspÃ³Å‚czesne rozwiÄ…zania NoSQL czÄ™sto nawiÄ…zujÄ… do idei relacyjnych.\n\n\n\n\n\n\n\nDane â€“ surowe fakty, liczby, teksty, ktÃ³re same w sobie niewiele znaczÄ…. ğŸ‘‰ np. 25, Warszawa, 12345\nInformacja â€“ dane zinterpretowane i zorganizowane w kontekÅ›cie. ğŸ‘‰ np. â€25 klientÃ³w z Warszawy zÅ‚oÅ¼yÅ‚o zamÃ³wienie w ostatnim tygodniuâ€.\n\nDane to materiaÅ‚, informacja to znaczenie.\n\n\n\nZorganizowany zbiÃ³r danych umoÅ¼liwiajÄ…cy ich Å‚atwe przeszukiwanie, aktualizacjÄ™ i analizÄ™.\nCechy:\n\nStrukturalnoÅ›Ä‡\nCentralizacja\nTrwaÅ‚oÅ›Ä‡ i bezpieczeÅ„stwo\n\nPrzykÅ‚ady:\n\nLista kontaktÃ³w w telefonie\nSystem rezerwacji hotelowej\nSklep internetowy\n\nTermin ,,baza danychâ€™â€™ uzywany jest na wiele rÃ³znych sposobÃ³w, ale na wykÅ‚adzie baza danych oznacza zbiÃ³r danych przechowywanych w pewien zorganizowany sposÃ³b. NajproÅ›ciej wyobraziÄ‡ sobie bazÄ™ danych jako szafkÄ™ na dokumenty. Jest to miejsce umozliwiajÄ…ce przechowywanie informacji, niezaleznie od ich typu i sposobu organizacji.\n\n\n\nBardzo czÄ™sto uzywamy terminu â€œbaza danychâ€ do okreÅ›lenia oprogramowania bazy danych, ktÃ³rego uzywamy. Takie podejÅ›cie jest bÅ‚Ä™dne i powoduje wiele nieporozumieÅ„. Oprogramowanie BD nazywane jest poprawnie sustemem zarzÄ…dzania bazÄ… danych (SZBD) lub (DBMS - Database Management System). Sama baza danych jest pojemnikiem tworzonym i modyfikowanym przez SZBD. Konkretna postaÄ‡ BD zienia siÄ™ w zaleznoÅ›ci od zastosowaÅ„.\nOprogramowanie do tworzenia, modyfikowania i przetwarzania baz danych.\nFunkcje DBMS:\n\nTworzenie i modyfikacja schematÃ³w\nOperacje CRUD (Create, Read, Update, Delete)\nZarzÄ…dzanie bezpieczeÅ„stwem i uprawnieniami\nOptymalizacja zapytaÅ„\n\nPrzykÅ‚ady: MySQL, PostgreSQL, Oracle, SQL Server, SQLite.\n\n\n\n\nSystemy baz danych sÄ… zorganizowane wedÅ‚ug poziomÃ³w abstrakcji, co pozwala oddzieliÄ‡ sposÃ³b przechowywania danych od ich widoku dla uÅ¼ytkownika.\n\n\n\nPoziom fizyczny (wewnÄ™trzny)\n\n\nopisuje sposÃ³b przechowywania danych (pliki, indeksy, struktury).\n\n\nPoziom logiczny (poÅ›redni)\n\n\nopisuje strukturÄ™ danych (tabele, relacje, typy danych).\n\n\nPoziom zewnÄ™trzny (widok uÅ¼ytkownika)\n\n\npokazuje dane z perspektywy uÅ¼ytkownika lub aplikacji.\n\nZmiany w jednym poziomie nie wymagajÄ… zmian w pozostaÅ‚ych â€” to tzw. niezaleÅ¼noÅ›Ä‡ danych.\n\n\n\nFormalny model trÃ³jpoziomowy:\n\npoziom wewnÄ™trzny â€“ fizyczne przechowywanie danych,\npoziom pojÄ™ciowy â€“ logiczna struktura bazy,\npoziom zewnÄ™trzny â€“ widoki uÅ¼ytkownikÃ³w.\n\nZalety:\n\nizolacja danych,\nbezpieczeÅ„stwo,\nelastycznoÅ›Ä‡ i skalowalnoÅ›Ä‡.\n\n\n\n\n\n\n\nTABELA to:\n\nZbiÃ³r danych o tej samej strukturze.\nUporzÄ…dkowana lista zawierajÄ…ca dane okreÅ›lonego typu\n\nKaÅ¼da tabela opisuje jeden typ obiektÃ³w (np. Studenci, Kursy).\nNajwazniejsze, ze tabela przechowuje dane jednego typu. W jednej tabeli nie pojawi siÄ™ jednoczeÅ›nie lista kontaktÃ³w i lista zamÃ³wieÅ„. &gt; Uwaga: Technicznie taka tabela jest mozliwa do realizacji ale pobieranie konkretnych elementÃ³w &gt; byÅ‚oby znacznie utrudnione.\n\nUwaga: Kazda tabela posiada nazwÄ™ pozwalajÄ…cÄ… jednoznacznie jÄ… zidentyfikowaÄ‡. Nazwa zawsze jest unikalna - zadna inna tabela nie moze mieÄ‡ takiej samej nazwy.\n\n\n\n\nPojedynczy rekord w tabeli (np. dane jednego studenta).\n\n\n\nWÅ‚aÅ›ciwoÅ›Ä‡ obiektu â€“ ma nazwÄ™ i typ danych (np. ImiÄ™, Nazwisko, NrIndeksu).\n\n\n\nZbiÃ³r dopuszczalnych wartoÅ›ci atrybutu (np. liczby caÅ‚kowite, ciÄ…gi znakÃ³w do 50 znakÃ³w).\n\n\n\n\nSchemat relacji â€“ struktura tabeli (nazwy kolumn, typy).\nInstancja relacji â€“ aktualna zawartoÅ›Ä‡ tabeli.\n\n\n\n\n\n\n\n\njednoznacznie identyfikuje kaÅ¼dy rekord,\nnie moÅ¼e mieÄ‡ wartoÅ›ci NULL.\n\nPrzykÅ‚ad: NrIndeksu w tabeli Studenci.\n\n\n\n\nkaÅ¼dy atrybut (lub ich kombinacja), ktÃ³ry mÃ³gÅ‚by byÄ‡ kluczem gÅ‚Ã³wnym. PrzykÅ‚ad: NrIndeksu i PESEL â€“ wybieramy jeden jako gÅ‚Ã³wny.\n\n\n\n\n\natrybut wskazujÄ…cy na klucz gÅ‚Ã³wny w innej tabeli. PrzykÅ‚ad: NrIndeksu w tabeli Oceny odnosi siÄ™ do Studenci.\n\n\n\n\n\nIntegralnoÅ›Ä‡ encji â€“ kaÅ¼da krotka musi byÄ‡ jednoznacznie identyfikowana.\nIntegralnoÅ›Ä‡ referencyjna â€“ wartoÅ›ci kluczy obcych muszÄ… istnieÄ‡ w tabelach nadrzÄ™dnych.\nIntegralnoÅ›Ä‡ dziedzinowa â€“ wartoÅ›ci atrybutÃ³w muszÄ… mieÅ›ciÄ‡ siÄ™ w swoich domenach.\n\n\n\n\n\n\n\n\nKto zaproponowaÅ‚ model relacyjny danych?\n\n\nDonald Knuth\nEdgar F. Codd\nBill Gates\nCharles Bachman\n\n\nCo opisuje poziom logiczny w architekturze ANSI/SPARC?\n\n\nSposÃ³b fizycznego zapisu danych\nWidok danych przez uÅ¼ytkownika\nStrukturÄ™ danych i relac\n\nâœï¸ Pytania otwarte / opisowe\n\nWyjaÅ›nij rÃ³Å¼nicÄ™ miÄ™dzy danymi a informacjÄ….\nWymieÅ„ i krÃ³tko opisz trzy poziomy abstrakcji w modelu ANSI/SPARC.\nCo to jest klucz gÅ‚Ã³wny i jakie sÄ… jego cechy?\nPodaj przykÅ‚ad relacji i wskaÅ¼ w niej krotki oraz atrybuty.\nDlaczego model relacyjny okazaÅ‚ siÄ™ przeÅ‚omem w historii baz danych?\nJakie sÄ… trzy podstawowe zasady integralnoÅ›ci danych?",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#wprowadzenie-i-cele-wykÅ‚adu",
    "href": "lectures/wyklad1.html#wprowadzenie-i-cele-wykÅ‚adu",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Celem wykÅ‚adu jest zapoznanie siÄ™ z podstawami relacyjnych baz danych â€” ich historiÄ…, pojÄ™ciami, architekturÄ…, strukturÄ… danych oraz zasadami integralnoÅ›ci. Po tym wykÅ‚adzie student powinien rozumieÄ‡, czym jest baza danych, jak dziaÅ‚a DBMS, co oznacza model relacyjny oraz jakie sÄ… klucze i reguÅ‚y spÃ³jnoÅ›ci danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "href": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Bazy danych nie sÄ… wynalazkiem XXI wieku â€” ich poczÄ…tki siÄ™gajÄ… lat 60. XX wieku, gdy organizacje zaczÄ™Å‚y gromadziÄ‡ coraz wiÄ™ksze iloÅ›ci danych.\n\n\nPierwsze systemy przechowywaÅ‚y dane w plikach na dyskach. ChoÄ‡ byÅ‚y proste, miaÅ‚y powaÅ¼ne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudnoÅ›Ä‡ w utrzymaniu spÃ³jnoÅ›ci\nBrak uniwersalnych narzÄ™dzi do wyszukiwania\n\nğŸ’¡ Zadanie: Na jakich innych obiektach, oprÃ³cz plikÃ³w, moÅ¼na pracowaÄ‡ w systemach operacyjnych?\n\n\n\nW latach 60. i 70. pojawiÅ‚y siÄ™ pierwsze systemy zarzÄ…dzania bazami danych (DBMS). ZapewniaÅ‚y:\n\ncentralnÄ… kontrolÄ™ danych,\nintegralnoÅ›Ä‡ i bezpieczeÅ„stwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n\nWczesne systemy wykorzystywaÅ‚y struktury drzewiaste lub grafowe. ByÅ‚y skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n\nW 1970 roku Edgar F. Codd zaproponowaÅ‚ model relacyjny danych, w ktÃ³rym:\n\ndane sÄ… przechowywane w tabelach (relacjach),\nkaÅ¼da tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystoÅ›Ä‡,\nelastycznoÅ›Ä‡ (Å‚atwo dodawaÄ‡ nowe tabele),\nbezpieczeÅ„stwo i spÃ³jnoÅ›Ä‡ danych.\n\n\n\n\nWraz z rozwojem modelu relacyjnego powstaÅ‚ SQL (Structured Query Language) â€“ jÄ™zyk do tworzenia, modyfikowania i pobierania danych.\nDziÅ› SQL jest fundamentem wiÄ™kszoÅ›ci systemÃ³w: od aplikacji biurowych po duÅ¼e systemy korporacyjne. Nawet wspÃ³Å‚czesne rozwiÄ…zania NoSQL czÄ™sto nawiÄ…zujÄ… do idei relacyjnych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "href": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Dane â€“ surowe fakty, liczby, teksty, ktÃ³re same w sobie niewiele znaczÄ…. ğŸ‘‰ np. 25, Warszawa, 12345\nInformacja â€“ dane zinterpretowane i zorganizowane w kontekÅ›cie. ğŸ‘‰ np. â€25 klientÃ³w z Warszawy zÅ‚oÅ¼yÅ‚o zamÃ³wienie w ostatnim tygodniuâ€.\n\nDane to materiaÅ‚, informacja to znaczenie.\n\n\n\nZorganizowany zbiÃ³r danych umoÅ¼liwiajÄ…cy ich Å‚atwe przeszukiwanie, aktualizacjÄ™ i analizÄ™.\nCechy:\n\nStrukturalnoÅ›Ä‡\nCentralizacja\nTrwaÅ‚oÅ›Ä‡ i bezpieczeÅ„stwo\n\nPrzykÅ‚ady:\n\nLista kontaktÃ³w w telefonie\nSystem rezerwacji hotelowej\nSklep internetowy\n\nTermin ,,baza danychâ€™â€™ uzywany jest na wiele rÃ³znych sposobÃ³w, ale na wykÅ‚adzie baza danych oznacza zbiÃ³r danych przechowywanych w pewien zorganizowany sposÃ³b. NajproÅ›ciej wyobraziÄ‡ sobie bazÄ™ danych jako szafkÄ™ na dokumenty. Jest to miejsce umozliwiajÄ…ce przechowywanie informacji, niezaleznie od ich typu i sposobu organizacji.\n\n\n\nBardzo czÄ™sto uzywamy terminu â€œbaza danychâ€ do okreÅ›lenia oprogramowania bazy danych, ktÃ³rego uzywamy. Takie podejÅ›cie jest bÅ‚Ä™dne i powoduje wiele nieporozumieÅ„. Oprogramowanie BD nazywane jest poprawnie sustemem zarzÄ…dzania bazÄ… danych (SZBD) lub (DBMS - Database Management System). Sama baza danych jest pojemnikiem tworzonym i modyfikowanym przez SZBD. Konkretna postaÄ‡ BD zienia siÄ™ w zaleznoÅ›ci od zastosowaÅ„.\nOprogramowanie do tworzenia, modyfikowania i przetwarzania baz danych.\nFunkcje DBMS:\n\nTworzenie i modyfikacja schematÃ³w\nOperacje CRUD (Create, Read, Update, Delete)\nZarzÄ…dzanie bezpieczeÅ„stwem i uprawnieniami\nOptymalizacja zapytaÅ„\n\nPrzykÅ‚ady: MySQL, PostgreSQL, Oracle, SQL Server, SQLite.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#architektura-systemÃ³w-baz-danych",
    "href": "lectures/wyklad1.html#architektura-systemÃ³w-baz-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Systemy baz danych sÄ… zorganizowane wedÅ‚ug poziomÃ³w abstrakcji, co pozwala oddzieliÄ‡ sposÃ³b przechowywania danych od ich widoku dla uÅ¼ytkownika.\n\n\n\nPoziom fizyczny (wewnÄ™trzny)\n\n\nopisuje sposÃ³b przechowywania danych (pliki, indeksy, struktury).\n\n\nPoziom logiczny (poÅ›redni)\n\n\nopisuje strukturÄ™ danych (tabele, relacje, typy danych).\n\n\nPoziom zewnÄ™trzny (widok uÅ¼ytkownika)\n\n\npokazuje dane z perspektywy uÅ¼ytkownika lub aplikacji.\n\nZmiany w jednym poziomie nie wymagajÄ… zmian w pozostaÅ‚ych â€” to tzw. niezaleÅ¼noÅ›Ä‡ danych.\n\n\n\nFormalny model trÃ³jpoziomowy:\n\npoziom wewnÄ™trzny â€“ fizyczne przechowywanie danych,\npoziom pojÄ™ciowy â€“ logiczna struktura bazy,\npoziom zewnÄ™trzny â€“ widoki uÅ¼ytkownikÃ³w.\n\nZalety:\n\nizolacja danych,\nbezpieczeÅ„stwo,\nelastycznoÅ›Ä‡ i skalowalnoÅ›Ä‡.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#model-relacyjny",
    "href": "lectures/wyklad1.html#model-relacyjny",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "TABELA to:\n\nZbiÃ³r danych o tej samej strukturze.\nUporzÄ…dkowana lista zawierajÄ…ca dane okreÅ›lonego typu\n\nKaÅ¼da tabela opisuje jeden typ obiektÃ³w (np. Studenci, Kursy).\nNajwazniejsze, ze tabela przechowuje dane jednego typu. W jednej tabeli nie pojawi siÄ™ jednoczeÅ›nie lista kontaktÃ³w i lista zamÃ³wieÅ„. &gt; Uwaga: Technicznie taka tabela jest mozliwa do realizacji ale pobieranie konkretnych elementÃ³w &gt; byÅ‚oby znacznie utrudnione.\n\nUwaga: Kazda tabela posiada nazwÄ™ pozwalajÄ…cÄ… jednoznacznie jÄ… zidentyfikowaÄ‡. Nazwa zawsze jest unikalna - zadna inna tabela nie moze mieÄ‡ takiej samej nazwy.\n\n\n\n\nPojedynczy rekord w tabeli (np. dane jednego studenta).\n\n\n\nWÅ‚aÅ›ciwoÅ›Ä‡ obiektu â€“ ma nazwÄ™ i typ danych (np. ImiÄ™, Nazwisko, NrIndeksu).\n\n\n\nZbiÃ³r dopuszczalnych wartoÅ›ci atrybutu (np. liczby caÅ‚kowite, ciÄ…gi znakÃ³w do 50 znakÃ³w).\n\n\n\n\nSchemat relacji â€“ struktura tabeli (nazwy kolumn, typy).\nInstancja relacji â€“ aktualna zawartoÅ›Ä‡ tabeli.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#klucze-i-integralnoÅ›Ä‡-danych",
    "href": "lectures/wyklad1.html#klucze-i-integralnoÅ›Ä‡-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "jednoznacznie identyfikuje kaÅ¼dy rekord,\nnie moÅ¼e mieÄ‡ wartoÅ›ci NULL.\n\nPrzykÅ‚ad: NrIndeksu w tabeli Studenci.\n\n\n\n\nkaÅ¼dy atrybut (lub ich kombinacja), ktÃ³ry mÃ³gÅ‚by byÄ‡ kluczem gÅ‚Ã³wnym. PrzykÅ‚ad: NrIndeksu i PESEL â€“ wybieramy jeden jako gÅ‚Ã³wny.\n\n\n\n\n\natrybut wskazujÄ…cy na klucz gÅ‚Ã³wny w innej tabeli. PrzykÅ‚ad: NrIndeksu w tabeli Oceny odnosi siÄ™ do Studenci.\n\n\n\n\n\nIntegralnoÅ›Ä‡ encji â€“ kaÅ¼da krotka musi byÄ‡ jednoznacznie identyfikowana.\nIntegralnoÅ›Ä‡ referencyjna â€“ wartoÅ›ci kluczy obcych muszÄ… istnieÄ‡ w tabelach nadrzÄ™dnych.\nIntegralnoÅ›Ä‡ dziedzinowa â€“ wartoÅ›ci atrybutÃ³w muszÄ… mieÅ›ciÄ‡ siÄ™ w swoich domenach.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#zestaw-pytaÅ„-testowych",
    "href": "lectures/wyklad1.html#zestaw-pytaÅ„-testowych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Kto zaproponowaÅ‚ model relacyjny danych?\n\n\nDonald Knuth\nEdgar F. Codd\nBill Gates\nCharles Bachman\n\n\nCo opisuje poziom logiczny w architekturze ANSI/SPARC?\n\n\nSposÃ³b fizycznego zapisu danych\nWidok danych przez uÅ¼ytkownika\nStrukturÄ™ danych i relac\n\nâœï¸ Pytania otwarte / opisowe\n\nWyjaÅ›nij rÃ³Å¼nicÄ™ miÄ™dzy danymi a informacjÄ….\nWymieÅ„ i krÃ³tko opisz trzy poziomy abstrakcji w modelu ANSI/SPARC.\nCo to jest klucz gÅ‚Ã³wny i jakie sÄ… jego cechy?\nPodaj przykÅ‚ad relacji i wskaÅ¼ w niej krotki oraz atrybuty.\nDlaczego model relacyjny okazaÅ‚ siÄ™ przeÅ‚omem w historii baz danych?\nJakie sÄ… trzy podstawowe zasady integralnoÅ›ci danych?",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)",
    "section": "",
    "text": "KaÅ¼dy projekt bazy danych zaczyna siÄ™ od zrozumienia czego oczekuje uÅ¼ytkownik. Bez tego Å‚atwo stworzyÄ‡ system, ktÃ³ry jest poprawny technicznie, ale bezuÅ¼yteczny w praktyce.\nPrzykÅ‚ad 1 â€“ biblioteka\nBiblioteka chce mieÄ‡ system, ktÃ³ry przechowuje dane o:\n\nksiÄ…Å¼kach (tytuÅ‚, autor, rok wydania, ISBN),\nczytelnikach (imiÄ™, nazwisko, numer karty bibliotecznej),\nwypoÅ¼yczeniach (jaka ksiÄ…Å¼ka, ktÃ³ry czytelnik, kiedy wypoÅ¼yczona i kiedy oddana).\n\nPrzykÅ‚ad 2 â€“ sklep internetowy\nSklep potrzebuje informacji o:\n\nklientach (imiÄ™, adres, e-mail),\nproduktach (nazwa, cena, kategoria),\nzamÃ³wieniach (ktÃ³ry klient, jakie produkty, kiedy zÅ‚oÅ¼ono, status zamÃ³wienia).\n\nğŸ‘‰ ZwrÃ³Ä‡ uwagÄ™:\n\nw bibliotece najwaÅ¼niejszy jest zwiÄ…zek wypoÅ¼yczeÅ„,\nw sklepie â€“ zwiÄ…zek zamÃ³wieÅ„.\n\nJuÅ¼ na tym etapie widaÄ‡, Å¼e kluczowe sÄ… powiÄ…zania, a nie tylko same dane.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#analiza-wymagaÅ„-uÅ¼ytkownika",
    "href": "lectures/wyklad2.html#analiza-wymagaÅ„-uÅ¼ytkownika",
    "title": "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)",
    "section": "",
    "text": "KaÅ¼dy projekt bazy danych zaczyna siÄ™ od zrozumienia czego oczekuje uÅ¼ytkownik. Bez tego Å‚atwo stworzyÄ‡ system, ktÃ³ry jest poprawny technicznie, ale bezuÅ¼yteczny w praktyce.\nPrzykÅ‚ad 1 â€“ biblioteka\nBiblioteka chce mieÄ‡ system, ktÃ³ry przechowuje dane o:\n\nksiÄ…Å¼kach (tytuÅ‚, autor, rok wydania, ISBN),\nczytelnikach (imiÄ™, nazwisko, numer karty bibliotecznej),\nwypoÅ¼yczeniach (jaka ksiÄ…Å¼ka, ktÃ³ry czytelnik, kiedy wypoÅ¼yczona i kiedy oddana).\n\nPrzykÅ‚ad 2 â€“ sklep internetowy\nSklep potrzebuje informacji o:\n\nklientach (imiÄ™, adres, e-mail),\nproduktach (nazwa, cena, kategoria),\nzamÃ³wieniach (ktÃ³ry klient, jakie produkty, kiedy zÅ‚oÅ¼ono, status zamÃ³wienia).\n\nğŸ‘‰ ZwrÃ³Ä‡ uwagÄ™:\n\nw bibliotece najwaÅ¼niejszy jest zwiÄ…zek wypoÅ¼yczeÅ„,\nw sklepie â€“ zwiÄ…zek zamÃ³wieÅ„.\n\nJuÅ¼ na tym etapie widaÄ‡, Å¼e kluczowe sÄ… powiÄ…zania, a nie tylko same dane.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#diagramy-encjazwiÄ…zek",
    "href": "lectures/wyklad2.html#diagramy-encjazwiÄ…zek",
    "title": "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)",
    "section": "Diagramy encjaâ€“zwiÄ…zek",
    "text": "Diagramy encjaâ€“zwiÄ…zek\nModel ERD (Entityâ€“Relationship Diagram) pozwala w przejrzysty sposÃ³b przedstawiÄ‡ jakie obiekty istniejÄ… w systemie i jak sÄ… ze sobÄ… powiÄ…zane.\n\nEncje rysujemy jako prostokÄ…ty.\nPrzykÅ‚ad: â€Studentâ€, â€KsiÄ…Å¼kaâ€, â€ZamÃ³wienieâ€.\nAtrybuty zapisujemy jako elipsy i Å‚Ä…czymy z encjÄ….\nâ€Studentâ€ â†’ ImiÄ™, Nazwisko, NrIndeksu.\nZwiÄ…zki przedstawiamy jako romby.\nâ€Studentâ€ \\(\\to\\) â€WypoÅ¼yczaâ€ \\(\\to\\) â€KsiÄ…Å¼kaâ€.\n\nPrzykÅ‚ad wizualny do opowiedzenia:\n\nWyobraÅºcie sobie trzy prostokÄ…ty: â€Studentâ€, â€KsiÄ…Å¼kaâ€ i â€Bibliotekarzâ€.\nÅÄ…czymy je rombem â€WypoÅ¼yczaâ€.\nDodajemy atrybuty: do studenta â€NrIndeksuâ€, do ksiÄ…Å¼ki â€ISBNâ€, a do zwiÄ…zku â€Data wypoÅ¼yczeniaâ€.\n\nğŸ‘‰ DziÄ™ki temu widzimy nie tylko obiekty, ale i relacje miÄ™dzy nimi.\nâ¸»",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#typy-zwiÄ…zkÃ³w",
    "href": "lectures/wyklad2.html#typy-zwiÄ…zkÃ³w",
    "title": "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)",
    "section": "Typy zwiÄ…zkÃ³w",
    "text": "Typy zwiÄ…zkÃ³w\nZwiÄ…zek 1:1 (jeden do jednego)\n\nKaÅ¼dy obiekt jednej encji odpowiada najwyÅ¼ej jednemu obiektowi drugiej encji.\nPrzykÅ‚ad: kaÅ¼dy czÅ‚owiek ma jedno unikalne PESEL.\n\nZwiÄ…zek 1:N (jeden do wielu)\n\nJeden obiekt encji A moÅ¼e byÄ‡ powiÄ…zany z wieloma obiektami encji B, ale nie odwrotnie.\nPrzykÅ‚ad: jeden wykÅ‚adowca prowadzi wiele kursÃ³w, ale kaÅ¼dy kurs ma dokÅ‚adnie jednego prowadzÄ…cego.\n\nZwiÄ…zek N:M (wiele do wielu)\n\nJeden obiekt encji A moÅ¼e byÄ‡ powiÄ…zany z wieloma obiektami encji B i odwrotnie.\nPrzykÅ‚ad: studenci zapisujÄ… siÄ™ na wiele kursÃ³w, a kaÅ¼dy kurs realizowany jest przez wielu studentÃ³w.\n\nMini-case: kino\n\nEncje: â€Filmâ€, â€Widzâ€, â€Seansâ€.\nWidzowie mogÄ… oglÄ…daÄ‡ wiele filmÃ³w, a kaÅ¼dy film moÅ¼e byÄ‡ oglÄ…dany przez wielu widzÃ³w. To klasyczne N:M.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#atrybuty-proste-zÅ‚oÅ¼one-wielowartoÅ›ciowe",
    "href": "lectures/wyklad2.html#atrybuty-proste-zÅ‚oÅ¼one-wielowartoÅ›ciowe",
    "title": "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)",
    "section": "Atrybuty proste, zÅ‚oÅ¼one, wielowartoÅ›ciowe",
    "text": "Atrybuty proste, zÅ‚oÅ¼one, wielowartoÅ›ciowe\n\nAtrybut prosty â€“ nie da siÄ™ go podzieliÄ‡: â€Data urodzeniaâ€, â€PESELâ€.\nAtrybut zÅ‚oÅ¼ony â€“ skÅ‚ada siÄ™ z mniejszych: â€Adresâ€ â†’ â€Ulicaâ€, â€Kod pocztowyâ€, â€Miastoâ€.\nAtrybut wielowartoÅ›ciowy â€“ moÅ¼e mieÄ‡ wiele wartoÅ›ci dla jednej encji: â€Numery telefonÃ³wâ€ dla jednego studenta.\n\nğŸ‘‰ To waÅ¼ne, bo w pÃ³Åºniejszym projektowaniu relacyjnym atrybut wielowartoÅ›ciowy czÄ™sto trzeba przeksztaÅ‚ciÄ‡ w oddzielnÄ… tabelÄ™.\nPrzykÅ‚ad:\n\nStudent moÅ¼e mieÄ‡ wiele adresÃ³w e-mail.\nW modelu ER narysujemy atrybut â€Emailâ€ jako elipsÄ™ podwÃ³jnÄ….\nW modelu relacyjnym â€“ stworzymy tabelÄ™ â€AdresyEmailâ€ powiÄ…zanÄ… z tabelÄ… â€Studenciâ€.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#przykÅ‚ady-caÅ‚oÅ›ciowe",
    "href": "lectures/wyklad2.html#przykÅ‚ady-caÅ‚oÅ›ciowe",
    "title": "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)",
    "section": "PrzykÅ‚ady caÅ‚oÅ›ciowe",
    "text": "PrzykÅ‚ady caÅ‚oÅ›ciowe\nNa koniec moÅ¼emy omÃ³wiÄ‡ kilka kompletnych mini-systemÃ³w, Å¼eby pokazaÄ‡ rÃ³Å¼ne rodzaje encji, zwiÄ…zkÃ³w i atrybutÃ³w.\nPrzykÅ‚ad A â€“ System rezerwacji hotelu\n\nEncje: â€PokÃ³jâ€, â€GoÅ›Ä‡â€, â€Rezerwacjaâ€.\nZwiÄ…zki: GoÅ›Ä‡ â€rezerwujeâ€ PokÃ³j.\nAtrybuty: Rezerwacja ma datÄ™ poczÄ…tku, datÄ™ koÅ„ca i status.\n\nPrzykÅ‚ad B â€“ Uczelnia\n\nEncje: â€Studentâ€, â€Kursâ€, â€WykÅ‚adowcaâ€.\nZwiÄ…zki: Student â€zapisuje siÄ™ naâ€ Kurs, WykÅ‚adowca â€prowadziâ€ Kurs.\nAtrybuty: Student â€“ imiÄ™, nazwisko, nr indeksu. Kurs â€“ nazwa, punktacja ECTS.\n\nPrzykÅ‚ad C â€“ Sklep internetowy\n\nEncje: â€Klientâ€, â€Produktâ€, â€ZamÃ³wienieâ€.\nZwiÄ…zki: Klient â€skÅ‚adaâ€ ZamÃ³wienie, ZamÃ³wienie â€zawieraâ€ Produkt.\nAtrybuty: Produkt â€“ cena, opis; ZamÃ³wienie â€“ data, status.\n\nâ¸»",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#podsumowanie",
    "href": "lectures/wyklad2.html#podsumowanie",
    "title": "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)",
    "section": "Podsumowanie",
    "text": "Podsumowanie\n\nProjektowanie bazy danych zaczynamy od analizy wymagaÅ„ uÅ¼ytkownika.\nModel ER pozwala uporzÄ…dkowaÄ‡ wiedzÄ™ w postaci encjeâ€“atrybutyâ€“zwiÄ…zki.\nWyrÃ³Å¼niamy zwiÄ…zki 1:1, 1:N, N:M oraz atrybuty proste, zÅ‚oÅ¼one i wielowartoÅ›ciowe.\nDiagram ERD to narzÄ™dzie komunikacji â€“ Å‚Ä…czy Å›wiat uÅ¼ytkownika ze Å›wiatem projektanta i programisty.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Projektowanie koncepcyjne â€“ model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogÃ³lne",
    "section": "",
    "text": "Kod:\nSemestr: zimowy",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Informacje ogÃ³lne"
    ]
  },
  {
    "objectID": "index.html#projektowanie-relacyjnych-baz-danych",
    "href": "index.html#projektowanie-relacyjnych-baz-danych",
    "title": "Informacje ogÃ³lne",
    "section": "",
    "text": "Kod:\nSemestr: zimowy",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Informacje ogÃ³lne"
    ]
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogÃ³lne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykÅ‚ad WEL21EA1S0:\n\n\n02.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n06.10.2025 PoniedziaÅ‚ek 8.00 - 9.30. b 61 s 104\n\n\n09.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n16.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n21.10.2025 Wtorek 8.00 - 9.35 b 61 s 116\n\n\n27.10.2025 PoniedziaÅ‚ek 9.50 - 11.25 b 61 s 104\n\n\n30.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n\n\nLaboratorium:\n\n20.11.2025 Czwartek (5-6-7-8) 4h b 61 s 104\n27.11.2025 Czwartek (5-6-7-8) 4h b 61 s 104\n08.12.2025 PoniedziaÅ‚ek (5-6-7-8) 4h b 61 s 104\n22.01.2026 Czwartek (1-2-3-4) 4 h b 61 s 104",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Informacje ogÃ³lne"
    ]
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "KsiÄ…Å¼ki i strony WWW",
    "section": "",
    "text": "Ben Forta - SQL w mnieniu oka. Helion. 2020.\nThomas Nield - Pierwsze kroki z SQL. Praktyczne podejÅ›cie dla poczÄ…tkujÄ…cych. Oâ€™Reilly: 2016"
  },
  {
    "objectID": "ksiazki.html#ksiÄ…Å¼ki",
    "href": "ksiazki.html#ksiÄ…Å¼ki",
    "title": "KsiÄ…Å¼ki i strony WWW",
    "section": "",
    "text": "Ben Forta - SQL w mnieniu oka. Helion. 2020.\nThomas Nield - Pierwsze kroki z SQL. Praktyczne podejÅ›cie dla poczÄ…tkujÄ…cych. Oâ€™Reilly: 2016"
  },
  {
    "objectID": "cwiczenia/cw1.html",
    "href": "cwiczenia/cw1.html",
    "title": "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "",
    "text": "Zanim zaczniemy korzystaÄ‡ z profesjonalnych systemÃ³w zarzÄ…dzania bazami danych (DBMS), warto zrozumieÄ‡, dlaczego sÄ… one potrzebne. Na poczÄ…tku dane czÄ™sto przechowuje siÄ™ w plikach tekstowych, np. CSV (Comma Separated Values). Pliki te moÅ¼na Å‚atwo tworzyÄ‡ i edytowaÄ‡, np. w Excelu, LibreOffice czy nawet w Notatniku.\nJednak takie â€proste bazy plikoweâ€ majÄ… swoje ograniczenia:\nRelacyjne systemy baz danych, takie jak PostgreSQL czy SQLite, rozwiÄ…zujÄ… te problemy. Dane sÄ… tam przechowywane w tabelach o jasno okreÅ›lonej strukturze (kolumny, typy danych), a system dba o integralnoÅ›Ä‡ i spÃ³jnoÅ›Ä‡ informacji. Zanim jednak przejdziemy do PostgreSQL, przyjrzyjmy siÄ™, jak wyglÄ…da â€prosta baza plikowaâ€ i jak moÅ¼na jÄ… przeksztaÅ‚ciÄ‡ w prawdziwÄ… bazÄ™ danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Ä†wiczenia",
      "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "cwiczenia/cw1.html#sqlite",
    "href": "cwiczenia/cw1.html#sqlite",
    "title": "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "SQLite",
    "text": "SQLite\nJak wspomniano na wykÅ‚adzie, dane moÅ¼na gromadziÄ‡ w rÃ³Å¼nego rodzaju bazach danych. CzÄ™sto jednak potrzebne jest nam szybkie i Å‚atwe rozwiÄ…zanie, bez koniecznoÅ›ci mozolnego budowania architektury klient-serwer. Chcemy bowiem przechowywaÄ‡ dane w prostym pliku i edytowaÄ‡ je rÃ³wnie Å‚atwo jak w przypadku dokumentu tekstowego, takiego jak w programie Word. W takich przypadkach najbardziej optymalne jest uÅ¼ycie wÅ‚aÅ›nie SQLite. SQLite jest najczÄ™Å›ciej wykorzystywanym na Å›wiecie systemem zarzÄ…dzania bazÄ… danych. ZostaÅ‚ zastosowany w iPhonach, iPadach, w urzÄ…dzeniach z systemem operacyjnym Android i Windows Mobile. Znajdziesz go rÃ³wnieÅ¼ w termostatach, a takÅ¼e w samochodowych systemach komputerowych. Jest teÅ¼ wykorzystywany w satelitach i w wielu innych nowoczesnych urzÄ…dzeniach, w przypadku ktÃ³rych konieczne jest przechowywanie danych i proste ich przeszukiwanie. Z SQLite korzysta w duÅ¼ym stopniu zarÃ³wno system operacyjny Windows, jak i system samolotu Airbus A350 XWB. Jest on wiÄ™c stosowany wszÄ™dzie tam, gdzie istotna jest Å‚atwoÅ›Ä‡ korzystania z niego oraz niskie koszty staÅ‚e. Jest rÃ³wnieÅ¼ doskonaÅ‚y do przygotowywania prototypÃ³w baz danych dla przedsiÄ™biorstw. Jednak coÅ› za coÅ› â€” z uwagi na brak serwera zarzÄ…dzajÄ…cego dostÄ™pem do bazy danych SQLite nie moÅ¼e byÄ‡ jednoczeÅ›nie wykorzystywany przez wielu uÅ¼ytkownikÃ³w. Nie jest bowiem moÅ¼liwe edytowanie tego samego pliku przez wiele osÃ³b w tym samym czasie. Ten system zarzÄ…dzania bazÄ… danych nadaje siÄ™ natomiast Å›wietnie do celÃ³w szkoleniowych.\nsqlite studio\n\nimport sqlite3\nimport csv\n\n# PoÅ‚Ä…czenie z bazÄ… (plik .db zostanie utworzony, jeÅ›li nie istnieje)\nconn = sqlite3.connect(\"klienci.db\")\ncur = conn.cursor()\n\n# Utworzenie tabeli\ncur.execute(\"\"\"\nCREATE TABLE IF NOT EXISTS klienci (\n    dane_osobowe TEXT,\n    adres TEXT,\n    produkty INTEGER\n);\n\"\"\")\n\n# Wczytanie danych z pliku CSV\nwith open(\"klienci_produkty_v2.csv\", newline='', encoding='utf-8') as csvfile:\n    reader = csv.DictReader(csvfile)\n    for row in reader:\n        cur.execute(\"\"\"\n            INSERT INTO klienci (dane_osobowe, adres, produkty)\n            VALUES (?, ?, ?)\n        \"\"\", (row['dane_osobowe'], row['adres'], row['produkty']))\n\n# Zapisanie zmian i zamkniÄ™cie poÅ‚Ä…czenia\nconn.commit()\nconn.close()\n\nprint(\"Dane zostaÅ‚y zaimportowane do bazy danych klienci.db\")\n\nDane zostaÅ‚y zaimportowane do bazy danych klienci.db\n\n\n\nimport sqlite3\nimport pandas as pd\n\n\ndb_file = \"klienci.db\"\n\n# PoÅ‚Ä…czenie z bazÄ… SQLite (plik zostanie utworzony jeÅ›li nie istnieje)\nconn = sqlite3.connect(db_file)\ncur = conn.cursor()\n\n# Pobranie 10 pierwszych rekordÃ³w do DataFrame\ndf = pd.read_sql_query(\"SELECT * FROM klienci LIMIT 10;\", conn)\n\n# WyÅ›wietlenie DataFrame\ndf\n\n\n\n\n\n\n\n\nid\ndane_osobowe\nadres\nprodukty\n\n\n\n\n0\n1\nKatarzyna WiÅ›niewski\nul. Lipowa 1,\nSÅ‚uchawki, Router, Drukarka, Telefon\n\n\n1\n2\nAnna Grabowska\nul. Mickiewicza ,\nTelefon, Laptop, Kamera internetowa, SÅ‚uchawki\n\n\n2\n3\nMarek CzerwiÅ„ska\nul. SÅ‚oneczna ,\nRouter\n\n\n3\n4\nPiotr KrÃ³l\nul. Szkolna 27,\nMonitor, Tablet, Klawiatura\n\n\n4\n5\nMarek Kowalski\nul. Polna ,\nMonitor\n\n\n5\n6\nMichaÅ‚ WÃ³jcik\nul. Spacerowa 30,\nMysz, Monitor\n\n\n6\n7\nAnna Baran\nul. Lipowa , 30-400\nMysz\n\n\n7\n8\nAdam Kowalski\nul. Mickiewicza , 60-100\nMonitor, Drukarka\n\n\n8\n9\nMarek CzerwiÅ„ska\nul. Lipowa , 35-100 PoznaÅ„\nLaptop, SÅ‚uchawki, Router\n\n\n9\n10\nPaweÅ‚ Pawlak\nul. Spacerowa ,\nMysz, Kamera internetowa, Laptop\n\n\n\n\n\n\n\n\n# ZamkniÄ™cie poÅ‚Ä…czenia\nconn.close()\n\n\n\nNowa baza â€œwyklikanaâ€\nNowa baza z pliku\nProsty kod sql\nZaÅ‚adowanie tabel i danych z kodu pliku sql",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Ä†wiczenia",
      "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "cwiczenia/cw1.html#ddl-w-sqlite",
    "href": "cwiczenia/cw1.html#ddl-w-sqlite",
    "title": "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "DDL w SQLite",
    "text": "DDL w SQLite\n\n1. Tworzenie tabeli klienci\n\nTworzymy tabelÄ™, jeÅ›li jeszcze nie istnieje\n\n\nCREATE TABLE IF NOT EXISTS klienci (\n    dane_osobowe TEXT,    -- pole z imieniem i nazwiskiem\n    adres TEXT,           -- pole z peÅ‚nym adresem\n    produkty TEXT         -- pole z produktami, w wersji nienormalizowanej (lista w jednej komÃ³rce)\n);\n\nINSERT przykÅ‚adowego rekordu do demonstracji dziaÅ‚ania\n\nINSERT INTO klienci (dane_osobowe, adres, produkty)\nVALUES ('Jan Kowalski', 'ul. Lipowa 12, 00-001 Warszawa', 'Laptop, Telefon');\n\nSprawdzenie zawartoÅ›ci tabeli SELECT * FROM klienci;\n\n\n\n2. Dodanie kolumny z kluczem gÅ‚Ã³wnym\nâ€“ Dodajemy kolumnÄ™ â€œidâ€ jako PRIMARY KEY\nALTER TABLE klienci ADD COLUMN id INTEGER PRIMARY KEY AUTOINCREMENT;\n\nPokazujemy efekt dodania kolumny\n\nPRAGMA table_info(klienci);\n\n\n3. Dodanie dodatkowej kolumny\n\nDodajemy kolumnÄ™ â€œtypâ€ (np. kategoria klienta: standard/premium)\n\nALTER TABLE klienci ADD COLUMN typ TEXT;\n\nWstawiamy przykÅ‚adowe wartoÅ›ci dla nowych rekordÃ³w\n\nUPDATE klienci SET typ = 'standard' WHERE id = 1;\n\nSprawdzamy aktualnÄ… tabelÄ™\n\nSELECT * FROM klienci;\n\n\n4. Tworzenie indeksu\nCREATE INDEX idx_klienci_nazwisko ON klienci(dane_osobowe);\n\n\n5. Usuwanie kolumny (ograniczenia SQLite)\n\nUwaga! - SQLite nie pozwala bezpoÅ›rednio usunÄ…Ä‡ kolumny\n\n-- 1. Tworzymy nowÄ… tabelÄ™ bez kolumny \"typ\"\nCREATE TABLE klienci_nowa AS\nSELECT id, dane_osobowe, adres, produkty\nFROM klienci;\n\n-- 2. Usuwamy starÄ… tabelÄ™\nDROP TABLE klienci;\n\n-- 3. Zmieniamy nazwÄ™ nowej tabeli na starÄ…\nALTER TABLE klienci_nowa RENAME TO klienci;\n\n-- Sprawdzamy strukturÄ™ tabeli po usuniÄ™ciu kolumny\nPRAGMA table_info(klienci);\n\n\n6. Zmiana nazwy tabeli\nALTER TABLE klienci RENAME TO klienci_stara;\n\n\n7. UsuniÄ™cie tabeli\nDROP TABLE IF EXISTS klienci;\nProblemy nienormalizowanej tabeli:\n\nKolumna produkty zawiera wiele wartoÅ›ci (1â€“4 produkty w jednej komÃ³rce).\nKolumna adres moÅ¼e byÄ‡ duplikowana, jeÅ›li wielu klientÃ³w mieszka pod tym samym adresem.\nTrudno wykonywaÄ‡ analizy typu â€ktÃ³rzy klienci kupili ten sam produktâ€.\nRyzyko powielania danych i bÅ‚Ä™dÃ³w aktualizacji.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Ä†wiczenia",
      "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "cwiczenia/cw1.html#pierwsza-postaÄ‡-normalna-1nf-analiza-tabeli-klienci",
    "href": "cwiczenia/cw1.html#pierwsza-postaÄ‡-normalna-1nf-analiza-tabeli-klienci",
    "title": "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "Pierwsza PostaÄ‡ Normalna (1NF) â€“ analiza tabeli klienci",
    "text": "Pierwsza PostaÄ‡ Normalna (1NF) â€“ analiza tabeli klienci\nProblemy tabeli:\n\nKolumna produkty zawiera wiele wartoÅ›ci â†’ brak atomowoÅ›ci.\nBrak klucza gÅ‚Ã³wnego.\nTrudno wyszukiwaÄ‡ klientÃ³w po produktach lub adresach.\nImiÄ™ i nazwisko, adres sÄ… w jednej kolumnie.\n\n\nKrok 0: Dodanie klucza gÅ‚Ã³wnego\nALTER TABLE klienci ADD COLUMN id INTEGER PRIMARY KEY AUTOINCREMENT;\n\nKaÅ¼dy rekord ma teraz unikalny identyfikator id.\nMoÅ¼na bezpiecznie rozdzielaÄ‡ produkty w kolejnych krokach.\n\n\n\nKrok 1 â€“ Pierwsza PostaÄ‡ Normalna (1NF)\nCel: rozdzielamy wielowartoÅ›ciowe kolumny (produkty) na osobne wiersze.\nTabela 1NF â€“ przykÅ‚adowe rekordy:\nCREATE TABLE klienci_1nf (\n    klient_id INTEGER,\n    dane_osobowe TEXT,\n    adres TEXT,\n    produkt TEXT\n);\n\n-- Wstawienie przykÅ‚adowych danych\nINSERT INTO klienci_1nf (klient_id, dane_osobowe, adres, produkt) VALUES\n(1, 'Jan Kowalski', 'ul. Lipowa 12, 00-001 Warszawa', 'Laptop'),\n(1, 'Jan Kowalski', 'ul. Lipowa 12, 00-001 Warszawa', 'Telefon'),\n(2, 'Anna Nowak', 'ul. DÅ‚uga 7, KrakÃ³w', 'Monitor'),\n(3, 'Piotr WiÅ›niewski', 'ul. Parkowa 3, ÅÃ³dÅº', 'Tablet'),\n(3, 'Piotr WiÅ›niewski', 'ul. Parkowa 3, ÅÃ³dÅº', 'Mysz'),\n(3, 'Piotr WiÅ›niewski', 'ul. Parkowa 3, ÅÃ³dÅº', 'Klawiatura');\nEfekt dydaktyczny:\n\nKaÅ¼dy wiersz zawiera jednÄ… wartoÅ›Ä‡ produktu.\nMoÅ¼emy wyszukiwaÄ‡ klientÃ³w po produkcie:\n\nSELECT dane_osobowe, adres FROM klienci_1nf WHERE produkt='Laptop';\n\n\nKrok 2 â€“ Druga PostaÄ‡ Normalna (2NF)\nCel: usuwamy redundancjÄ™ zaleÅ¼noÅ›ci czÄ™Å›ciowych\nâ€“ dane, ktÃ³re zaleÅ¼Ä… tylko od klienta (adres, imiÄ™/nazwisko), przenosimy do osobnej tabeli klienci.\nCREATE TABLE klienci_2nf (\n    klient_id INTEGER PRIMARY KEY,\n    dane_osobowe TEXT,\n    adres TEXT\n);\n\nCREATE TABLE zakupy (\n    klient_id INTEGER,\n    produkt TEXT,\n    FOREIGN KEY (klient_id) REFERENCES klienci_2nf(klient_id)\n);\n\n-- Wstawienie przykÅ‚adowych danych\nINSERT INTO klienci_2nf (klient_id, dane_osobowe, adres) VALUES\n(1, 'Jan Kowalski', 'ul. Lipowa 12, 00-001 Warszawa'),\n(2, 'Anna Nowak', 'ul. DÅ‚uga 7, KrakÃ³w'),\n(3, 'Piotr WiÅ›niewski', 'ul. Parkowa 3, ÅÃ³dÅº');\n\nINSERT INTO zakupy (klient_id, produkt) VALUES\n(1, 'Laptop'),\n(1, 'Telefon'),\n(2, 'Monitor'),\n(3, 'Tablet'),\n(3, 'Mysz'),\n(3, 'Klawiatura');\nEfekt:\n\nKlient pojawia siÄ™ tylko raz w tabeli klienci.\nTabela zakupy przechowuje produkty, a klient_id Å‚Ä…czy je z klientem.\nRedukcja redundancji i Å‚atwiejsze zarzÄ…dzanie danymi.\n\n\n\nKrok 3 â€“ Trzecia PostaÄ‡ Normalna (3NF)\nCel: peÅ‚na atomizacja danych â€“ dzielimy adres na ulicÄ™, numer, kod, miasto.\n\nimport sqlite3\nimport pandas as pd\n\n# Wczytanie CSV\ndf = pd.read_csv('klienci_produkty_v2.csv')  # kolumny: dane_osobowe, adres, produkty\n\n# Utworzenie poÅ‚Ä…czenia z bazÄ… SQLite\nconn = sqlite3.connect('klienci_normalizacja.db')\ncur = conn.cursor()\n\n# ===================================================\n# 1. Tworzymy tabele w 3NF\n# ===================================================\ncur.execute('''\nCREATE TABLE IF NOT EXISTS adresy (\n    adres_id INTEGER PRIMARY KEY AUTOINCREMENT,\n    ulica TEXT,\n    numer TEXT,\n    kod TEXT,\n    miasto TEXT\n)\n''')\n\ncur.execute('''\nCREATE TABLE IF NOT EXISTS klienci (\n    klient_id INTEGER PRIMARY KEY AUTOINCREMENT,\n    dane_osobowe TEXT,\n    adres_id INTEGER,\n    FOREIGN KEY (adres_id) REFERENCES adresy(adres_id)\n)\n''')\n\ncur.execute('''\nCREATE TABLE IF NOT EXISTS zakupy (\n    klient_id INTEGER,\n    produkt TEXT,\n    FOREIGN KEY (klient_id) REFERENCES klienci(klient_id)\n)\n''')\n\nconn.commit()\n\n# ===================================================\n# 2. WypeÅ‚nienie tabel\n# ===================================================\n\n# Pomocnicza funkcja do rozdzielania adresu\ndef rozdziel_adres(adres):\n    try:\n        # zakÅ‚adamy format: \"ul. Lipowa 12, 00-001 Warszawa\"\n        czesci = adres.split(',')\n        ulica_numer = czesci[0].strip().rsplit(' ', 1)\n        ulica = ulica_numer[0]\n        numer = ulica_numer[1] if len(ulica_numer) &gt; 1 else ''\n        kod_miasto = czesci[1].strip().split(' ', 1) if len(czesci) &gt; 1 else ['', '']\n        kod = kod_miasto[0]\n        miasto = kod_miasto[1] if len(kod_miasto) &gt; 1 else ''\n        return ulica, numer, kod, miasto\n    except:\n        return '', '', '', ''\n\n# Dodanie adresÃ³w i przypisanie adres_id\nadres_map = {}  # mapowanie peÅ‚nego adresu na adres_id\nfor index, row in df.iterrows():\n    adres = row['adres']\n    if adres not in adres_map:\n        ulica, numer, kod, miasto = rozdziel_adres(adres)\n        cur.execute('''\n            INSERT INTO adresy (ulica, numer, kod, miasto)\n            VALUES (?, ?, ?, ?)\n        ''', (ulica, numer, kod, miasto))\n        adres_id = cur.lastrowid\n        adres_map[adres] = adres_id\n\n    # Dodanie klienta\n    cur.execute('''\n        INSERT INTO klienci (dane_osobowe, adres_id)\n        VALUES (?, ?)\n    ''', (row['dane_osobowe'], adres_map[adres]))\n    klient_id = cur.lastrowid\n\n    # Rozdzielenie produktÃ³w i dodanie do zakupy\n    produkty = [p.strip() for p in str(row['produkty']).split(',')]\n    for produkt in produkty:\n        if produkt:  # pomijamy puste\n            cur.execute('''\n                INSERT INTO zakupy (klient_id, produkt)\n                VALUES (?, ?)\n            ''', (klient_id, produkt))\n\nconn.commit()\nconn.close()\n\nprint(\"Import i normalizacja zakoÅ„czone!\")\n\nImport i normalizacja zakoÅ„czone!\n\n\nOpis dziaÅ‚ania:\n\nAdresy sÄ… rozdzielane na ulica, numer, kod, miasto â†’ tabela adresy.\nKlienci trafiajÄ… do tabeli klienci z adres_id.\nProdukty sÄ… rozdzielane i dodawane do tabeli zakupy.\nKaÅ¼dy klient ma unikalny klient_id, wiÄ™c jeÅ›li kupiÅ‚ kilka produktÃ³w, w zakupy bÄ™dzie kilka wierszy.\n\n\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('klienci_normalizacja.db')\n\n# WyÅ›wietlenie 10 pierwszych klientÃ³w\ndf_klienci = pd.read_sql('SELECT * FROM klienci LIMIT 10', conn)\ndf_klienci.head(10)\n\n\n\n\n\n\n\n\nklient_id\ndane_osobowe\nadres_id\n\n\n\n\n0\n1\nKatarzyna WiÅ›niewski\n1\n\n\n1\n2\nAnna Grabowska\n2\n\n\n2\n3\nMarek CzerwiÅ„ska\n3\n\n\n3\n4\nPiotr KrÃ³l\n4\n\n\n4\n5\nMarek Kowalski\n5\n\n\n5\n6\nMichaÅ‚ WÃ³jcik\n6\n\n\n6\n7\nAnna Baran\n7\n\n\n7\n8\nAdam Kowalski\n8\n\n\n8\n9\nMarek CzerwiÅ„ska\n9\n\n\n9\n10\nPaweÅ‚ Pawlak\n10\n\n\n\n\n\n\n\n\n# WyÅ›wietlenie 10 pierwszych zakupÃ³w\ndf_zakupy = pd.read_sql('SELECT * FROM zakupy LIMIT 10', conn)\ndf_zakupy\n\n\n\n\n\n\n\n\nklient_id\nprodukt\n\n\n\n\n0\n1\nSÅ‚uchawki\n\n\n1\n1\nRouter\n\n\n2\n1\nDrukarka\n\n\n3\n1\nTelefon\n\n\n4\n2\nTelefon\n\n\n5\n2\nLaptop\n\n\n6\n2\nKamera internetowa\n\n\n7\n2\nSÅ‚uchawki\n\n\n8\n3\nRouter\n\n\n9\n4\nMonitor\n\n\n\n\n\n\n\n\nconn.close()\n\nNormalizacja tabeli klienci â€“ peÅ‚ne podsumowanie\nTabela poczÄ…tkowa (przed normalizacjÄ…)\n\nNazwa tabeli: klienci\nLiczba kolumn: 3 (dane_osobowe, adres, produkty)\nTypy danych: wszystkie TEXT (nienormalizowane)\nProblemy:\nBrak klucza gÅ‚Ã³wnego â†’ brak jednoznacznej identyfikacji rekordu.\nWielowartoÅ›ciowa kolumna produkty â†’ zÅ‚amanie zasad atomowoÅ›ci.\nImiÄ™/nazwisko i adres w jednej kolumnie â†’ brak peÅ‚nej atomowoÅ›ci.\nTrudnoÅ›ci w analizie i wyszukiwaniu.\n\nâ¸»\nProces normalizacji krok po kroku\nKrok 0 â€“ Dodanie klucza gÅ‚Ã³wnego\n\nKolumna id jako PRIMARY KEY.\nKaÅ¼dy rekord jednoznacznie identyfikowany.\n\nKrok 1 â€“ 1NF\n\nRozdzielenie wielowartoÅ›ciowej kolumny produkty na osobne wiersze.\nJeden wiersz = jeden klient + jeden produkt.\nCel: kaÅ¼da kolumna jest atomowa.\n\nKrok 2 â€“ 2NF\n\nRozdzielenie danych, ktÃ³re zaleÅ¼Ä… tylko od klienta (adres, imiÄ™/nazwisko), do osobnej tabeli klienci.\nProdukty przeniesione do tabeli zakupy.\nRelacja: klient_id w zakupy â†’ klient_id w klienci (1:N).\n\nKrok 3 â€“ 3NF\n\nRozdzielenie adresu na atomowe kolumny: ulica, numer, kod, miasto â†’ tabela adresy.\nW tabeli klienci pozostaje tylko adres_id jako klucz obcy.\nRelacje:\nklienci.adres_id â†’ adresy.adres_id (1:1)\nzakupy.klient_id â†’ klienci.klient_id (1:N)\n\n\nimport pandas as pd\n\n# Wczytanie CSV\ndf = pd.read_csv('klienci_produkty_v2.csv')  # kolumny: dane_osobowe, adres, produkty\n\n# Plik wynikowy SQL\nsql_file = open('klienci_3nf.sql', 'w', encoding='utf-8')\n\n# ===================================================\n# 1. Tworzenie tabel\n# ===================================================\nsql_file.write(\"\"\"\n-- Tabele w 3NF\nCREATE TABLE IF NOT EXISTS adresy (\n    adres_id INTEGER PRIMARY KEY AUTOINCREMENT,\n    ulica TEXT,\n    numer TEXT,\n    kod TEXT,\n    miasto TEXT\n);\n\nCREATE TABLE IF NOT EXISTS klienci (\n    klient_id INTEGER PRIMARY KEY AUTOINCREMENT,\n    dane_osobowe TEXT,\n    adres_id INTEGER,\n    FOREIGN KEY (adres_id) REFERENCES adresy(adres_id)\n);\n\nCREATE TABLE IF NOT EXISTS zakupy (\n    klient_id INTEGER,\n    produkt TEXT,\n    FOREIGN KEY (klient_id) REFERENCES klienci(klient_id)\n);\n\n\"\"\")\n\n# ===================================================\n# 2. Generowanie INSERT dla wszystkich danych\n# ===================================================\nadres_map = {}  # mapowanie peÅ‚nego adresu na adres_id\nadres_id_counter = 1\nklient_id_counter = 1\n\ndef rozdziel_adres(adres):\n    try:\n        czesci = adres.split(',')\n        ulica_numer = czesci[0].strip().rsplit(' ', 1)\n        ulica = ulica_numer[0]\n        numer = ulica_numer[1] if len(ulica_numer) &gt; 1 else ''\n        kod_miasto = czesci[1].strip().split(' ', 1) if len(czesci) &gt; 1 else ['', '']\n        kod = kod_miasto[0]\n        miasto = kod_miasto[1] if len(kod_miasto) &gt; 1 else ''\n        return ulica, numer, kod, miasto\n    except:\n        return '', '', '', ''\n\nfor index, row in df.iterrows():\n    adres = row['adres']\n    if adres not in adres_map:\n        ulica, numer, kod, miasto = rozdziel_adres(adres)\n        sql_file.write(f\"INSERT INTO adresy (adres_id, ulica, numer, kod, miasto) VALUES ({adres_id_counter}, '{ulica.replace('\\'','\\'\\'')}', '{numer}', '{kod}', '{miasto}');\\n\")\n        adres_map[adres] = adres_id_counter\n        adres_id_counter += 1\n\n    # Dodanie klienta\n    sql_file.write(f\"INSERT INTO klienci (klient_id, dane_osobowe, adres_id) VALUES ({klient_id_counter}, '{row['dane_osobowe'].replace('\\'','\\'\\'')}', {adres_map[adres]});\\n\")\n\n    # Rozdzielenie produktÃ³w\n    produkty = [p.strip() for p in str(row['produkty']).split(',')]\n    for produkt in produkty:\n        if produkt:\n            sql_file.write(f\"INSERT INTO zakupy (klient_id, produkt) VALUES ({klient_id_counter}, '{produkt.replace('\\'','\\'\\'')}');\\n\")\n\n    klient_id_counter += 1\n\nsql_file.close()\nprint(\"Plik SQL 'klienci_3nf.sql' zostaÅ‚ wygenerowany!\")\n\nPlik SQL 'klienci_3nf.sql' zostaÅ‚ wygenerowany!",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Ä†wiczenia",
      "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "cwiczenia/cw1.html#serwer-baz-danych",
    "href": "cwiczenia/cw1.html#serwer-baz-danych",
    "title": "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "Serwer baz danych",
    "text": "Serwer baz danych\nPostgreSQL to relacyjny system zarzÄ…dzania bazÄ… danych (RDBMS â€“ Relational Database Management System), naleÅ¼Ä…cy do najbardziej zaawansowanych i niezawodnych rozwiÄ…zaÅ„ typu open source. UmoÅ¼liwia on tworzenie, przechowywanie i przetwarzanie danych w sposÃ³b zgodny z zasadami modelu relacyjnego, zapewniajÄ…c jednoczeÅ›nie obsÅ‚ugÄ™ transakcji, integralnoÅ›Ä‡ danych, bezpieczeÅ„stwo oraz wysokÄ… wydajnoÅ›Ä‡.\nDo pracy z PostgreSQL czÄ™sto wykorzystuje siÄ™ narzÄ™dzie pgAdmin â€“ graficzny interfejs uÅ¼ytkownika (GUI), ktÃ³ry pozwala w wygodny sposÃ³b zarzÄ…dzaÄ‡ serwerem i bazami danych, wykonywaÄ‡ zapytania SQL, projektowaÄ‡ struktury tabel oraz analizowaÄ‡ dane. DziÄ™ki pgAdmin uÅ¼ytkownik moÅ¼e Å‚Ä…czyÄ‡ siÄ™ z serwerem PostgreSQL, przeglÄ…daÄ‡ obiekty bazy (schematy, tabele, widoki, funkcje), a takÅ¼e monitorowaÄ‡ jej dziaÅ‚anie.\nPostgreSQL dziaÅ‚a w architekturze klientâ€“serwer. Oznacza to, Å¼e serwer baz danych (program postgres) dziaÅ‚a w tle i odpowiada za przechowywanie oraz zarzÄ…dzanie danymi, natomiast klienci (np. pgAdmin, aplikacje webowe, skrypty w Pythonie) Å‚Ä…czÄ… siÄ™ z nim za pomocÄ… sieciowego protokoÅ‚u i wysyÅ‚ajÄ… polecenia SQL. Serwer przetwarza te polecenia, wykonuje operacje na danych i zwraca wyniki do klienta. Takie rozwiÄ…zanie pozwala wielu uÅ¼ytkownikom lub aplikacjom jednoczeÅ›nie korzystaÄ‡ z tej samej bazy danych w sposÃ³b bezpieczny i kontrolowany.\nW trakcie laboratorium bÄ™dziemy korzystaÄ‡ z PostgreSQL i pgAdmin, aby poznaÄ‡ zasady dziaÅ‚ania relacyjnych systemÃ³w baz danych â€“ od projektowania schematÃ³w danych, poprzez tworzenie tabel i relacji, aÅ¼ po wykonywanie zapytaÅ„ SQL i analizÄ™ wynikÃ³w.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Ä†wiczenia",
      "ğŸ“˜ Wprowadzenie: od prostych plikÃ³w do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "",
    "text": "Celem dzisiejszego wykÅ‚adu jest pokazanie, jak przejÅ›Ä‡ od koncepcyjnego modelu ERD (Entityâ€“Relationship Diagram), ktÃ³ry opisuje co chcemy przechowywaÄ‡, do modelu relacyjnego, ktÃ³ry mÃ³wi jak te dane bÄ™dÄ… fizycznie zorganizowane w tabelach.\nğŸ‘‰ Innymi sÅ‚owy â€” dziÅ› â€przekÅ‚adamyâ€ logikÄ™ Å›wiata rzeczywistego na jÄ™zyk tabel, kolumn i kluczy.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#cel-wykÅ‚adu",
    "href": "lectures/wyklad3.html#cel-wykÅ‚adu",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "",
    "text": "Celem dzisiejszego wykÅ‚adu jest pokazanie, jak przejÅ›Ä‡ od koncepcyjnego modelu ERD (Entityâ€“Relationship Diagram), ktÃ³ry opisuje co chcemy przechowywaÄ‡, do modelu relacyjnego, ktÃ³ry mÃ³wi jak te dane bÄ™dÄ… fizycznie zorganizowane w tabelach.\nğŸ‘‰ Innymi sÅ‚owy â€” dziÅ› â€przekÅ‚adamyâ€ logikÄ™ Å›wiata rzeczywistego na jÄ™zyk tabel, kolumn i kluczy.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#wprowadzenie",
    "href": "lectures/wyklad3.html#wprowadzenie",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "1. Wprowadzenie",
    "text": "1. Wprowadzenie\nZacznijmy od prostego pytania do grupy:\nâ€Czy narysowany diagram ERD to juÅ¼ baza danych?â€\nWiÄ™kszoÅ›Ä‡ studentÃ³w odpowie, Å¼e nie â€” i majÄ… racjÄ™. ERD to tylko opis pojÄ™Ä‡ i powiÄ…zaÅ„ miÄ™dzy nimi, coÅ› w rodzaju mapy koncepcyjnej. Dopiero model relacyjny pozwala tÄ™ mapÄ™ zaimplementowaÄ‡ w systemie DBMS â€“ czyli stworzyÄ‡ konkretne tabele, relacje i klucze.\n\nPrzykÅ‚ad porÃ³wnawczy:\nERD to jak plan architektoniczny domu.\nModel relacyjny to juÅ¼ projekt budowlany z wymiarami i materiaÅ‚ami.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#przypomnienie-podstawowych-pojÄ™Ä‡",
    "href": "lectures/wyklad3.html#przypomnienie-podstawowych-pojÄ™Ä‡",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Przypomnienie podstawowych pojÄ™Ä‡",
    "text": "Przypomnienie podstawowych pojÄ™Ä‡\nZanim przejdziemy do reguÅ‚, powtÃ³rzmy szybko:\n\nEncja â€“ obiekt, o ktÃ³rym przechowujemy dane (np. Student, Kurs, Produkt).\nAtrybut â€“ wÅ‚aÅ›ciwoÅ›Ä‡ tego obiektu (np. imiÄ™, nazwisko, cena).\nZwiÄ…zek (relationship) â€“ powiÄ…zanie miÄ™dzy encjami (np. Student zapisuje siÄ™ na Kurs).\nKrotka (tuple) â€“ pojedynczy wiersz tabeli (np. dane jednego studenta).\nDomena â€“ dopuszczalne wartoÅ›ci dla atrybutu (np. liczby od 1 do 5 dla oceny).\n\nğŸ‘‰ Wszystkie te pojÄ™cia znajdÄ… swoje odpowiedniki w modelu relacyjnym.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#proces-mapowania-transformacji",
    "href": "lectures/wyklad3.html#proces-mapowania-transformacji",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Proces mapowania (transformacji)",
    "text": "Proces mapowania (transformacji)\nTeraz przechodzimy do sedna: jak zamieniÄ‡ ERD w zestaw tabel.\nMoÅ¼na to potraktowaÄ‡ jak przepis: krok po kroku.\n\nğŸ”¹ 1. Encje \\(\\to\\) Tabele\nKaÅ¼da encja z modelu ER staje siÄ™ tabelÄ… w modelu relacyjnym.\nKaÅ¼dy atrybut encji staje siÄ™ kolumnÄ….\nWyobraÅºmy sobie, Å¼e prostokÄ…ty z diagramu ER zamieniamy w tabele SQL.\nWszystkie elipsy (atrybuty) stajÄ… siÄ™ kolumnami.\nPrzykÅ‚ad:\n\nEncja: STUDENT (NrIndeksu, ImiÄ™, Nazwisko, RokStudiow)\n\nRelacja: STUDENT(NrIndeksu, ImiÄ™, Nazwisko, RokStudiow)\n\n\nğŸ”¹ 2. Atrybuty zÅ‚oÅ¼one\nAtrybut zÅ‚oÅ¼ony to taki, ktÃ³ry sam skÅ‚ada siÄ™ z kilku czÄ™Å›ci.\nW modelu relacyjnym nie ma takiej konstrukcji, wiÄ™c trzeba go rozbiÄ‡.\nPrzykÅ‚ad:\nAdres = (Ulica, KodPocztowy, Miasto)\nâ€ZauwaÅ¼my, Å¼e dziÄ™ki temu moÅ¼emy np. wyszukiwaÄ‡ po samym mieÅ›cie, co nie byÅ‚oby moÅ¼liwe, gdyby caÅ‚y adres byÅ‚ jednym polem tekstowym.â€\n\n\nğŸ”¹ 3. Atrybuty wielowartoÅ›ciowe\nAtrybut wielowartoÅ›ciowy to taki, ktÃ³ry moÅ¼e mieÄ‡ wiÄ™cej niÅ¼ jednÄ… wartoÅ›Ä‡ dla jednej encji.\nPrzykÅ‚ad: Student moÅ¼e mieÄ‡ wiele adresÃ³w e-mail.\nW modelu relacyjnym nie moÅ¼emy trzymaÄ‡ wielu wartoÅ›ci w jednej kolumnie, wiÄ™c: â¡ï¸ Tworzymy osobnÄ… tabelÄ™.\nEMAIL(NrIndeksu, Email)\n\nKlucz gÅ‚Ã³wny: (NrIndeksu, Email)\nNrIndeksu to klucz obcy do tabeli STUDENT.\n\nâ€To moment, w ktÃ³rym ERD zaczyna siÄ™ rozrastaÄ‡ â€” z jednej encji robiÄ… siÄ™ dwie tabele.\nAle dziÄ™ki temu baza pozostaje spÃ³jna i czytelna.â€\n\n\nğŸ”¹ 4. ZwiÄ…zki 1:1\nZwiÄ…zek â€jeden do jednegoâ€ oznacza, Å¼e kaÅ¼demu rekordowi z jednej tabeli odpowiada najwyÅ¼ej jeden rekord z drugiej.\nPrzykÅ‚ad:\n\nKaÅ¼da osoba ma dokÅ‚adnie jeden paszport.\n\nOSOBA(PESEL, ImiÄ™, Nazwisko)\nPASZPORT(NrPaszportu, DataWaÅ¼noÅ›ci, PESEL)\nDodajemy PESEL jako klucz obcy w tabeli PASZPORT.\nâ€JeÅ›li obie strony sÄ… naprawdÄ™ w relacji 1:1, moÅ¼na teÅ¼ rozwaÅ¼yÄ‡ poÅ‚Ä…czenie tych tabel â€” ale zwykle zostawia siÄ™ je osobno, gdy przechowujÄ… rÃ³Å¼ne grupy informacji\n\n\nğŸ”¹ 5. ZwiÄ…zki 1:N\nTo najczÄ™stszy przypadek w praktyce.\nPrzykÅ‚ad: Jeden wykÅ‚adowca prowadzi wiele kursÃ³w.\nWYKÅADOWCA(IDWykÅ‚adowcy, ImiÄ™, Nazwisko)\nKURS(IDKursu, Nazwa, IDWykÅ‚adowcy)\nIDWykÅ‚adowcy w tabeli KURS jest kluczem obcym.\nâ€PamiÄ™tajcie: klucz obcy zawsze dodajemy po stronie N, czyli po tej, gdzie moÅ¼e byÄ‡ wiÄ™cej rekordÃ³w.â€\n\n\nğŸ”¹ 6. ZwiÄ…zki N:M\nTo przypadek â€wiele do wieluâ€ â€” np. student moÅ¼e uczestniczyÄ‡ w wielu kursach, a kaÅ¼dy kurs ma wielu studentÃ³w.\nW tym wypadku nie da siÄ™ dodaÄ‡ klucza obcego do jednej z tabel, wiÄ™c tworzymy tabelÄ™ poÅ›redniczÄ…cÄ….\nSTUDENT(NrIndeksu, ImiÄ™, Nazwisko)\nKURS(IDKursu, Nazwa)\nZAPIS(NrIndeksu, IDKursu, DataZapisu)\nâ€Ta trzecia tabela to tak naprawdÄ™ odwzorowanie zwiÄ…zku. DziÄ™ki niej moÅ¼emy np. zapisaÄ‡ dodatkowe informacje o relacji â€” np. datÄ™ zapisania siÄ™ na kurs.â€\n\n\n5. Jak projektowaÄ‡ dobre tabele?\nKiedy masz juÅ¼ relacje, czas je zdefiniowaÄ‡ w SQL.\nTu warto podkreÅ›liÄ‡ kilka zasad:\n\nCzytelne nazwy (jednolite, najlepiej w liczbie pojedynczej).\nTypy danych dopasowane do zawartoÅ›ci.\nOgraniczenia (constraints):\nPRIMARY KEY â€“ jednoznaczna identyfikacja,\nFOREIGN KEY â€“ zapewnia spÃ³jnoÅ›Ä‡,\nNOT NULL, UNIQUE, CHECK â€“ wymuszajÄ… poprawnoÅ›Ä‡ danych.\n\nPrzykÅ‚ad SQL:\nCREATE TABLE STUDENT (\n  NrIndeksu CHAR(6) PRIMARY KEY,\n  Imie VARCHAR(30) NOT NULL,\n  Nazwisko VARCHAR(40) NOT NULL\n);\nâ€To dopiero teraz jest konkretna implementacja â€” coÅ›, co moÅ¼na utworzyÄ‡ w PostgreSQL, MySQL czy Oracle.\nAle zanim napiszemy SQL, zawsze powinniÅ›my mieÄ‡ dobrze przemyÅ›lany model relacyjny.â€\n\n\n6. Ä†wiczenie praktyczne\n\nZadanie: Zaprojektuj schemat relacyjny dla firmy, w ktÃ³rej pracownicy realizujÄ… projekty. KaÅ¼dy projekt ma wielu pracownikÃ³w, a kaÅ¼dy pracownik moÅ¼e uczestniczyÄ‡ w wielu projektach. Dodatkowo pamiÄ™tamy od kiedy pracownik uczestniczy w projekcie.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#podsumowanie",
    "href": "lectures/wyklad3.html#podsumowanie",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Podsumowanie:",
    "text": "Podsumowanie:\nâ€DziÅ› nauczyliÅ›my siÄ™ tÅ‚umaczyÄ‡ jÄ™zyk analitykÃ³w (ERD) na jÄ™zyk baz danych (model relacyjny).â€\n\nEncje â†’ tabele\nAtrybuty â†’ kolumny\nZwiÄ…zki â†’ klucze obce lub tabele poÅ›rednie\nAtrybuty zÅ‚oÅ¼one â†’ rozbijamy\nAtrybuty wielowartoÅ›ciowe â†’ osobne tabele\n\nğŸ‘‰ W kolejnym wykÅ‚adzie przejdziemy do normalizacji, czyli porzÄ…dkowania tabel, by unikaÄ‡ bÅ‚Ä™dÃ³w i redundancji.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html",
    "href": "lectures/wyklad4.html",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKaÅ¼dy wiersz (row) = rekord / krotka\n\nKaÅ¼da kolumna (column) = atrybut\n\nDziedzina (domain) = zbiÃ³r dopuszczalnych wartoÅ›ci w kolumnie\n\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#model-relacyjny-przypomnienie-i-pojÄ™cia-podstawowe",
    "href": "lectures/wyklad4.html#model-relacyjny-przypomnienie-i-pojÄ™cia-podstawowe",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKaÅ¼dy wiersz (row) = rekord / krotka\n\nKaÅ¼da kolumna (column) = atrybut\n\nDziedzina (domain) = zbiÃ³r dopuszczalnych wartoÅ›ci w kolumnie\n\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#klucze-i-wiÄ™zy-integralnoÅ›ci",
    "href": "lectures/wyklad4.html#klucze-i-wiÄ™zy-integralnoÅ›ci",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "2ï¸âƒ£ Klucze i wiÄ™zy integralnoÅ›ci",
    "text": "2ï¸âƒ£ Klucze i wiÄ™zy integralnoÅ›ci\n\nğŸ”¸ Klucz gÅ‚Ã³wny (PRIMARY KEY)\n\nUnikalnie identyfikuje kaÅ¼dy wiersz w tabeli.\nNie moÅ¼e byÄ‡ NULL.\n\n\n\nğŸ”¸ Klucz obcy (FOREIGN KEY)\n\nOdwoÅ‚uje siÄ™ do innej tabeli (relacja miÄ™dzy tabelami).\n\n\n\nğŸ”¸ Inne wiÄ™zy:\n\nUNIQUE â€“ unikalnoÅ›Ä‡ wartoÅ›ci w kolumnie.\nNOT NULL â€“ kolumna nie moÅ¼e mieÄ‡ wartoÅ›ci pustej.\nCHECK â€“ warunek logiczny na wartoÅ›Ä‡ kolumny.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#schemat-bazy-danych-przykÅ‚ad-biblioteka",
    "href": "lectures/wyklad4.html#schemat-bazy-danych-przykÅ‚ad-biblioteka",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "3ï¸âƒ£ Schemat bazy danych â€“ przykÅ‚ad â€Bibliotekaâ€",
    "text": "3ï¸âƒ£ Schemat bazy danych â€“ przykÅ‚ad â€Bibliotekaâ€\n\nTabele:\n\nAutorzy (autor_id, imie, nazwisko)\nKsiazki (ksiazka_id, tytul, rok, autor_id)\n\n\n\nRelacja:\n\nKsiazki.autor_id \\(\\to\\) Autorzy.autor_id (klucz obcy)",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#tworzenie-tabel-ddl-data-definition-language",
    "href": "lectures/wyklad4.html#tworzenie-tabel-ddl-data-definition-language",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "4ï¸âƒ£ Tworzenie tabel (DDL â€“ Data Definition Language)",
    "text": "4ï¸âƒ£ Tworzenie tabel (DDL â€“ Data Definition Language)\nPolecenie CREATE TABLE sÅ‚uÅ¼y do utworzenia nowej tabeli w bazie danych.\nW tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz rÃ³Å¼ne wiÄ™zy integralnoÅ›ci, takie jak PRIMARY KEY, NOT NULL czy FOREIGN KEY.\nKaÅ¼da tabela powinna mieÄ‡ kolumnÄ™, ktÃ³ra jednoznacznie identyfikuje kaÅ¼dy wiersz â€“ to wÅ‚aÅ›nie klucz gÅ‚Ã³wny.\nW przykÅ‚adzie poniÅ¼ej tworzymy dwie tabele: Autorzy i Ksiazki, ktÃ³re bÄ™dÄ… ze sobÄ… powiÄ…zane relacjÄ… klucz gÅ‚Ã³wnyâ€“klucz obcy.\n\nPrzykÅ‚ad w SQLite i PostgreSQL\nCREATE TABLE Autorzy (\n    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT\n    imie         TEXT NOT NULL,\n    nazwisko     TEXT NOT NULL\n);\n\nCREATE TABLE Ksiazki (\n    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja\n    tytul        VARCHAR(200) NOT NULL,\n    rok          INTEGER CHECK (rok &gt; 0),\n    autor_id     INTEGER,\n    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)\n);\n\nW SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.\nW PostgreSQL SERIAL lub GENERATED ALWAYS AS IDENTITY.\n\nW powyÅ¼szym przykÅ‚adzie tabela Autorzy przechowuje dane o autorach, a tabela Ksiazki â€“ dane o ksiÄ…Å¼kach. Kolumna autor_id w tabeli Ksiazki jest kluczem obcym i wskazuje, ktÃ³ry autor napisaÅ‚ danÄ… ksiÄ…Å¼kÄ™. DziÄ™ki wiÄ™zom integralnoÅ›ci baza pilnuje, aby kaÅ¼da ksiÄ…Å¼ka miaÅ‚a poprawnego autora. Takie powiÄ…zania sÄ… podstawÄ… modelu relacyjnego.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#modyfikacja-i-usuwanie-tabel",
    "href": "lectures/wyklad4.html#modyfikacja-i-usuwanie-tabel",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "5ï¸âƒ£ Modyfikacja i usuwanie tabel",
    "text": "5ï¸âƒ£ Modyfikacja i usuwanie tabel\nALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;\n\nDROP TABLE Ksiazki;",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#wstawianie-danych-dml-data-manipulation-language",
    "href": "lectures/wyklad4.html#wstawianie-danych-dml-data-manipulation-language",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "6ï¸âƒ£ Wstawianie danych (DML â€“ Data Manipulation Language)",
    "text": "6ï¸âƒ£ Wstawianie danych (DML â€“ Data Manipulation Language)\nPolecenie INSERT INTO sÅ‚uÅ¼y do wprowadzania nowych wierszy (rekordÃ³w) do tabeli. WartoÅ›ci muszÄ… byÄ‡ zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.). MoÅ¼na dodaÄ‡ jeden lub wiele rekordÃ³w w jednym poleceniu. PoniÅ¼ej wstawiamy kilku autorÃ³w oraz ich ksiÄ…Å¼ki do utworzonych wczeÅ›niej tabel.\nINSERT INTO Autorzy (imie, nazwisko) VALUES\n('Adam', 'Mickiewicz'),\n('Henryk', 'Sienkiewicz'),\n('BolesÅ‚aw', 'Prus');\n\nINSERT INTO Ksiazki (tytul, rok, autor_id) VALUES\n('Pan Tadeusz', 1834, 1),\n('Quo Vadis', 1896, 2),\n('Lalka', 1890, 3);\nKaÅ¼dy rekord reprezentuje jednÄ… pozycjÄ™ w tabeli. Polecenie INSERT wymaga podania wartoÅ›ci w tej samej kolejnoÅ›ci, w jakiej wymieniono kolumny. JeÅ›li nie podamy jakiejÅ› kolumny, a ma ona zdefiniowanÄ… wartoÅ›Ä‡ domyÅ›lnÄ… (DEFAULT), baza wstawi jÄ… automatycznie. DziÄ™ki temu moÅ¼emy stopniowo budowaÄ‡ zawartoÅ›Ä‡ naszej bazy danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#wybieranie-danych-select",
    "href": "lectures/wyklad4.html#wybieranie-danych-select",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "7ï¸âƒ£ Wybieranie danych â€“ SELECT",
    "text": "7ï¸âƒ£ Wybieranie danych â€“ SELECT\n\nğŸ§© Podstawowy SELECT\nPolecenie SELECT jest najczÄ™Å›ciej uÅ¼ywanym poleceniem SQL i sÅ‚uÅ¼y do pobierania danych z tabel. Pozwala okreÅ›liÄ‡, ktÃ³re kolumny chcemy zobaczyÄ‡ i z ktÃ³rych tabel dane majÄ… pochodziÄ‡. JeÅ›li uÅ¼yjemy gwiazdki *, oznacza to, Å¼e wybieramy wszystkie kolumny. PoniÅ¼sze zapytanie zwraca wszystkich autorÃ³w z tabeli Autorzy.\nSELECT * FROM Autorzy;\n\n\nğŸ§© WybÃ³r konkretnych kolumn\nSELECT imie, nazwisko FROM Autorzy;\nWynik to peÅ‚na tabela z kolumnami autor_id, imie i nazwisko. CzÄ™sto jednak potrzebujemy tylko czÄ™Å›ci danych, np. imienia i nazwiska â€“ wtedy podajemy konkretne kolumny:\n\n\nğŸ§© Nadawanie aliasÃ³w\nSELECT imie AS \"ImiÄ™\", nazwisko AS \"Nazwisko\" FROM Autorzy;\nTakie zapytania pomagajÄ… ograniczyÄ‡ iloÅ›Ä‡ danych i zwiÄ™kszyÄ‡ czytelnoÅ›Ä‡ wynikÃ³w. Warto teÅ¼ nadawaÄ‡ aliasy (AS), ktÃ³re pozwalajÄ… zmieniÄ‡ nazwÄ™ kolumn w wynikach i nadaÄ‡ im bardziej opisowy wyglÄ…d.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#filtrowanie-where",
    "href": "lectures/wyklad4.html#filtrowanie-where",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "8ï¸âƒ£ Filtrowanie â€“ WHERE",
    "text": "8ï¸âƒ£ Filtrowanie â€“ WHERE\nKiedy chcemy wybraÄ‡ tylko czÄ™Å›Ä‡ danych, uÅ¼ywamy klauzuli WHERE. DziÄ™ki niej moÅ¼emy ustawiÄ‡ warunki, jakie muszÄ… speÅ‚niaÄ‡ rekordy, by pojawiÅ‚y siÄ™ w wyniku. To bardzo potÄ™Å¼ne narzÄ™dzie, ktÃ³re pozwala np. wyszukiwaÄ‡ ksiÄ…Å¼ki z konkretnego roku lub autora. W poniÅ¼szym przykÅ‚adzie wybieramy ksiÄ…Å¼ki wydane po roku 1850.\nSELECT * FROM Ksiazki\nWHERE rok &gt; 1850;\n\nğŸ§  Operatory:\nMoÅ¼emy teÅ¼ stosowaÄ‡ inne operatory:\n\n=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=\nLIKE â€˜Q%â€™ â†’ zaczyna siÄ™ na Q\nIN (â€¦)\nBETWEEN 1800 AND 1900\nIS NULL, IS NOT NULL\n\nNa przykÅ‚ad, aby znaleÅºÄ‡ wszystkie ksiÄ…Å¼ki, ktÃ³rych tytuÅ‚ zawiera literÄ™ â€aâ€, uÅ¼ywamy wzorca z LIKE:\nSELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';\nKlauzula WHERE pozwala wiÄ™c filtrowaÄ‡ dane na wiele sposobÃ³w, co czyni zapytania SQL bardzo elastycznymi.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#sortowanie-order-by",
    "href": "lectures/wyklad4.html#sortowanie-order-by",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "9ï¸âƒ£ Sortowanie â€“ ORDER BY",
    "text": "9ï¸âƒ£ Sortowanie â€“ ORDER BY\nPo pobraniu danych czÄ™sto chcemy uporzÄ…dkowaÄ‡ je wedÅ‚ug okreÅ›lonego kryterium. Do tego sÅ‚uÅ¼y klauzula ORDER BY, dziÄ™ki ktÃ³rej moÅ¼emy sortowaÄ‡ rosnÄ…co (ASC) lub malejÄ…co (DESC). Sortowanie dziaÅ‚a na dowolnej kolumnie, takÅ¼e tych, ktÃ³re nie sÄ… wyÅ›wietlane w wyniku. W przykÅ‚adzie poniÅ¼ej porzÄ…dkujemy ksiÄ…Å¼ki wedÅ‚ug roku wydania od najnowszej do najstarszej.\nSELECT * FROM Ksiazki ORDER BY rok DESC;\nJeÅ›li nie podamy kierunku sortowania, domyÅ›lnie jest to ASC (rosnÄ…co). MoÅ¼na teÅ¼ sortowaÄ‡ wedÅ‚ug kilku kolumn jednoczeÅ›nie, np. najpierw po autorze, a potem po roku. Sortowanie poprawia czytelnoÅ›Ä‡ wynikÃ³w i pozwala szybciej analizowaÄ‡ dane.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#grupowanie-i-agregacja-group-by-having",
    "href": "lectures/wyklad4.html#grupowanie-i-agregacja-group-by-having",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "ğŸ”Ÿ Grupowanie i agregacja â€“ GROUP BY, HAVING",
    "text": "ğŸ”Ÿ Grupowanie i agregacja â€“ GROUP BY, HAVING\nCzasem chcemy policzyÄ‡, ile danych naleÅ¼y do danej kategorii â€“ np. ilu autorÃ³w napisaÅ‚o wiÄ™cej niÅ¼ jednÄ… ksiÄ…Å¼kÄ™. Do tego sÅ‚uÅ¼y GROUP BY, ktÃ³re grupuje dane wedÅ‚ug wybranej kolumny. W poÅ‚Ä…czeniu z funkcjami agregujÄ…cymi, takimi jak COUNT(), AVG(), SUM(), MIN() czy MAX(), daje duÅ¼e moÅ¼liwoÅ›ci analizy. Klauzula HAVING pozwala odfiltrowaÄ‡ grupy po obliczeniu agregacji.\nSELECT autor_id, COUNT(*) AS liczba_ksiazek\nFROM Ksiazki\nGROUP BY autor_id\nHAVING COUNT(*) &gt; 1;\nTo zapytanie zwraca tylko tych autorÃ³w, ktÃ³rzy majÄ… wiÄ™cej niÅ¼ jednÄ… ksiÄ…Å¼kÄ™. RÃ³Å¼nica miÄ™dzy WHERE a HAVING polega na tym, Å¼e WHERE filtruje pojedyncze wiersze przed grupowaniem, a HAVING filtruje caÅ‚e grupy po agregacji. Wyniki moÅ¼na potem Å‚Ä…czyÄ‡ z innymi tabelami, by uzyskaÄ‡ bardziej opisowe raporty.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#Å‚Ä…czenie-tabel-join",
    "href": "lectures/wyklad4.html#Å‚Ä…czenie-tabel-join",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "1ï¸âƒ£1ï¸âƒ£ ÅÄ…czenie tabel â€“ JOIN",
    "text": "1ï¸âƒ£1ï¸âƒ£ ÅÄ…czenie tabel â€“ JOIN\nW relacyjnym modelu danych informacje sÄ… rozproszone w rÃ³Å¼nych tabelach, ktÃ³re Å‚Ä…czy siÄ™ przy pomocy kluczy obcych. Polecenie JOIN pozwala zestawiÄ‡ dane z kilku tabel na podstawie wspÃ³lnej kolumny. NajczÄ™Å›ciej uÅ¼ywany jest INNER JOIN, ktÃ³ry zwraca tylko rekordy, dla ktÃ³rych istnieje dopasowanie w obu tabelach. W przykÅ‚adzie Å‚Ä…czymy tabelÄ™ Ksiazki z Autorzy, aby zobaczyÄ‡ tytuÅ‚ ksiÄ…Å¼ki i jej autora.\n\nğŸ”¹ INNER JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\nWynikiem bÄ™dzie lista ksiÄ…Å¼ek wraz z imieniem i nazwiskiem autora. JeÅ›li chcemy, aby w wynikach pojawiÅ‚y siÄ™ takÅ¼e ksiÄ…Å¼ki bez autora (lub autorzy bez ksiÄ…Å¼ek), uÅ¼ywamy odpowiednio LEFT JOIN lub RIGHT JOIN. ÅÄ…czenie tabel to fundament relacyjnych baz danych â€“ dziÄ™ki niemu dane sÄ… spÃ³jne i nie trzeba ich powielaÄ‡.\n\n\nğŸ”¹ LEFT JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nLEFT JOIN Autorzy a ON k.autor_id = a.autor_id;",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#aktualizacja-i-usuwanie-danych",
    "href": "lectures/wyklad4.html#aktualizacja-i-usuwanie-danych",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "1ï¸âƒ£2ï¸âƒ£ Aktualizacja i usuwanie danych",
    "text": "1ï¸âƒ£2ï¸âƒ£ Aktualizacja i usuwanie danych\nPolecenie UPDATE pozwala modyfikowaÄ‡ dane juÅ¼ istniejÄ…ce w tabeli. Zawsze naleÅ¼y uÅ¼ywaÄ‡ klauzuli WHERE, aby zmiana nie objÄ™Å‚a wszystkich rekordÃ³w. Z kolei DELETE sÅ‚uÅ¼y do usuwania rekordÃ³w â€“ rÃ³wnieÅ¼ z warunkiem, by nie usunÄ…Ä‡ wszystkiego przez pomyÅ‚kÄ™. PrzykÅ‚ad poniÅ¼ej pokazuje, jak zmieniÄ‡ rok wydania ksiÄ…Å¼ki i usunÄ…Ä‡ starsze pozycje.\nUPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';\n\nDELETE FROM Ksiazki WHERE rok &lt; 1850;\nUPDATE pozwala teÅ¼ aktualizowaÄ‡ wiele kolumn naraz, a nawet wykonywaÄ‡ obliczenia. Z kolei DELETE usuwa rekordy z tabeli, ale nie zmienia struktury bazy. Warto zawsze testowaÄ‡ warunek WHERE wczeÅ›niej przy pomocy SELECT, by uniknÄ…Ä‡ niechcianych usuniÄ™Ä‡.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#podsumowanie",
    "href": "lectures/wyklad4.html#podsumowanie",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "Podsumowanie",
    "text": "Podsumowanie\nSQL jest jÄ™zykiem deklaratywnym â€“ opisujemy co chcemy uzyskaÄ‡, a nie jak to zrobiÄ‡. DziÄ™ki temu uÅ¼ytkownik nie musi znaÄ‡ szczegÃ³Å‚Ã³w dziaÅ‚ania bazy danych, wystarczy, Å¼e opisze warunki i strukturÄ™ zapytania. Poznane dziÅ› polecenia (CREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY) to fundament pracy z bazami danych. Opanowanie ich pozwala budowaÄ‡ i analizowaÄ‡ nawet bardzo zÅ‚oÅ¼one systemy informacyjne.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html",
    "href": "lectures/wyklad7.html",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Podzapytanie to zapytanie wewnÄ…trz innego zapytania SQL. SÅ‚uÅ¼y do wykonywania bardziej zÅ‚oÅ¼onych operacji, kiedy jedno zapytanie potrzebuje wynikÃ³w innego.\nMoÅ¼emy je traktowaÄ‡ jak â€mini-zapytaniaâ€, ktÃ³re dostarczajÄ… danych do zapytania gÅ‚Ã³wnego.\nPodzapytania mogÄ… wystÄ™powaÄ‡ w rÃ³Å¼nych miejscach:\n\nw klauzuli WHERE â€“ do filtrowania danych,\nw klauzuli FROM â€“ jako tymczasowa tabela,\nw klauzuli SELECT â€“ do obliczeÅ„ w kaÅ¼dej krotce,\nw konstrukcjach EXISTS, IN, ALL, ANY â€“ do testowania warunkÃ³w logicznych.\n\n\n\nTo najczÄ™stszy typ podzapytania.\nZapytanie gÅ‚Ã³wne wybiera dane na podstawie wartoÅ›ci zwrÃ³conej przez podzapytanie.\n\n\nZnajdÅº ksiÄ…Å¼ki napisane przez autora o nazwisku Sienkiewicz.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id = (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko = 'Sienkiewicz'\n);\n\n\n\n\nPodzapytanie wewnÄ™trzne szuka identyfikatora autora autor_id, ktÃ³rego nazwisko to Sienkiewicz.\nZapytanie gÅ‚Ã³wne wybiera z tabeli Ksiazki tylko te rekordy, w ktÃ³rych autor_id jest rÃ³wny wynikowi podzapytania.\n\n\nğŸ”¸ Takie podzapytanie musi zwrÃ³ciÄ‡ jednÄ… wartoÅ›Ä‡ (scalar subquery) â€“ w przeciwnym razie wystÄ…pi bÅ‚Ä…d.\n\n\n\n\n\nJeÅ›li podzapytanie zwraca wiÄ™cej niÅ¼ jeden rekord, uÅ¼ywamy operatora IN.\n\n\nZnajdÅº wszystkie ksiÄ…Å¼ki autorÃ³w, ktÃ³rych nazwiska zaczynajÄ… siÄ™ na literÄ™ M.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id IN (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko LIKE 'M%'\n);\n\n\n\n\nPodzapytanie wewnÄ™trzne zwraca listÄ™ identyfikatorÃ³w autorÃ³w, np. [1, 5, 7].\nZapytanie gÅ‚Ã³wne wybiera ksiÄ…Å¼ki, ktÃ³rych autor_id znajduje siÄ™ na tej liÅ›cie.\n\n\nğŸ”¸ Operator IN moÅ¼na traktowaÄ‡ jak porÃ³wnanie z â€wieloma wartoÅ›ciami jednoczeÅ›nieâ€.\n\n\n\n\n\nPodzapytanie moÅ¼e teÅ¼ zwracaÄ‡ pojedynczÄ… wartoÅ›Ä‡ (skalarnÄ…) i byÄ‡ uÅ¼yte w liÅ›cie kolumn.\n\n\nWyÅ›wietl listÄ™ autorÃ³w wraz z liczbÄ… ich ksiÄ…Å¼ek.\nSELECT\n    a.imie,\n    a.nazwisko,\n    (\n        SELECT COUNT(*)\n        FROM Ksiazki k\n        WHERE k.autor_id = a.autor_id\n    ) AS liczba_ksiazek\nFROM Autorzy a;\n\n\n\n\nDla kaÅ¼dego autora (a.autor_id) wykonuje siÄ™ osobne podzapytanie, ktÃ³re liczy ksiÄ…Å¼ki przypisane do tego autora.\nWynik jest dodawany jako nowa kolumna liczba_ksiazek.\n\n\nğŸ”¸ To tzw. podzapytanie skorelowane (correlated subquery), poniewaÅ¼ odnosi siÄ™ do kolumny z zapytania gÅ‚Ã³wnego.\n\n\n\n\n\nPodzapytanie moÅ¼e tworzyÄ‡ tymczasowÄ… tabelÄ™ w sekcji FROM. Takie rozwiÄ…zanie nazywa siÄ™ derived table i pozwala na pracÄ™ z przetworzonymi danymi.\n\n\nPolicz Å›redni rok wydania ksiÄ…Å¼ek, a nastÄ™pnie wybierz te, ktÃ³re sÄ… starsze od Å›redniej.\nSELECT tytul, rok\nFROM (\n    SELECT *\n    FROM Ksiazki\n) AS K\nWHERE K.rok &lt; (\n    SELECT AVG(rok) FROM Ksiazki\n);\n\n\n\n\nPodzapytanie w FROM tworzy tymczasowÄ… tabelÄ™ K.\nW klauzuli WHERE uÅ¼ywamy innego podzapytania, ktÃ³re liczy Å›redni rok wydania.\nWynik to ksiÄ…Å¼ki starsze od Å›redniej publikacji.\n\n\n\n\n\nTo podzapytanie, ktÃ³re odwoÅ‚uje siÄ™ do kolumn z zapytania gÅ‚Ã³wnego. Wykonuje siÄ™ dla kaÅ¼dego wiersza osobno â€“ dlatego bywa wolniejsze, ale bardzo elastyczne.\n\n\nZnajdÅº najstarszÄ… ksiÄ…Å¼kÄ™ kaÅ¼dego autora.\nSELECT k.tytul, k.rok, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id\nWHERE k.rok = (\n    SELECT MIN(rok)\n    FROM Ksiazki\n    WHERE autor_id = k.autor_id\n);\n\n\n\n\nDla kaÅ¼dego wiersza w tabeli Ksiazki podzapytanie szuka najmniejszego roku dla tego samego autora.\nPorÃ³wnanie k.rok = (MIN(rok)) sprawia, Å¼e zostaje tylko najstarsza ksiÄ…Å¼ka kaÅ¼dego autora.\n\n\n\n\n\nOperator EXISTS sprawdza, czy podzapytanie zwrÃ³ciÅ‚o jakiekolwiek wiersze. Nie liczy ich â€” interesuje nas jedynie, czy wynik istnieje (TRUE/FALSE).\n\n\nZnajdÅº autorÃ³w, ktÃ³rzy napisali przynajmniej jednÄ… ksiÄ…Å¼kÄ™.\nSELECT imie, nazwisko\nFROM Autorzy a\nWHERE EXISTS (\n    SELECT 1\n    FROM Ksiazki k\n    WHERE k.autor_id = a.autor_id\n);\n\n\n\n\nDla kaÅ¼dego autora sprawdzane jest, czy istnieje co najmniej jeden wiersz w tabeli Ksiazki z tym samym autor_id.\nJeÅ›li tak â€” warunek EXISTS zwraca TRUE, a autor pojawia siÄ™ w wyniku.\n\n\n\n\n\nOperator ALL wymaga, aby warunek byÅ‚ speÅ‚niony dla wszystkich wynikÃ³w podzapytania. Operator ANY (lub SOME) â€“ aby warunek byÅ‚ speÅ‚niony dla przynajmniej jednego.\n\n\nZnajdÅº ksiÄ…Å¼ki wydane wczeÅ›niej niÅ¼ wszystkie ksiÄ…Å¼ki Prusa.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE rok &lt; ALL (\n    SELECT rok\n    FROM Ksiazki\n    WHERE autor_id = (\n        SELECT autor_id FROM Autorzy WHERE nazwisko = 'Prus'\n    )\n);\n\n\n\n\nPodzapytanie wewnÄ™trzne zwraca lata publikacji ksiÄ…Å¼ek Prusa.\nZapytanie gÅ‚Ã³wne wybiera tylko te ksiÄ…Å¼ki, ktÃ³rych rok jest mniejszy niÅ¼ wszystkie te wartoÅ›ci.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTyp podzapytania\nMiejsce uÅ¼ycia\nZwracany wynik\nTypowe operatory\nPrzykÅ‚ad zastosowania\n\n\n\n\nJednowartoÅ›ciowe (scalar)\nWHERE, SELECT\nPojedyncza wartoÅ›Ä‡ (1 rekord, 1 kolumna)\n=, &lt;, &gt;\nAutor o nazwisku â€Sienkiewiczâ€\n\n\nWielowartoÅ›ciowe (multivalue)\nWHERE\nLista wartoÅ›ci (wiele rekordÃ³w)\nIN, NOT IN\nAutorzy, ktÃ³rych nazwisko zaczyna siÄ™ na â€Mâ€\n\n\nKorelowane (correlated)\nWHERE, SELECT\nZmienny wynik dla kaÅ¼dego wiersza\n=, EXISTS\nNajstarsza ksiÄ…Å¼ka danego autora\n\n\nZagnieÅ¼dÅ¼one w FROM (tabela pochodna)\nFROM\nZbiÃ³r wierszy (tymczasowa tabela)\nâ€”\nÅšredni rok wydania ksiÄ…Å¼ek i porÃ³wnanie ze Å›redniÄ…\n\n\nZ operatorem EXISTS / NOT EXISTS\nWHERE\nPrawda / FaÅ‚sz (czy istnieje wynik)\nEXISTS, NOT EXISTS\nAutorzy, ktÃ³rzy napisali przynajmniej jednÄ… ksiÄ…Å¼kÄ™\n\n\nZ operatorem ALL / ANY / SOME\nWHERE\nPorÃ³wnanie z wieloma wartoÅ›ciami\nALL, ANY, SOME\nKsiÄ…Å¼ki starsze niÅ¼ wszystkie ksiÄ…Å¼ki Prusa",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-w-klauzuli-where-jednowartoÅ›ciowe",
    "href": "lectures/wyklad7.html#podzapytanie-w-klauzuli-where-jednowartoÅ›ciowe",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "To najczÄ™stszy typ podzapytania.\nZapytanie gÅ‚Ã³wne wybiera dane na podstawie wartoÅ›ci zwrÃ³conej przez podzapytanie.\n\n\nZnajdÅº ksiÄ…Å¼ki napisane przez autora o nazwisku Sienkiewicz.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id = (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko = 'Sienkiewicz'\n);\n\n\n\n\nPodzapytanie wewnÄ™trzne szuka identyfikatora autora autor_id, ktÃ³rego nazwisko to Sienkiewicz.\nZapytanie gÅ‚Ã³wne wybiera z tabeli Ksiazki tylko te rekordy, w ktÃ³rych autor_id jest rÃ³wny wynikowi podzapytania.\n\n\nğŸ”¸ Takie podzapytanie musi zwrÃ³ciÄ‡ jednÄ… wartoÅ›Ä‡ (scalar subquery) â€“ w przeciwnym razie wystÄ…pi bÅ‚Ä…d.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-zwracajÄ…ce-wiele-wartoÅ›ci-operator-in",
    "href": "lectures/wyklad7.html#podzapytanie-zwracajÄ…ce-wiele-wartoÅ›ci-operator-in",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "JeÅ›li podzapytanie zwraca wiÄ™cej niÅ¼ jeden rekord, uÅ¼ywamy operatora IN.\n\n\nZnajdÅº wszystkie ksiÄ…Å¼ki autorÃ³w, ktÃ³rych nazwiska zaczynajÄ… siÄ™ na literÄ™ M.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id IN (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko LIKE 'M%'\n);\n\n\n\n\nPodzapytanie wewnÄ™trzne zwraca listÄ™ identyfikatorÃ³w autorÃ³w, np. [1, 5, 7].\nZapytanie gÅ‚Ã³wne wybiera ksiÄ…Å¼ki, ktÃ³rych autor_id znajduje siÄ™ na tej liÅ›cie.\n\n\nğŸ”¸ Operator IN moÅ¼na traktowaÄ‡ jak porÃ³wnanie z â€wieloma wartoÅ›ciami jednoczeÅ›nieâ€.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-w-klauzuli-select",
    "href": "lectures/wyklad7.html#podzapytanie-w-klauzuli-select",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Podzapytanie moÅ¼e teÅ¼ zwracaÄ‡ pojedynczÄ… wartoÅ›Ä‡ (skalarnÄ…) i byÄ‡ uÅ¼yte w liÅ›cie kolumn.\n\n\nWyÅ›wietl listÄ™ autorÃ³w wraz z liczbÄ… ich ksiÄ…Å¼ek.\nSELECT\n    a.imie,\n    a.nazwisko,\n    (\n        SELECT COUNT(*)\n        FROM Ksiazki k\n        WHERE k.autor_id = a.autor_id\n    ) AS liczba_ksiazek\nFROM Autorzy a;\n\n\n\n\nDla kaÅ¼dego autora (a.autor_id) wykonuje siÄ™ osobne podzapytanie, ktÃ³re liczy ksiÄ…Å¼ki przypisane do tego autora.\nWynik jest dodawany jako nowa kolumna liczba_ksiazek.\n\n\nğŸ”¸ To tzw. podzapytanie skorelowane (correlated subquery), poniewaÅ¼ odnosi siÄ™ do kolumny z zapytania gÅ‚Ã³wnego.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-w-klauzuli-from-tabela-pochodna",
    "href": "lectures/wyklad7.html#podzapytanie-w-klauzuli-from-tabela-pochodna",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Podzapytanie moÅ¼e tworzyÄ‡ tymczasowÄ… tabelÄ™ w sekcji FROM. Takie rozwiÄ…zanie nazywa siÄ™ derived table i pozwala na pracÄ™ z przetworzonymi danymi.\n\n\nPolicz Å›redni rok wydania ksiÄ…Å¼ek, a nastÄ™pnie wybierz te, ktÃ³re sÄ… starsze od Å›redniej.\nSELECT tytul, rok\nFROM (\n    SELECT *\n    FROM Ksiazki\n) AS K\nWHERE K.rok &lt; (\n    SELECT AVG(rok) FROM Ksiazki\n);\n\n\n\n\nPodzapytanie w FROM tworzy tymczasowÄ… tabelÄ™ K.\nW klauzuli WHERE uÅ¼ywamy innego podzapytania, ktÃ³re liczy Å›redni rok wydania.\nWynik to ksiÄ…Å¼ki starsze od Å›redniej publikacji.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#korelowane-podzapytanie-correlated-subquery",
    "href": "lectures/wyklad7.html#korelowane-podzapytanie-correlated-subquery",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "To podzapytanie, ktÃ³re odwoÅ‚uje siÄ™ do kolumn z zapytania gÅ‚Ã³wnego. Wykonuje siÄ™ dla kaÅ¼dego wiersza osobno â€“ dlatego bywa wolniejsze, ale bardzo elastyczne.\n\n\nZnajdÅº najstarszÄ… ksiÄ…Å¼kÄ™ kaÅ¼dego autora.\nSELECT k.tytul, k.rok, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id\nWHERE k.rok = (\n    SELECT MIN(rok)\n    FROM Ksiazki\n    WHERE autor_id = k.autor_id\n);\n\n\n\n\nDla kaÅ¼dego wiersza w tabeli Ksiazki podzapytanie szuka najmniejszego roku dla tego samego autora.\nPorÃ³wnanie k.rok = (MIN(rok)) sprawia, Å¼e zostaje tylko najstarsza ksiÄ…Å¼ka kaÅ¼dego autora.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-z-exists",
    "href": "lectures/wyklad7.html#podzapytanie-z-exists",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Operator EXISTS sprawdza, czy podzapytanie zwrÃ³ciÅ‚o jakiekolwiek wiersze. Nie liczy ich â€” interesuje nas jedynie, czy wynik istnieje (TRUE/FALSE).\n\n\nZnajdÅº autorÃ³w, ktÃ³rzy napisali przynajmniej jednÄ… ksiÄ…Å¼kÄ™.\nSELECT imie, nazwisko\nFROM Autorzy a\nWHERE EXISTS (\n    SELECT 1\n    FROM Ksiazki k\n    WHERE k.autor_id = a.autor_id\n);\n\n\n\n\nDla kaÅ¼dego autora sprawdzane jest, czy istnieje co najmniej jeden wiersz w tabeli Ksiazki z tym samym autor_id.\nJeÅ›li tak â€” warunek EXISTS zwraca TRUE, a autor pojawia siÄ™ w wyniku.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#porÃ³wnania-z-all-any",
    "href": "lectures/wyklad7.html#porÃ³wnania-z-all-any",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Operator ALL wymaga, aby warunek byÅ‚ speÅ‚niony dla wszystkich wynikÃ³w podzapytania. Operator ANY (lub SOME) â€“ aby warunek byÅ‚ speÅ‚niony dla przynajmniej jednego.\n\n\nZnajdÅº ksiÄ…Å¼ki wydane wczeÅ›niej niÅ¼ wszystkie ksiÄ…Å¼ki Prusa.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE rok &lt; ALL (\n    SELECT rok\n    FROM Ksiazki\n    WHERE autor_id = (\n        SELECT autor_id FROM Autorzy WHERE nazwisko = 'Prus'\n    )\n);\n\n\n\n\nPodzapytanie wewnÄ™trzne zwraca lata publikacji ksiÄ…Å¼ek Prusa.\nZapytanie gÅ‚Ã³wne wybiera tylko te ksiÄ…Å¼ki, ktÃ³rych rok jest mniejszy niÅ¼ wszystkie te wartoÅ›ci.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTyp podzapytania\nMiejsce uÅ¼ycia\nZwracany wynik\nTypowe operatory\nPrzykÅ‚ad zastosowania\n\n\n\n\nJednowartoÅ›ciowe (scalar)\nWHERE, SELECT\nPojedyncza wartoÅ›Ä‡ (1 rekord, 1 kolumna)\n=, &lt;, &gt;\nAutor o nazwisku â€Sienkiewiczâ€\n\n\nWielowartoÅ›ciowe (multivalue)\nWHERE\nLista wartoÅ›ci (wiele rekordÃ³w)\nIN, NOT IN\nAutorzy, ktÃ³rych nazwisko zaczyna siÄ™ na â€Mâ€\n\n\nKorelowane (correlated)\nWHERE, SELECT\nZmienny wynik dla kaÅ¼dego wiersza\n=, EXISTS\nNajstarsza ksiÄ…Å¼ka danego autora\n\n\nZagnieÅ¼dÅ¼one w FROM (tabela pochodna)\nFROM\nZbiÃ³r wierszy (tymczasowa tabela)\nâ€”\nÅšredni rok wydania ksiÄ…Å¼ek i porÃ³wnanie ze Å›redniÄ…\n\n\nZ operatorem EXISTS / NOT EXISTS\nWHERE\nPrawda / FaÅ‚sz (czy istnieje wynik)\nEXISTS, NOT EXISTS\nAutorzy, ktÃ³rzy napisali przynajmniej jednÄ… ksiÄ…Å¼kÄ™\n\n\nZ operatorem ALL / ANY / SOME\nWHERE\nPorÃ³wnanie z wieloma wartoÅ›ciami\nALL, ANY, SOME\nKsiÄ…Å¼ki starsze niÅ¼ wszystkie ksiÄ…Å¼ki Prusa",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#tworzenie-widoku",
    "href": "lectures/wyklad7.html#tworzenie-widoku",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "ğŸ”¹ 1. Tworzenie widoku",
    "text": "ğŸ”¹ 1. Tworzenie widoku\nWidok tworzymy za pomocÄ… polecenia CREATE VIEW.\n\nPrzykÅ‚ad:\nUtwÃ³rz widok wyÅ›wietlajÄ…cy listÄ™ ksiÄ…Å¼ek wraz z nazwiskiem autora.\nCREATE VIEW Widok_Ksiazki_Autorzy AS\nSELECT\n    k.tytul,\n    k.rok,\n    a.imie,\n    a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\nâ¡ï¸ Po utworzeniu widoku moÅ¼na z niego korzystaÄ‡ tak, jak z kaÅ¼dej innej tabeli:\nSELECT * FROM Widok_Ksiazki_Autorzy;",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#widoki-jako-warstwa-abstrakcji",
    "href": "lectures/wyklad7.html#widoki-jako-warstwa-abstrakcji",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "ğŸ”¹ 2. Widoki jako warstwa abstrakcji",
    "text": "ğŸ”¹ 2. Widoki jako warstwa abstrakcji\nWidoki dziaÅ‚ajÄ… jak poziom poÅ›redni miÄ™dzy uÅ¼ytkownikiem a fizycznÄ… strukturÄ… bazy danych. UÅ¼ytkownik nie musi znaÄ‡ szczegÃ³Å‚Ã³w Å‚Ä…czenia tabel, kluczy obcych czy kolumn â€” wystarczy, Å¼e zna nazwÄ™ widoku.\n\nPrzykÅ‚ad:\nWidok pokazujÄ…cy tylko podstawowe dane o ksiÄ…Å¼kach:\nCREATE VIEW Widok_Biblioteka_Publiczna AS\nSELECT tytul, rok\nFROM Ksiazki;\nâ¡ï¸ UÅ¼ytkownik moÅ¼e wykonaÄ‡:\nSELECT * FROM Widok_Biblioteka_Publiczna;\ni otrzymaÄ‡ uproszczony zestaw danych bez dostÄ™pu do tabel ÅºrÃ³dÅ‚owych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#widoki-oparte-na-podzapytaniach",
    "href": "lectures/wyklad7.html#widoki-oparte-na-podzapytaniach",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "ğŸ”¹ 3. Widoki oparte na podzapytaniach",
    "text": "ğŸ”¹ 3. Widoki oparte na podzapytaniach\nWidoki mogÄ… zawieraÄ‡ podzapytania â€” dziÄ™ki temu moÅ¼na tworzyÄ‡ widoki analityczne, raportowe, czy agregujÄ…ce dane.\n\nPrzykÅ‚ad:\nWidok pokazujÄ…cy liczbÄ™ ksiÄ…Å¼ek napisanych przez kaÅ¼dego autora:\nCREATE VIEW Widok_LiczbaKsiazek AS\nSELECT\n    a.autor_id,\n    a.imie,\n    a.nazwisko,\n    COUNT(k.ksiazka_id) AS liczba_ksiazek\nFROM Autorzy a\nLEFT JOIN Ksiazki k ON a.autor_id = k.autor_id\nGROUP BY a.autor_id, a.imie, a.nazwisko;\nâ¡ï¸ NastÄ™pnie moÅ¼emy wykonaÄ‡:\nSELECT * FROM Widok_LiczbaKsiazek WHERE liczba_ksiazek &gt; 3;",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#aktualizowalnoÅ›Ä‡-widokÃ³w",
    "href": "lectures/wyklad7.html#aktualizowalnoÅ›Ä‡-widokÃ³w",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "ğŸ”¹ 4. AktualizowalnoÅ›Ä‡ widokÃ³w",
    "text": "ğŸ”¹ 4. AktualizowalnoÅ›Ä‡ widokÃ³w\nNie kaÅ¼dy widok moÅ¼na modyfikowaÄ‡ (czyli wykonywaÄ‡ INSERT, UPDATE, DELETE).\nWidoki sÄ… aktualizowalne, jeÅ›li:\n\nodnoszÄ… siÄ™ tylko do jednej tabeli,\nnie zawierajÄ… GROUP BY, DISTINCT, UNION, HAVING ani funkcji agregujÄ…cych,\nnie zawierajÄ… podzapytaÅ„ w klauzuli SELECT.\n\nJeÅ›li widok jest bardziej zÅ‚oÅ¼ony (np. z JOIN lub GROUP BY), staje siÄ™ tylko do odczytu.\n\nPrzykÅ‚ad â€“ widok aktualizowalny:\nCREATE VIEW Widok_AutorzyPodstawowi AS\nSELECT autor_id, imie, nazwisko\nFROM Autorzy;\nMoÅ¼emy:\nUPDATE Widok_AutorzyPodstawowi\nSET nazwisko = 'Nowak'\nWHERE autor_id = 1;",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#usuwanie-i-modyfikacja-widokÃ³w",
    "href": "lectures/wyklad7.html#usuwanie-i-modyfikacja-widokÃ³w",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "ğŸ”¹ 5. Usuwanie i modyfikacja widokÃ³w",
    "text": "ğŸ”¹ 5. Usuwanie i modyfikacja widokÃ³w\nAby usunÄ…Ä‡ widok:\nDROP VIEW Widok_LiczbaKsiazek;\nAby zmieniÄ‡ definicjÄ™ widoku:\nCREATE OR REPLACE VIEW Widok_LiczbaKsiazek AS\nSELECT nazwisko, COUNT(*) AS liczba\nFROM Autorzy a\nJOIN Ksiazki k ON a.autor_id = k.autor_id\nGROUP BY nazwisko;",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#zalety-i-wady-widokÃ³w",
    "href": "lectures/wyklad7.html#zalety-i-wady-widokÃ³w",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "ğŸ”¹ 6. Zalety i wady widokÃ³w",
    "text": "ğŸ”¹ 6. Zalety i wady widokÃ³w\nâœ… Zalety:\n\nUproszczenie zÅ‚oÅ¼onych zapytaÅ„ (abstrakcja)\nZwiÄ™kszenie bezpieczeÅ„stwa â€“ ograniczony dostÄ™p do danych\nReuÅ¼ywalnoÅ›Ä‡ â€“ jedno miejsce definicji raportu\nMoÅ¼liwoÅ›Ä‡ definiowania logicznych perspektyw danych\n\nâš ï¸ Wady:\n\nWydajnoÅ›Ä‡ â€“ kaÅ¼de odwoÅ‚anie do widoku powoduje wykonanie zapytania ÅºrÃ³dÅ‚owego\nOgraniczona aktualizowalnoÅ›Ä‡\nZÅ‚oÅ¼one widoki mogÄ… utrudniaÄ‡ debugowanie i optymalizacjÄ™\n\n\nğŸ§© PrzykÅ‚ad praktyczny â€“ widok zagnieÅ¼dÅ¼ony\nWidoki moÅ¼na zagnieÅ¼dÅ¼aÄ‡ â€“ jeden widok moÅ¼e korzystaÄ‡ z innego.\nCREATE VIEW Widok_StarsiAutorzy AS\nSELECT autor_id, imie, nazwisko\nFROM Autorzy\nWHERE rok_urodzenia &lt; 1950;\n\nCREATE VIEW Widok_StarsiAutorzy_LiczbaKsiazek AS\nSELECT\n    sa.imie,\n    sa.nazwisko,\n    COUNT(k.ksiazka_id) AS liczba_ksiazek\nFROM Widok_StarsiAutorzy sa\nJOIN Ksiazki k ON sa.autor_id = k.autor_id\nGROUP BY sa.imie, sa.nazwisko;\nâ¡ï¸ Teraz moÅ¼esz wykonaÄ‡:\n\nSELECT * FROM Widok_StarsiAutorzy_LiczbaKsiazek\nWHERE liczba_ksiazek &gt; 2;\nWidoki pozwalajÄ… budowaÄ‡ hierarchiÄ™ logicznych perspektyw danych â€” od prostych po analityczne.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#najwaÅ¼niejsze-wnioski",
    "href": "lectures/wyklad7.html#najwaÅ¼niejsze-wnioski",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "ğŸ“˜ NajwaÅ¼niejsze wnioski",
    "text": "ğŸ“˜ NajwaÅ¼niejsze wnioski\n\nWidoki nie przechowujÄ… danych, lecz definicjÄ™ zapytania.\nMoÅ¼na je traktowaÄ‡ jak â€tabele wirtualneâ€.\nUÅ‚atwiajÄ… zarzÄ…dzanie dostÄ™pem do danych i tworzenie raportÃ³w.\nProste widoki sÄ… aktualizowalne, zÅ‚oÅ¼one â€” tylko do odczytu.\nMoÅ¼na je zagnieÅ¼dÅ¼aÄ‡, tworzÄ…c coraz bardziej rozbudowane analizy.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/plan.html",
    "href": "lectures/plan.html",
    "title": "Projektowanie Relacyjnych Baz Danych",
    "section": "",
    "text": "WykÅ‚ad 1: Wprowadzenie do baz danych i model relacyjny â€¢ Historia i ewolucja baz danych â€¢ Podstawowe pojÄ™cia: dane, informacja, baza danych, DBMS â€¢ Architektura systemÃ³w baz danych (ANSI/SPARC, poziomy abstrakcji) â€¢ Model relacyjny: relacje, krotki, atrybuty, domeny â€¢ Klucze (gÅ‚Ã³wny, obcy, kandydujÄ…ce) i integralnoÅ›Ä‡ danych\nâ¸»\nWykÅ‚ad 2: Projektowanie koncepcyjne â€“ model ER (Entity-Relationship) â€¢ Analiza wymagaÅ„ uÅ¼ytkownika â€¢ Diagramy encja-zwiÄ…zek (ERD): encje, atrybuty, zwiÄ…zki â€¢ Typy zwiÄ…zkÃ³w: 1:1, 1:N, N:M â€¢ Atrybuty proste, zÅ‚oÅ¼one, wielowartoÅ›ciowe â€¢ Ä†wiczenia: tworzenie ERD dla prostego systemu\nâ¸»\nWykÅ‚ad 3: Od modelu ER do modelu relacyjnego â€¢ ReguÅ‚y transformacji ERD na schemat relacyjny â€¢ Mapowanie encji i zwiÄ…zkÃ³w â€¢ Schemat relacyjny â€“ projektowanie tabel â€¢ Ä†wiczenia: przejÅ›cie od ERD do relacji\nâ¸»\nWykÅ‚ad 4: Normalizacja baz danych â€¢ Redundancja i anomalia danych (wstawiania, modyfikacji, usuwania) â€¢ Klucze funkcyjne i zaleÅ¼noÅ›ci funkcyjne â€¢ Postacie normalne: 1NF, 2NF, 3NF, BCNF â€¢ PrzykÅ‚ady normalizacji i denormalizacji\nâ¸»\nWykÅ‚ad 5: Wprowadzenie do SQL â€“ definicja danych (DDL) â€¢ Podstawowe elementy skÅ‚adni SQL â€¢ Tworzenie baz danych i tabel (CREATE DATABASE, CREATE TABLE) â€¢ Typy danych w SQL â€¢ Ograniczenia integralnoÅ›ci (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL) â€¢ Modyfikacja schematu (ALTER TABLE, DROP TABLE)\nâ¸»\nWykÅ‚ad 6: SQL â€“ manipulacja danymi (DML) â€¢ Wstawianie danych (INSERT) â€¢ Aktualizacja i usuwanie danych (UPDATE, DELETE) â€¢ Podstawowe zapytania (SELECT, FROM, WHERE) â€¢ Operatory logiczne i porÃ³wnania â€¢ Operacje na zbiorach (UNION, INTERSECT, EXCEPT)\nâ¸»\nWykÅ‚ad 7: SQL â€“ zapytania zÅ‚oÅ¼one i funkcje â€¢ ÅÄ…czenia tabel (JOIN: INNER, LEFT, RIGHT, FULL) â€¢ Funkcje agregujÄ…ce (COUNT, SUM, AVG, MIN, MAX) â€¢ Grupowanie i filtrowanie grup (GROUP BY, HAVING) â€¢ Podzapytania (subqueries) â€¢ KrÃ³tki wstÄ™p do indeksÃ³w i wydajnoÅ›ci zapytaÅ„"
  }
]