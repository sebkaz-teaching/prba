[
  {
    "objectID": "lectures/plan.html",
    "href": "lectures/plan.html",
    "title": "Projektowanie Relacyjnych Baz Danych",
    "section": "",
    "text": "Wykład 1: Wprowadzenie do baz danych i model relacyjny • Historia i ewolucja baz danych • Podstawowe pojęcia: dane, informacja, baza danych, DBMS • Architektura systemów baz danych (ANSI/SPARC, poziomy abstrakcji) • Model relacyjny: relacje, krotki, atrybuty, domeny • Klucze (główny, obcy, kandydujące) i integralność danych\n⸻\nWykład 2: Projektowanie koncepcyjne – model ER (Entity-Relationship) • Analiza wymagań użytkownika • Diagramy encja-związek (ERD): encje, atrybuty, związki • Typy związków: 1:1, 1:N, N:M • Atrybuty proste, złożone, wielowartościowe • Ćwiczenia: tworzenie ERD dla prostego systemu\n⸻\nWykład 3: Od modelu ER do modelu relacyjnego • Reguły transformacji ERD na schemat relacyjny • Mapowanie encji i związków • Schemat relacyjny – projektowanie tabel • Ćwiczenia: przejście od ERD do relacji\n⸻\nWykład 4: Normalizacja baz danych • Redundancja i anomalia danych (wstawiania, modyfikacji, usuwania) • Klucze funkcyjne i zależności funkcyjne • Postacie normalne: 1NF, 2NF, 3NF, BCNF • Przykłady normalizacji i denormalizacji\n⸻\nWykład 5: Wprowadzenie do SQL – definicja danych (DDL) • Podstawowe elementy składni SQL • Tworzenie baz danych i tabel (CREATE DATABASE, CREATE TABLE) • Typy danych w SQL • Ograniczenia integralności (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL) • Modyfikacja schematu (ALTER TABLE, DROP TABLE)\n⸻\nWykład 6: SQL – manipulacja danymi (DML) • Wstawianie danych (INSERT) • Aktualizacja i usuwanie danych (UPDATE, DELETE) • Podstawowe zapytania (SELECT, FROM, WHERE) • Operatory logiczne i porównania • Operacje na zbiorach (UNION, INTERSECT, EXCEPT)\n⸻\nWykład 7: SQL – zapytania złożone i funkcje • Łączenia tabel (JOIN: INNER, LEFT, RIGHT, FULL) • Funkcje agregujące (COUNT, SUM, AVG, MIN, MAX) • Grupowanie i filtrowanie grup (GROUP BY, HAVING) • Podzapytania (subqueries) • Krótki wstęp do indeksów i wydajności zapytań"
  },
  {
    "objectID": "lectures/wyklad4.html",
    "href": "lectures/wyklad4.html",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKażdy wiersz (row) = rekord / krotka\n\nKażda kolumna (column) = atrybut\n\nDziedzina (domain) = zbiór dopuszczalnych wartości w kolumnie\n\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "href": "lectures/wyklad4.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKażdy wiersz (row) = rekord / krotka\n\nKażda kolumna (column) = atrybut\n\nDziedzina (domain) = zbiór dopuszczalnych wartości w kolumnie\n\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#klucze-i-więzy-integralności",
    "href": "lectures/wyklad4.html#klucze-i-więzy-integralności",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "2️⃣ Klucze i więzy integralności",
    "text": "2️⃣ Klucze i więzy integralności\n\n🔸 Klucz główny (PRIMARY KEY)\n\nUnikalnie identyfikuje każdy wiersz w tabeli.\nNie może być NULL.\n\n\n\n🔸 Klucz obcy (FOREIGN KEY)\n\nOdwołuje się do innej tabeli (relacja między tabelami).\n\n\n\n🔸 Inne więzy:\n\nUNIQUE – unikalność wartości w kolumnie.\nNOT NULL – kolumna nie może mieć wartości pustej.\nCHECK – warunek logiczny na wartość kolumny.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#schemat-bazy-danych-przykład-biblioteka",
    "href": "lectures/wyklad4.html#schemat-bazy-danych-przykład-biblioteka",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "3️⃣ Schemat bazy danych – przykład „Biblioteka”",
    "text": "3️⃣ Schemat bazy danych – przykład „Biblioteka”\n\nTabele:\n\nAutorzy (autor_id, imie, nazwisko)\nKsiazki (ksiazka_id, tytul, rok, autor_id)\n\n\n\nRelacja:\n\nKsiazki.autor_id \\(\\to\\) Autorzy.autor_id (klucz obcy)",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#tworzenie-tabel-ddl-data-definition-language",
    "href": "lectures/wyklad4.html#tworzenie-tabel-ddl-data-definition-language",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "4️⃣ Tworzenie tabel (DDL – Data Definition Language)",
    "text": "4️⃣ Tworzenie tabel (DDL – Data Definition Language)\nPolecenie CREATE TABLE służy do utworzenia nowej tabeli w bazie danych.\nW tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz różne więzy integralności, takie jak PRIMARY KEY, NOT NULL czy FOREIGN KEY.\nKażda tabela powinna mieć kolumnę, która jednoznacznie identyfikuje każdy wiersz – to właśnie klucz główny.\nW przykładzie poniżej tworzymy dwie tabele: Autorzy i Ksiazki, które będą ze sobą powiązane relacją klucz główny–klucz obcy.\n\nPrzykład w SQLite i PostgreSQL\nCREATE TABLE Autorzy (\n    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT\n    imie         TEXT NOT NULL,\n    nazwisko     TEXT NOT NULL\n);\n\nCREATE TABLE Ksiazki (\n    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja\n    tytul        VARCHAR(200) NOT NULL,\n    rok          INTEGER CHECK (rok &gt; 0),\n    autor_id     INTEGER,\n    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)\n);\n\nW SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.\nW PostgreSQL SERIAL lub GENERATED ALWAYS AS IDENTITY.\n\nW powyższym przykładzie tabela Autorzy przechowuje dane o autorach, a tabela Ksiazki – dane o książkach. Kolumna autor_id w tabeli Ksiazki jest kluczem obcym i wskazuje, który autor napisał daną książkę. Dzięki więzom integralności baza pilnuje, aby każda książka miała poprawnego autora. Takie powiązania są podstawą modelu relacyjnego.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#modyfikacja-i-usuwanie-tabel",
    "href": "lectures/wyklad4.html#modyfikacja-i-usuwanie-tabel",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "5️⃣ Modyfikacja i usuwanie tabel",
    "text": "5️⃣ Modyfikacja i usuwanie tabel\nALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;\n\nDROP TABLE Ksiazki;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#wstawianie-danych-dml-data-manipulation-language",
    "href": "lectures/wyklad4.html#wstawianie-danych-dml-data-manipulation-language",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "6️⃣ Wstawianie danych (DML – Data Manipulation Language)",
    "text": "6️⃣ Wstawianie danych (DML – Data Manipulation Language)\nPolecenie INSERT INTO służy do wprowadzania nowych wierszy (rekordów) do tabeli. Wartości muszą być zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.). Można dodać jeden lub wiele rekordów w jednym poleceniu. Poniżej wstawiamy kilku autorów oraz ich książki do utworzonych wcześniej tabel.\nINSERT INTO Autorzy (imie, nazwisko) VALUES\n('Adam', 'Mickiewicz'),\n('Henryk', 'Sienkiewicz'),\n('Bolesław', 'Prus');\n\nINSERT INTO Ksiazki (tytul, rok, autor_id) VALUES\n('Pan Tadeusz', 1834, 1),\n('Quo Vadis', 1896, 2),\n('Lalka', 1890, 3);\nKażdy rekord reprezentuje jedną pozycję w tabeli. Polecenie INSERT wymaga podania wartości w tej samej kolejności, w jakiej wymieniono kolumny. Jeśli nie podamy jakiejś kolumny, a ma ona zdefiniowaną wartość domyślną (DEFAULT), baza wstawi ją automatycznie. Dzięki temu możemy stopniowo budować zawartość naszej bazy danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#wybieranie-danych-select",
    "href": "lectures/wyklad4.html#wybieranie-danych-select",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "7️⃣ Wybieranie danych – SELECT",
    "text": "7️⃣ Wybieranie danych – SELECT\n\n🧩 Podstawowy SELECT\nPolecenie SELECT jest najczęściej używanym poleceniem SQL i służy do pobierania danych z tabel. Pozwala określić, które kolumny chcemy zobaczyć i z których tabel dane mają pochodzić. Jeśli użyjemy gwiazdki *, oznacza to, że wybieramy wszystkie kolumny. Poniższe zapytanie zwraca wszystkich autorów z tabeli Autorzy.\nSELECT * FROM Autorzy;\n\n\n🧩 Wybór konkretnych kolumn\nSELECT imie, nazwisko FROM Autorzy;\nWynik to pełna tabela z kolumnami autor_id, imie i nazwisko. Często jednak potrzebujemy tylko części danych, np. imienia i nazwiska – wtedy podajemy konkretne kolumny:\n\n\n🧩 Nadawanie aliasów\nSELECT imie AS \"Imię\", nazwisko AS \"Nazwisko\" FROM Autorzy;\nTakie zapytania pomagają ograniczyć ilość danych i zwiększyć czytelność wyników. Warto też nadawać aliasy (AS), które pozwalają zmienić nazwę kolumn w wynikach i nadać im bardziej opisowy wygląd.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#filtrowanie-where",
    "href": "lectures/wyklad4.html#filtrowanie-where",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "8️⃣ Filtrowanie – WHERE",
    "text": "8️⃣ Filtrowanie – WHERE\nKiedy chcemy wybrać tylko część danych, używamy klauzuli WHERE. Dzięki niej możemy ustawić warunki, jakie muszą spełniać rekordy, by pojawiły się w wyniku. To bardzo potężne narzędzie, które pozwala np. wyszukiwać książki z konkretnego roku lub autora. W poniższym przykładzie wybieramy książki wydane po roku 1850.\nSELECT * FROM Ksiazki\nWHERE rok &gt; 1850;\n\n🧠 Operatory:\nMożemy też stosować inne operatory:\n\n=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=\nLIKE ‘Q%’ → zaczyna się na Q\nIN (…)\nBETWEEN 1800 AND 1900\nIS NULL, IS NOT NULL\n\nNa przykład, aby znaleźć wszystkie książki, których tytuł zawiera literę „a”, używamy wzorca z LIKE:\nSELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';\nKlauzula WHERE pozwala więc filtrować dane na wiele sposobów, co czyni zapytania SQL bardzo elastycznymi.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#sortowanie-order-by",
    "href": "lectures/wyklad4.html#sortowanie-order-by",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "9️⃣ Sortowanie – ORDER BY",
    "text": "9️⃣ Sortowanie – ORDER BY\nPo pobraniu danych często chcemy uporządkować je według określonego kryterium. Do tego służy klauzula ORDER BY, dzięki której możemy sortować rosnąco (ASC) lub malejąco (DESC). Sortowanie działa na dowolnej kolumnie, także tych, które nie są wyświetlane w wyniku. W przykładzie poniżej porządkujemy książki według roku wydania od najnowszej do najstarszej.\nSELECT * FROM Ksiazki ORDER BY rok DESC;\nJeśli nie podamy kierunku sortowania, domyślnie jest to ASC (rosnąco). Można też sortować według kilku kolumn jednocześnie, np. najpierw po autorze, a potem po roku. Sortowanie poprawia czytelność wyników i pozwala szybciej analizować dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#grupowanie-i-agregacja-group-by-having",
    "href": "lectures/wyklad4.html#grupowanie-i-agregacja-group-by-having",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "🔟 Grupowanie i agregacja – GROUP BY, HAVING",
    "text": "🔟 Grupowanie i agregacja – GROUP BY, HAVING\nCzasem chcemy policzyć, ile danych należy do danej kategorii – np. ilu autorów napisało więcej niż jedną książkę. Do tego służy GROUP BY, które grupuje dane według wybranej kolumny. W połączeniu z funkcjami agregującymi, takimi jak COUNT(), AVG(), SUM(), MIN() czy MAX(), daje duże możliwości analizy. Klauzula HAVING pozwala odfiltrować grupy po obliczeniu agregacji.\nSELECT autor_id, COUNT(*) AS liczba_ksiazek\nFROM Ksiazki\nGROUP BY autor_id\nHAVING COUNT(*) &gt; 1;\nTo zapytanie zwraca tylko tych autorów, którzy mają więcej niż jedną książkę. Różnica między WHERE a HAVING polega na tym, że WHERE filtruje pojedyncze wiersze przed grupowaniem, a HAVING filtruje całe grupy po agregacji. Wyniki można potem łączyć z innymi tabelami, by uzyskać bardziej opisowe raporty.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#łączenie-tabel-join",
    "href": "lectures/wyklad4.html#łączenie-tabel-join",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "1️⃣1️⃣ Łączenie tabel – JOIN",
    "text": "1️⃣1️⃣ Łączenie tabel – JOIN\nW relacyjnym modelu danych informacje są rozproszone w różnych tabelach, które łączy się przy pomocy kluczy obcych. Polecenie JOIN pozwala zestawić dane z kilku tabel na podstawie wspólnej kolumny. Najczęściej używany jest INNER JOIN, który zwraca tylko rekordy, dla których istnieje dopasowanie w obu tabelach. W przykładzie łączymy tabelę Ksiazki z Autorzy, aby zobaczyć tytuł książki i jej autora.\n\n🔹 INNER JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\nWynikiem będzie lista książek wraz z imieniem i nazwiskiem autora. Jeśli chcemy, aby w wynikach pojawiły się także książki bez autora (lub autorzy bez książek), używamy odpowiednio LEFT JOIN lub RIGHT JOIN. Łączenie tabel to fundament relacyjnych baz danych – dzięki niemu dane są spójne i nie trzeba ich powielać.\n\n\n🔹 LEFT JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nLEFT JOIN Autorzy a ON k.autor_id = a.autor_id;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#aktualizacja-i-usuwanie-danych",
    "href": "lectures/wyklad4.html#aktualizacja-i-usuwanie-danych",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "1️⃣2️⃣ Aktualizacja i usuwanie danych",
    "text": "1️⃣2️⃣ Aktualizacja i usuwanie danych\nPolecenie UPDATE pozwala modyfikować dane już istniejące w tabeli. Zawsze należy używać klauzuli WHERE, aby zmiana nie objęła wszystkich rekordów. Z kolei DELETE służy do usuwania rekordów – również z warunkiem, by nie usunąć wszystkiego przez pomyłkę. Przykład poniżej pokazuje, jak zmienić rok wydania książki i usunąć starsze pozycje.\nUPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';\n\nDELETE FROM Ksiazki WHERE rok &lt; 1850;\nUPDATE pozwala też aktualizować wiele kolumn naraz, a nawet wykonywać obliczenia. Z kolei DELETE usuwa rekordy z tabeli, ale nie zmienia struktury bazy. Warto zawsze testować warunek WHERE wcześniej przy pomocy SELECT, by uniknąć niechcianych usunięć.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#podsumowanie",
    "href": "lectures/wyklad4.html#podsumowanie",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "Podsumowanie",
    "text": "Podsumowanie\nSQL jest językiem deklaratywnym – opisujemy co chcemy uzyskać, a nie jak to zrobić. Dzięki temu użytkownik nie musi znać szczegółów działania bazy danych, wystarczy, że opisze warunki i strukturę zapytania. Poznane dziś polecenia (CREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY) to fundament pracy z bazami danych. Opanowanie ich pozwala budować i analizować nawet bardzo złożone systemy informacyjne.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "",
    "text": "Celem dzisiejszego wykładu jest pokazanie, jak przejść od koncepcyjnego modelu ERD (Entity–Relationship Diagram), który opisuje co chcemy przechowywać, do modelu relacyjnego, który mówi jak te dane będą fizycznie zorganizowane w tabelach.\n👉 Innymi słowy — dziś „przekładamy” logikę świata rzeczywistego na język tabel, kolumn i kluczy.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#cel-wykładu",
    "href": "lectures/wyklad3.html#cel-wykładu",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "",
    "text": "Celem dzisiejszego wykładu jest pokazanie, jak przejść od koncepcyjnego modelu ERD (Entity–Relationship Diagram), który opisuje co chcemy przechowywać, do modelu relacyjnego, który mówi jak te dane będą fizycznie zorganizowane w tabelach.\n👉 Innymi słowy — dziś „przekładamy” logikę świata rzeczywistego na język tabel, kolumn i kluczy.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#wprowadzenie",
    "href": "lectures/wyklad3.html#wprowadzenie",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "1. Wprowadzenie",
    "text": "1. Wprowadzenie\nZacznijmy od prostego pytania do grupy:\n„Czy narysowany diagram ERD to już baza danych?”\nWiększość studentów odpowie, że nie — i mają rację. ERD to tylko opis pojęć i powiązań między nimi, coś w rodzaju mapy koncepcyjnej. Dopiero model relacyjny pozwala tę mapę zaimplementować w systemie DBMS – czyli stworzyć konkretne tabele, relacje i klucze.\n\nPrzykład porównawczy:\nERD to jak plan architektoniczny domu.\nModel relacyjny to już projekt budowlany z wymiarami i materiałami.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#przypomnienie-podstawowych-pojęć",
    "href": "lectures/wyklad3.html#przypomnienie-podstawowych-pojęć",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Przypomnienie podstawowych pojęć",
    "text": "Przypomnienie podstawowych pojęć\nZanim przejdziemy do reguł, powtórzmy szybko:\n\nEncja – obiekt, o którym przechowujemy dane (np. Student, Kurs, Produkt).\nAtrybut – właściwość tego obiektu (np. imię, nazwisko, cena).\nZwiązek (relationship) – powiązanie między encjami (np. Student zapisuje się na Kurs).\nKrotka (tuple) – pojedynczy wiersz tabeli (np. dane jednego studenta).\nDomena – dopuszczalne wartości dla atrybutu (np. liczby od 1 do 5 dla oceny).\n\n👉 Wszystkie te pojęcia znajdą swoje odpowiedniki w modelu relacyjnym.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#proces-mapowania-transformacji",
    "href": "lectures/wyklad3.html#proces-mapowania-transformacji",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Proces mapowania (transformacji)",
    "text": "Proces mapowania (transformacji)\nTeraz przechodzimy do sedna: jak zamienić ERD w zestaw tabel.\nMożna to potraktować jak przepis: krok po kroku.\n\n🔹 1. Encje \\(\\to\\) Tabele\nKażda encja z modelu ER staje się tabelą w modelu relacyjnym.\nKażdy atrybut encji staje się kolumną.\nWyobraźmy sobie, że prostokąty z diagramu ER zamieniamy w tabele SQL.\nWszystkie elipsy (atrybuty) stają się kolumnami.\nPrzykład:\n\nEncja: STUDENT (NrIndeksu, Imię, Nazwisko, RokStudiow)\n\nRelacja: STUDENT(NrIndeksu, Imię, Nazwisko, RokStudiow)\n\n\n🔹 2. Atrybuty złożone\nAtrybut złożony to taki, który sam składa się z kilku części.\nW modelu relacyjnym nie ma takiej konstrukcji, więc trzeba go rozbić.\nPrzykład:\nAdres = (Ulica, KodPocztowy, Miasto)\n„Zauważmy, że dzięki temu możemy np. wyszukiwać po samym mieście, co nie byłoby możliwe, gdyby cały adres był jednym polem tekstowym.”\n\n\n🔹 3. Atrybuty wielowartościowe\nAtrybut wielowartościowy to taki, który może mieć więcej niż jedną wartość dla jednej encji.\nPrzykład: Student może mieć wiele adresów e-mail.\nW modelu relacyjnym nie możemy trzymać wielu wartości w jednej kolumnie, więc: ➡️ Tworzymy osobną tabelę.\nEMAIL(NrIndeksu, Email)\n\nKlucz główny: (NrIndeksu, Email)\nNrIndeksu to klucz obcy do tabeli STUDENT.\n\n„To moment, w którym ERD zaczyna się rozrastać — z jednej encji robią się dwie tabele.\nAle dzięki temu baza pozostaje spójna i czytelna.”\n\n\n🔹 4. Związki 1:1\nZwiązek „jeden do jednego” oznacza, że każdemu rekordowi z jednej tabeli odpowiada najwyżej jeden rekord z drugiej.\nPrzykład:\n\nKażda osoba ma dokładnie jeden paszport.\n\nOSOBA(PESEL, Imię, Nazwisko)\nPASZPORT(NrPaszportu, DataWażności, PESEL)\nDodajemy PESEL jako klucz obcy w tabeli PASZPORT.\n„Jeśli obie strony są naprawdę w relacji 1:1, można też rozważyć połączenie tych tabel — ale zwykle zostawia się je osobno, gdy przechowują różne grupy informacji\n\n\n🔹 5. Związki 1:N\nTo najczęstszy przypadek w praktyce.\nPrzykład: Jeden wykładowca prowadzi wiele kursów.\nWYKŁADOWCA(IDWykładowcy, Imię, Nazwisko)\nKURS(IDKursu, Nazwa, IDWykładowcy)\nIDWykładowcy w tabeli KURS jest kluczem obcym.\n„Pamiętajcie: klucz obcy zawsze dodajemy po stronie N, czyli po tej, gdzie może być więcej rekordów.”\n\n\n🔹 6. Związki N:M\nTo przypadek „wiele do wielu” — np. student może uczestniczyć w wielu kursach, a każdy kurs ma wielu studentów.\nW tym wypadku nie da się dodać klucza obcego do jednej z tabel, więc tworzymy tabelę pośredniczącą.\nSTUDENT(NrIndeksu, Imię, Nazwisko)\nKURS(IDKursu, Nazwa)\nZAPIS(NrIndeksu, IDKursu, DataZapisu)\n„Ta trzecia tabela to tak naprawdę odwzorowanie związku. Dzięki niej możemy np. zapisać dodatkowe informacje o relacji — np. datę zapisania się na kurs.”\n\n\n5. Jak projektować dobre tabele?\nKiedy masz już relacje, czas je zdefiniować w SQL.\nTu warto podkreślić kilka zasad:\n\nCzytelne nazwy (jednolite, najlepiej w liczbie pojedynczej).\nTypy danych dopasowane do zawartości.\nOgraniczenia (constraints):\nPRIMARY KEY – jednoznaczna identyfikacja,\nFOREIGN KEY – zapewnia spójność,\nNOT NULL, UNIQUE, CHECK – wymuszają poprawność danych.\n\nPrzykład SQL:\nCREATE TABLE STUDENT (\n  NrIndeksu CHAR(6) PRIMARY KEY,\n  Imie VARCHAR(30) NOT NULL,\n  Nazwisko VARCHAR(40) NOT NULL\n);\n„To dopiero teraz jest konkretna implementacja — coś, co można utworzyć w PostgreSQL, MySQL czy Oracle.\nAle zanim napiszemy SQL, zawsze powinniśmy mieć dobrze przemyślany model relacyjny.”\n\n\n6. Ćwiczenie praktyczne\n\nZadanie: Zaprojektuj schemat relacyjny dla firmy, w której pracownicy realizują projekty. Każdy projekt ma wielu pracowników, a każdy pracownik może uczestniczyć w wielu projektach. Dodatkowo pamiętamy od kiedy pracownik uczestniczy w projekcie.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#podsumowanie",
    "href": "lectures/wyklad3.html#podsumowanie",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Podsumowanie:",
    "text": "Podsumowanie:\n„Dziś nauczyliśmy się tłumaczyć język analityków (ERD) na język baz danych (model relacyjny).”\n\nEncje → tabele\nAtrybuty → kolumny\nZwiązki → klucze obce lub tabele pośrednie\nAtrybuty złożone → rozbijamy\nAtrybuty wielowartościowe → osobne tabele\n\n👉 W kolejnym wykładzie przejdziemy do normalizacji, czyli porządkowania tabel, by unikać błędów i redundancji.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: zimowy",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#projektowanie-relacyjnych-baz-danych",
    "href": "index.html#projektowanie-relacyjnych-baz-danych",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: zimowy",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogólne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykład WEL21EA1S0:\n\n\n02.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n06.10.2025 Poniedziałek 8.00 - 9.30. b 61 s 104\n\n\n09.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n16.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n21.10.2025 Wtorek 8.00 - 9.35 b 61 s 104\n27.10.2025 Poniedziałek 9.50 - 11.25 b 61 s 104\n30.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n\nLaboratorium:",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "Ben Forta - SQL w mnieniu oka. Helion. 2020.\nThomas Nield - Pierwsze kroki z SQL. Praktyczne podejście dla początkujących. O’Reilly: 2016"
  },
  {
    "objectID": "ksiazki.html#książki",
    "href": "ksiazki.html#książki",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "Ben Forta - SQL w mnieniu oka. Helion. 2020.\nThomas Nield - Pierwsze kroki z SQL. Praktyczne podejście dla początkujących. O’Reilly: 2016"
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "",
    "text": "Każdy projekt bazy danych zaczyna się od zrozumienia czego oczekuje użytkownik. Bez tego łatwo stworzyć system, który jest poprawny technicznie, ale bezużyteczny w praktyce.\nPrzykład 1 – biblioteka\nBiblioteka chce mieć system, który przechowuje dane o:\n\nksiążkach (tytuł, autor, rok wydania, ISBN),\nczytelnikach (imię, nazwisko, numer karty bibliotecznej),\nwypożyczeniach (jaka książka, który czytelnik, kiedy wypożyczona i kiedy oddana).\n\nPrzykład 2 – sklep internetowy\nSklep potrzebuje informacji o:\n\nklientach (imię, adres, e-mail),\nproduktach (nazwa, cena, kategoria),\nzamówieniach (który klient, jakie produkty, kiedy złożono, status zamówienia).\n\n👉 Zwróć uwagę:\n\nw bibliotece najważniejszy jest związek wypożyczeń,\nw sklepie – związek zamówień.\n\nJuż na tym etapie widać, że kluczowe są powiązania, a nie tylko same dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#analiza-wymagań-użytkownika",
    "href": "lectures/wyklad2.html#analiza-wymagań-użytkownika",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "",
    "text": "Każdy projekt bazy danych zaczyna się od zrozumienia czego oczekuje użytkownik. Bez tego łatwo stworzyć system, który jest poprawny technicznie, ale bezużyteczny w praktyce.\nPrzykład 1 – biblioteka\nBiblioteka chce mieć system, który przechowuje dane o:\n\nksiążkach (tytuł, autor, rok wydania, ISBN),\nczytelnikach (imię, nazwisko, numer karty bibliotecznej),\nwypożyczeniach (jaka książka, który czytelnik, kiedy wypożyczona i kiedy oddana).\n\nPrzykład 2 – sklep internetowy\nSklep potrzebuje informacji o:\n\nklientach (imię, adres, e-mail),\nproduktach (nazwa, cena, kategoria),\nzamówieniach (który klient, jakie produkty, kiedy złożono, status zamówienia).\n\n👉 Zwróć uwagę:\n\nw bibliotece najważniejszy jest związek wypożyczeń,\nw sklepie – związek zamówień.\n\nJuż na tym etapie widać, że kluczowe są powiązania, a nie tylko same dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#diagramy-encjazwiązek",
    "href": "lectures/wyklad2.html#diagramy-encjazwiązek",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Diagramy encja–związek",
    "text": "Diagramy encja–związek\nModel ERD (Entity–Relationship Diagram) pozwala w przejrzysty sposób przedstawić jakie obiekty istnieją w systemie i jak są ze sobą powiązane.\n\nEncje rysujemy jako prostokąty.\nPrzykład: „Student”, „Książka”, „Zamówienie”.\nAtrybuty zapisujemy jako elipsy i łączymy z encją.\n„Student” → Imię, Nazwisko, NrIndeksu.\nZwiązki przedstawiamy jako romby.\n„Student” \\(\\to\\) „Wypożycza” \\(\\to\\) „Książka”.\n\nPrzykład wizualny do opowiedzenia:\n\nWyobraźcie sobie trzy prostokąty: „Student”, „Książka” i „Bibliotekarz”.\nŁączymy je rombem „Wypożycza”.\nDodajemy atrybuty: do studenta „NrIndeksu”, do książki „ISBN”, a do związku „Data wypożyczenia”.\n\n👉 Dzięki temu widzimy nie tylko obiekty, ale i relacje między nimi.\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#typy-związków",
    "href": "lectures/wyklad2.html#typy-związków",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Typy związków",
    "text": "Typy związków\nZwiązek 1:1 (jeden do jednego)\n\nKażdy obiekt jednej encji odpowiada najwyżej jednemu obiektowi drugiej encji.\nPrzykład: każdy człowiek ma jedno unikalne PESEL.\n\nZwiązek 1:N (jeden do wielu)\n\nJeden obiekt encji A może być powiązany z wieloma obiektami encji B, ale nie odwrotnie.\nPrzykład: jeden wykładowca prowadzi wiele kursów, ale każdy kurs ma dokładnie jednego prowadzącego.\n\nZwiązek N:M (wiele do wielu)\n\nJeden obiekt encji A może być powiązany z wieloma obiektami encji B i odwrotnie.\nPrzykład: studenci zapisują się na wiele kursów, a każdy kurs realizowany jest przez wielu studentów.\n\nMini-case: kino\n\nEncje: „Film”, „Widz”, „Seans”.\nWidzowie mogą oglądać wiele filmów, a każdy film może być oglądany przez wielu widzów. To klasyczne N:M.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#atrybuty-proste-złożone-wielowartościowe",
    "href": "lectures/wyklad2.html#atrybuty-proste-złożone-wielowartościowe",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Atrybuty proste, złożone, wielowartościowe",
    "text": "Atrybuty proste, złożone, wielowartościowe\n\nAtrybut prosty – nie da się go podzielić: „Data urodzenia”, „PESEL”.\nAtrybut złożony – składa się z mniejszych: „Adres” → „Ulica”, „Kod pocztowy”, „Miasto”.\nAtrybut wielowartościowy – może mieć wiele wartości dla jednej encji: „Numery telefonów” dla jednego studenta.\n\n👉 To ważne, bo w późniejszym projektowaniu relacyjnym atrybut wielowartościowy często trzeba przekształcić w oddzielną tabelę.\nPrzykład:\n\nStudent może mieć wiele adresów e-mail.\nW modelu ER narysujemy atrybut „Email” jako elipsę podwójną.\nW modelu relacyjnym – stworzymy tabelę „AdresyEmail” powiązaną z tabelą „Studenci”.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#przykłady-całościowe",
    "href": "lectures/wyklad2.html#przykłady-całościowe",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Przykłady całościowe",
    "text": "Przykłady całościowe\nNa koniec możemy omówić kilka kompletnych mini-systemów, żeby pokazać różne rodzaje encji, związków i atrybutów.\nPrzykład A – System rezerwacji hotelu\n\nEncje: „Pokój”, „Gość”, „Rezerwacja”.\nZwiązki: Gość „rezerwuje” Pokój.\nAtrybuty: Rezerwacja ma datę początku, datę końca i status.\n\nPrzykład B – Uczelnia\n\nEncje: „Student”, „Kurs”, „Wykładowca”.\nZwiązki: Student „zapisuje się na” Kurs, Wykładowca „prowadzi” Kurs.\nAtrybuty: Student – imię, nazwisko, nr indeksu. Kurs – nazwa, punktacja ECTS.\n\nPrzykład C – Sklep internetowy\n\nEncje: „Klient”, „Produkt”, „Zamówienie”.\nZwiązki: Klient „składa” Zamówienie, Zamówienie „zawiera” Produkt.\nAtrybuty: Produkt – cena, opis; Zamówienie – data, status.\n\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#podsumowanie",
    "href": "lectures/wyklad2.html#podsumowanie",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Podsumowanie",
    "text": "Podsumowanie\n\nProjektowanie bazy danych zaczynamy od analizy wymagań użytkownika.\nModel ER pozwala uporządkować wiedzę w postaci encje–atrybuty–związki.\nWyróżniamy związki 1:1, 1:N, N:M oraz atrybuty proste, złożone i wielowartościowe.\nDiagram ERD to narzędzie komunikacji – łączy świat użytkownika ze światem projektanta i programisty.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Celem wykładu jest zapoznanie się z podstawami relacyjnych baz danych — ich historią, pojęciami, architekturą, strukturą danych oraz zasadami integralności. Po tym wykładzie student powinien rozumieć, czym jest baza danych, jak działa DBMS, co oznacza model relacyjny oraz jakie są klucze i reguły spójności danych.\n\n\n\nBazy danych nie są wynalazkiem XXI wieku — ich początki sięgają lat 60. XX wieku, gdy organizacje zaczęły gromadzić coraz większe ilości danych.\n\n\nPierwsze systemy przechowywały dane w plikach na dyskach. Choć były proste, miały poważne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudność w utrzymaniu spójności\nBrak uniwersalnych narzędzi do wyszukiwania\n\n💡 Zadanie: Na jakich innych obiektach, oprócz plików, można pracować w systemach operacyjnych?\n\n\n\nW latach 60. i 70. pojawiły się pierwsze systemy zarządzania bazami danych (DBMS). Zapewniały:\n\ncentralną kontrolę danych,\nintegralność i bezpieczeństwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n\nWczesne systemy wykorzystywały struktury drzewiaste lub grafowe. Były skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n\nW 1970 roku Edgar F. Codd zaproponował model relacyjny danych, w którym:\n\ndane są przechowywane w tabelach (relacjach),\nkażda tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystość,\nelastyczność (łatwo dodawać nowe tabele),\nbezpieczeństwo i spójność danych.\n\n\n\n\nWraz z rozwojem modelu relacyjnego powstał SQL (Structured Query Language) – język do tworzenia, modyfikowania i pobierania danych.\nDziś SQL jest fundamentem większości systemów: od aplikacji biurowych po duże systemy korporacyjne. Nawet współczesne rozwiązania NoSQL często nawiązują do idei relacyjnych.\n\n\n\n\n\n\n\nDane – surowe fakty, liczby, teksty, które same w sobie niewiele znaczą. 👉 np. 25, Warszawa, 12345\nInformacja – dane zinterpretowane i zorganizowane w kontekście. 👉 np. „25 klientów z Warszawy złożyło zamówienie w ostatnim tygodniu”.\n\nDane to materiał, informacja to znaczenie.\n\n\n\nZorganizowany zbiór danych umożliwiający ich łatwe przeszukiwanie, aktualizację i analizę.\nCechy:\n\nStrukturalność\nCentralizacja\nTrwałość i bezpieczeństwo\n\nPrzykłady:\n\nLista kontaktów w telefonie\nSystem rezerwacji hotelowej\nSklep internetowy\n\nTermin ,,baza danych’’ uzywany jest na wiele róznych sposobów, ale na wykładzie baza danych oznacza zbiór danych przechowywanych w pewien zorganizowany sposób. Najprościej wyobrazić sobie bazę danych jako szafkę na dokumenty. Jest to miejsce umozliwiające przechowywanie informacji, niezaleznie od ich typu i sposobu organizacji.\n\n\n\nBardzo często uzywamy terminu “baza danych” do określenia oprogramowania bazy danych, którego uzywamy. Takie podejście jest błędne i powoduje wiele nieporozumień. Oprogramowanie BD nazywane jest poprawnie sustemem zarządzania bazą danych (SZBD) lub (DBMS - Database Management System). Sama baza danych jest pojemnikiem tworzonym i modyfikowanym przez SZBD. Konkretna postać BD zienia się w zalezności od zastosowań.\nOprogramowanie do tworzenia, modyfikowania i przetwarzania baz danych.\nFunkcje DBMS:\n\nTworzenie i modyfikacja schematów\nOperacje CRUD (Create, Read, Update, Delete)\nZarządzanie bezpieczeństwem i uprawnieniami\nOptymalizacja zapytań\n\nPrzykłady: MySQL, PostgreSQL, Oracle, SQL Server, SQLite.\n\n\n\n\nSystemy baz danych są zorganizowane według poziomów abstrakcji, co pozwala oddzielić sposób przechowywania danych od ich widoku dla użytkownika.\n\n\n\nPoziom fizyczny (wewnętrzny)\n\n\nopisuje sposób przechowywania danych (pliki, indeksy, struktury).\n\n\nPoziom logiczny (pośredni)\n\n\nopisuje strukturę danych (tabele, relacje, typy danych).\n\n\nPoziom zewnętrzny (widok użytkownika)\n\n\npokazuje dane z perspektywy użytkownika lub aplikacji.\n\nZmiany w jednym poziomie nie wymagają zmian w pozostałych — to tzw. niezależność danych.\n\n\n\nFormalny model trójpoziomowy:\n\npoziom wewnętrzny – fizyczne przechowywanie danych,\npoziom pojęciowy – logiczna struktura bazy,\npoziom zewnętrzny – widoki użytkowników.\n\nZalety:\n\nizolacja danych,\nbezpieczeństwo,\nelastyczność i skalowalność.\n\n\n\n\n\n\n\nTABELA to:\n\nZbiór danych o tej samej strukturze.\nUporządkowana lista zawierająca dane określonego typu\n\nKażda tabela opisuje jeden typ obiektów (np. Studenci, Kursy).\nNajwazniejsze, ze tabela przechowuje dane jednego typu. W jednej tabeli nie pojawi się jednocześnie lista kontaktów i lista zamówień. &gt; Uwaga: Technicznie taka tabela jest mozliwa do realizacji ale pobieranie konkretnych elementów &gt; byłoby znacznie utrudnione.\n\nUwaga: Kazda tabela posiada nazwę pozwalającą jednoznacznie ją zidentyfikować. Nazwa zawsze jest unikalna - zadna inna tabela nie moze mieć takiej samej nazwy.\n\n\n\n\nPojedynczy rekord w tabeli (np. dane jednego studenta).\n\n\n\nWłaściwość obiektu – ma nazwę i typ danych (np. Imię, Nazwisko, NrIndeksu).\n\n\n\nZbiór dopuszczalnych wartości atrybutu (np. liczby całkowite, ciągi znaków do 50 znaków).\n\n\n\n\nSchemat relacji – struktura tabeli (nazwy kolumn, typy).\nInstancja relacji – aktualna zawartość tabeli.\n\n\n\n\n\n\n\n\njednoznacznie identyfikuje każdy rekord,\nnie może mieć wartości NULL.\n\nPrzykład: NrIndeksu w tabeli Studenci.\n\n\n\n\nkażdy atrybut (lub ich kombinacja), który mógłby być kluczem głównym. Przykład: NrIndeksu i PESEL – wybieramy jeden jako główny.\n\n\n\n\n\natrybut wskazujący na klucz główny w innej tabeli. Przykład: NrIndeksu w tabeli Oceny odnosi się do Studenci.\n\n\n\n\n\nIntegralność encji – każda krotka musi być jednoznacznie identyfikowana.\nIntegralność referencyjna – wartości kluczy obcych muszą istnieć w tabelach nadrzędnych.\nIntegralność dziedzinowa – wartości atrybutów muszą mieścić się w swoich domenach.\n\n\n\n\n\n\n\n\nKto zaproponował model relacyjny danych?\n\n\nDonald Knuth\nEdgar F. Codd\nBill Gates\nCharles Bachman\n\n\nCo opisuje poziom logiczny w architekturze ANSI/SPARC?\n\n\nSposób fizycznego zapisu danych\nWidok danych przez użytkownika\nStrukturę danych i relac\n\n✏️ Pytania otwarte / opisowe\n\nWyjaśnij różnicę między danymi a informacją.\nWymień i krótko opisz trzy poziomy abstrakcji w modelu ANSI/SPARC.\nCo to jest klucz główny i jakie są jego cechy?\nPodaj przykład relacji i wskaż w niej krotki oraz atrybuty.\nDlaczego model relacyjny okazał się przełomem w historii baz danych?\nJakie są trzy podstawowe zasady integralności danych?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#wprowadzenie-i-cele-wykładu",
    "href": "lectures/wyklad1.html#wprowadzenie-i-cele-wykładu",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Celem wykładu jest zapoznanie się z podstawami relacyjnych baz danych — ich historią, pojęciami, architekturą, strukturą danych oraz zasadami integralności. Po tym wykładzie student powinien rozumieć, czym jest baza danych, jak działa DBMS, co oznacza model relacyjny oraz jakie są klucze i reguły spójności danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "href": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Bazy danych nie są wynalazkiem XXI wieku — ich początki sięgają lat 60. XX wieku, gdy organizacje zaczęły gromadzić coraz większe ilości danych.\n\n\nPierwsze systemy przechowywały dane w plikach na dyskach. Choć były proste, miały poważne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudność w utrzymaniu spójności\nBrak uniwersalnych narzędzi do wyszukiwania\n\n💡 Zadanie: Na jakich innych obiektach, oprócz plików, można pracować w systemach operacyjnych?\n\n\n\nW latach 60. i 70. pojawiły się pierwsze systemy zarządzania bazami danych (DBMS). Zapewniały:\n\ncentralną kontrolę danych,\nintegralność i bezpieczeństwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n\nWczesne systemy wykorzystywały struktury drzewiaste lub grafowe. Były skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n\nW 1970 roku Edgar F. Codd zaproponował model relacyjny danych, w którym:\n\ndane są przechowywane w tabelach (relacjach),\nkażda tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystość,\nelastyczność (łatwo dodawać nowe tabele),\nbezpieczeństwo i spójność danych.\n\n\n\n\nWraz z rozwojem modelu relacyjnego powstał SQL (Structured Query Language) – język do tworzenia, modyfikowania i pobierania danych.\nDziś SQL jest fundamentem większości systemów: od aplikacji biurowych po duże systemy korporacyjne. Nawet współczesne rozwiązania NoSQL często nawiązują do idei relacyjnych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "href": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Dane – surowe fakty, liczby, teksty, które same w sobie niewiele znaczą. 👉 np. 25, Warszawa, 12345\nInformacja – dane zinterpretowane i zorganizowane w kontekście. 👉 np. „25 klientów z Warszawy złożyło zamówienie w ostatnim tygodniu”.\n\nDane to materiał, informacja to znaczenie.\n\n\n\nZorganizowany zbiór danych umożliwiający ich łatwe przeszukiwanie, aktualizację i analizę.\nCechy:\n\nStrukturalność\nCentralizacja\nTrwałość i bezpieczeństwo\n\nPrzykłady:\n\nLista kontaktów w telefonie\nSystem rezerwacji hotelowej\nSklep internetowy\n\nTermin ,,baza danych’’ uzywany jest na wiele róznych sposobów, ale na wykładzie baza danych oznacza zbiór danych przechowywanych w pewien zorganizowany sposób. Najprościej wyobrazić sobie bazę danych jako szafkę na dokumenty. Jest to miejsce umozliwiające przechowywanie informacji, niezaleznie od ich typu i sposobu organizacji.\n\n\n\nBardzo często uzywamy terminu “baza danych” do określenia oprogramowania bazy danych, którego uzywamy. Takie podejście jest błędne i powoduje wiele nieporozumień. Oprogramowanie BD nazywane jest poprawnie sustemem zarządzania bazą danych (SZBD) lub (DBMS - Database Management System). Sama baza danych jest pojemnikiem tworzonym i modyfikowanym przez SZBD. Konkretna postać BD zienia się w zalezności od zastosowań.\nOprogramowanie do tworzenia, modyfikowania i przetwarzania baz danych.\nFunkcje DBMS:\n\nTworzenie i modyfikacja schematów\nOperacje CRUD (Create, Read, Update, Delete)\nZarządzanie bezpieczeństwem i uprawnieniami\nOptymalizacja zapytań\n\nPrzykłady: MySQL, PostgreSQL, Oracle, SQL Server, SQLite.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#architektura-systemów-baz-danych",
    "href": "lectures/wyklad1.html#architektura-systemów-baz-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Systemy baz danych są zorganizowane według poziomów abstrakcji, co pozwala oddzielić sposób przechowywania danych od ich widoku dla użytkownika.\n\n\n\nPoziom fizyczny (wewnętrzny)\n\n\nopisuje sposób przechowywania danych (pliki, indeksy, struktury).\n\n\nPoziom logiczny (pośredni)\n\n\nopisuje strukturę danych (tabele, relacje, typy danych).\n\n\nPoziom zewnętrzny (widok użytkownika)\n\n\npokazuje dane z perspektywy użytkownika lub aplikacji.\n\nZmiany w jednym poziomie nie wymagają zmian w pozostałych — to tzw. niezależność danych.\n\n\n\nFormalny model trójpoziomowy:\n\npoziom wewnętrzny – fizyczne przechowywanie danych,\npoziom pojęciowy – logiczna struktura bazy,\npoziom zewnętrzny – widoki użytkowników.\n\nZalety:\n\nizolacja danych,\nbezpieczeństwo,\nelastyczność i skalowalność.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#model-relacyjny",
    "href": "lectures/wyklad1.html#model-relacyjny",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "TABELA to:\n\nZbiór danych o tej samej strukturze.\nUporządkowana lista zawierająca dane określonego typu\n\nKażda tabela opisuje jeden typ obiektów (np. Studenci, Kursy).\nNajwazniejsze, ze tabela przechowuje dane jednego typu. W jednej tabeli nie pojawi się jednocześnie lista kontaktów i lista zamówień. &gt; Uwaga: Technicznie taka tabela jest mozliwa do realizacji ale pobieranie konkretnych elementów &gt; byłoby znacznie utrudnione.\n\nUwaga: Kazda tabela posiada nazwę pozwalającą jednoznacznie ją zidentyfikować. Nazwa zawsze jest unikalna - zadna inna tabela nie moze mieć takiej samej nazwy.\n\n\n\n\nPojedynczy rekord w tabeli (np. dane jednego studenta).\n\n\n\nWłaściwość obiektu – ma nazwę i typ danych (np. Imię, Nazwisko, NrIndeksu).\n\n\n\nZbiór dopuszczalnych wartości atrybutu (np. liczby całkowite, ciągi znaków do 50 znaków).\n\n\n\n\nSchemat relacji – struktura tabeli (nazwy kolumn, typy).\nInstancja relacji – aktualna zawartość tabeli.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#klucze-i-integralność-danych",
    "href": "lectures/wyklad1.html#klucze-i-integralność-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "jednoznacznie identyfikuje każdy rekord,\nnie może mieć wartości NULL.\n\nPrzykład: NrIndeksu w tabeli Studenci.\n\n\n\n\nkażdy atrybut (lub ich kombinacja), który mógłby być kluczem głównym. Przykład: NrIndeksu i PESEL – wybieramy jeden jako główny.\n\n\n\n\n\natrybut wskazujący na klucz główny w innej tabeli. Przykład: NrIndeksu w tabeli Oceny odnosi się do Studenci.\n\n\n\n\n\nIntegralność encji – każda krotka musi być jednoznacznie identyfikowana.\nIntegralność referencyjna – wartości kluczy obcych muszą istnieć w tabelach nadrzędnych.\nIntegralność dziedzinowa – wartości atrybutów muszą mieścić się w swoich domenach.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#zestaw-pytań-testowych",
    "href": "lectures/wyklad1.html#zestaw-pytań-testowych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Kto zaproponował model relacyjny danych?\n\n\nDonald Knuth\nEdgar F. Codd\nBill Gates\nCharles Bachman\n\n\nCo opisuje poziom logiczny w architekturze ANSI/SPARC?\n\n\nSposób fizycznego zapisu danych\nWidok danych przez użytkownika\nStrukturę danych i relac\n\n✏️ Pytania otwarte / opisowe\n\nWyjaśnij różnicę między danymi a informacją.\nWymień i krótko opisz trzy poziomy abstrakcji w modelu ANSI/SPARC.\nCo to jest klucz główny i jakie są jego cechy?\nPodaj przykład relacji i wskaż w niej krotki oraz atrybuty.\nDlaczego model relacyjny okazał się przełomem w historii baz danych?\nJakie są trzy podstawowe zasady integralności danych?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html",
    "href": "lectures/wyklad5.html",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "",
    "text": "Złe zaprojektowanie struktury bazy danych prowadzi do wielu problemów:\n\n\nTo powielanie tych samych informacji w różnych miejscach bazy.\nPrzykład: jeśli w każdej tabeli z zamówieniami przechowujemy pełne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordów.\n\n\n\nBłędy i niekonsekwencje wynikające z nadmiarowej struktury danych.\n\nAnomalia aktualizacji – zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykładowcy w kilku wierszach tabeli.\nAnomalia wstawiania – brak możliwości dodania danych bez istnienia innych.\nNp. nie można dodać nowego kursu, dopóki nie zapisze się na niego student.\nAnomalia usuwania – usunięcie rekordu powoduje utratę innych informacji.\nNp. usunięcie ostatniego studenta z kursu powoduje utratę danych o samym kursie.\n\n👉 Wniosek: błędy projektowe utrudniają utrzymanie spójności danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#problemy-złego-projektu-bazy-danych",
    "href": "lectures/wyklad5.html#problemy-złego-projektu-bazy-danych",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "",
    "text": "Złe zaprojektowanie struktury bazy danych prowadzi do wielu problemów:\n\n\nTo powielanie tych samych informacji w różnych miejscach bazy.\nPrzykład: jeśli w każdej tabeli z zamówieniami przechowujemy pełne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordów.\n\n\n\nBłędy i niekonsekwencje wynikające z nadmiarowej struktury danych.\n\nAnomalia aktualizacji – zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykładowcy w kilku wierszach tabeli.\nAnomalia wstawiania – brak możliwości dodania danych bez istnienia innych.\nNp. nie można dodać nowego kursu, dopóki nie zapisze się na niego student.\nAnomalia usuwania – usunięcie rekordu powoduje utratę innych informacji.\nNp. usunięcie ostatniego studenta z kursu powoduje utratę danych o samym kursie.\n\n👉 Wniosek: błędy projektowe utrudniają utrzymanie spójności danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#zależności-funkcjonalne",
    "href": "lectures/wyklad5.html#zależności-funkcjonalne",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "2. Zależności funkcjonalne",
    "text": "2. Zależności funkcjonalne\n\n🔹 Definicja\nZależność funkcjonalna (ang. functional dependency) opisuje relację między atrybutami w tabeli.\nMówimy, że atrybut B jest funkcyjnie zależny od atrybutu A (zapis:\nA → B), jeśli każdej wartości A odpowiada dokładnie jedna wartość B.\n\n\n🔹 Przykłady\n\nNrIndeksu → Imię, Nazwisko, Kierunek\n(każdy numer indeksu jednoznacznie identyfikuje studenta)\nKurs → Sala, Prowadzący\n(dany kurs odbywa się zawsze w tej samej sali, prowadzony przez tę samą osobę)\n\n\n\n🔹 Klucze\n\nKlucz główny (primary key) – jednoznacznie identyfikuje wiersz tabeli.\n\nKlucz kandydujący (candidate key) – minimalny zestaw atrybutów, który może być kluczem.\n\nKlucz obcy (foreign key) – wskazuje na klucz główny w innej tabeli i tworzy powiązanie między tabelami.\n\n\n\n🔹 Typy zależności\n\nZależność pełna – atrybut zależy od całego klucza złożonego.\n\nZależność częściowa – atrybut zależy tylko od części klucza.\n\nZależność przechodnia – atrybut zależy pośrednio od klucza (A → B → C).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#formy-normalne-1nf-3nf-bcnf",
    "href": "lectures/wyklad5.html#formy-normalne-1nf-3nf-bcnf",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "3. Formy normalne (1NF – 3NF, BCNF)",
    "text": "3. Formy normalne (1NF – 3NF, BCNF)\nNormalizacja to proces przekształcania tabel w taki sposób, aby usunąć redundancję i zapobiec anomaliom.\n\n🧩 Pierwsza postać normalna (1NF)\n\nWszystkie wartości w tabeli są atomowe (niepodzielne).\n\nBrak list, zbiorów lub kolumn powtarzających się.\n\n✅ Każda kolumna ma jedną wartość w komórce.\nPrzykład (naruszenie 1NF): | Student | NrIndeksu | Kursy | |———-|————|——–| | Jan Nowak | 12345 | Bazy danych, Programowanie |\n✅ Poprawnie:\nTworzymy osobną tabelę STUDENT_KURS, gdzie każdy kurs to osobny rekord.\n\n\n\n🧩 Druga postać normalna (2NF)\n\nTabela jest w 1NF i wszystkie atrybuty niekluczowe zależą w pełni od całego klucza głównego.\n\nDotyczy tabel z kluczem złożonym.\n\nPrzykład:\nTabela ZAPISY(StudentID, KursID, Sala)\n→ atrybut Sala zależy tylko od KursID, a nie od całego klucza (StudentID, KursID).\nRozwiązanie: wydziel tabelę KURS(KursID, Sala).\n\n\n\n🧩 Trzecia postać normalna (3NF)\n\nTabela jest w 2NF i nie zawiera zależności przechodnich.\n\nKażdy atrybut niekluczowy zależy bezpośrednio od klucza głównego.\n\nPrzykład:\nNrIndeksu → Kierunek, Kierunek → Dziekan\n➡️ Dziekan zależy pośrednio od NrIndeksu.\nRozwiązanie: osobna tabela KIERUNEK(Dziekan, Kierunek).\n\n\n\n🧩 Postać Boyce’a-Codda (BCNF)\n\nDla każdej zależności A → B, zbiór A musi być kluczem kandydującym.\n\nBardziej restrykcyjna niż 3NF – eliminuje wszelkie potencjalne redundancje.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#diagramy-erd-entityrelationship-diagram",
    "href": "lectures/wyklad5.html#diagramy-erd-entityrelationship-diagram",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "4. Diagramy ERD (Entity–Relationship Diagram)",
    "text": "4. Diagramy ERD (Entity–Relationship Diagram)\nDiagram ERD jest graficznym sposobem przedstawienia modelu konceptualnego bazy danych.\n\n🔹 Główne elementy ERD\n\nEncja (Entity) – obiekt, o którym przechowujemy dane (np. Student, Kurs).\n\nAtrybut (Attribute) – właściwość encji (np. Imię, Nazwisko, NrIndeksu).\n\nRelacja (Relationship) – powiązanie między encjami (np. Student zapisuje się na Kurs).\n\nKardynalność (Cardinality) – określa liczność relacji:\n\n1:1 (jeden do jednego)\n\n1:N (jeden do wielu)\n\nN:M (wielu do wielu)\n\n\nIdentyfikator (Primary Key) – atrybut jednoznacznie identyfikujący encję.\n\n\n\n🔹 Przykład:\nSTUDENT (NrIndeksu, Imię, Nazwisko, Kierunek)\nKURS (KursID, Nazwa, Prowadzący)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nRelacja między STUDENT a KURS: N:M poprzez encję pośredniczącą ZAPIS.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#proces-projektowania-bazy-danych",
    "href": "lectures/wyklad5.html#proces-projektowania-bazy-danych",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "5. Proces projektowania bazy danych",
    "text": "5. Proces projektowania bazy danych\nProjektowanie bazy to proces etapowy:\n\nAnaliza wymagań – zrozumienie, jakie dane są potrzebne i jakie operacje będą wykonywane.\n\nModel konceptualny – opis danych w postaci ERD.\n\nModel logiczny – zamiana modelu ERD na relacyjny schemat tabel.\n\nModel fizyczny – implementacja w konkretnym systemie DBMS (np. PostgreSQL, MySQL).\n\n\nDokumentacja SQLite\nDokumentacja PostgreSQL\nA. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  }
]