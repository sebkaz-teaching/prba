[
  {
    "objectID": "lectures/wyklad_sql_sekcje4_5.html",
    "href": "lectures/wyklad_sql_sekcje4_5.html",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL – Sekcje 4 i 5",
    "section": "",
    "text": "Indeksy to podstawowe narzędzie optymalizacji zapytań, które pozwala bazie danych szybko znaleźć potrzebne wiersze, bez konieczności skanowania całej tabeli.\nMożna je porównać do spisu treści w książce — zamiast czytać każdy rozdział, patrzymy od razu na właściwą stronę.\n\n\nBez indeksu baza danych musi sprawdzić każdy wiersz tabeli, by znaleźć pasujące rekordy (sequential scan).\nZ indeksem, silnik może odczytać tylko te dane, które spełniają warunek — znacznie szybciej i przy mniejszym zużyciu zasobów.\nKorzyści z indeksów:\n\n⏱️ Szybsze wyszukiwanie danych, szczególnie w dużych tabelach\n\n💾 Ograniczenie operacji I/O, bo baza czyta mniej bloków z dysku\n\n🔄 Przyspieszenie sortowania i łączenia tabel (JOIN), jeśli indeks obejmuje kolumny używane w warunkach\n\n\n\n\nNajczęściej spotykane:\n\nB-Tree (balanced tree) – najpopularniejszy typ, sprawdza się w większości wyszukiwań, zakresów i sortowań\n\nHash – szybki dostęp po dokładnej wartości (nie obsługuje zakresów)\n\nBitmap – efektywny dla kolumn o małej liczbie unikalnych wartości, np. płeć lub status\n\nKompozytowe – obejmują kilka kolumn, przydatne przy filtrach i sortowaniach wielokolumnowych\n\n\n\n\n\nKolumny używane w WHERE – aby szybciej wyszukać dane\n\nKolumny używane w JOIN – przyspiesza łączenie tabel\n\nKolumny w ORDER BY lub GROUP BY – pomaga szybciej sortować i grupować wyniki\n\nKolumny unikalne lub klucze główne – zapewnia integralność danych i przyspiesza wyszukiwanie\n\n\n\n\nIndeksy przyspieszają odczyt, ale mają też koszty:\n\n🔄 Spowolnienie operacji INSERT/UPDATE/DELETE, bo indeksy trzeba aktualizować\n\n💾 Zwiększone zużycie pamięci i przestrzeni dyskowej\n\n⚖️ Trzeba wybrać optymalny zestaw indeksów, żeby nie pogorszyć ogólnej wydajności"
  },
  {
    "objectID": "lectures/wyklad_sql_sekcje4_5.html#sekcja-4-indeksy-w-sql",
    "href": "lectures/wyklad_sql_sekcje4_5.html#sekcja-4-indeksy-w-sql",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL – Sekcje 4 i 5",
    "section": "",
    "text": "Indeksy to podstawowe narzędzie optymalizacji zapytań, które pozwala bazie danych szybko znaleźć potrzebne wiersze, bez konieczności skanowania całej tabeli.\nMożna je porównać do spisu treści w książce — zamiast czytać każdy rozdział, patrzymy od razu na właściwą stronę.\n\n\nBez indeksu baza danych musi sprawdzić każdy wiersz tabeli, by znaleźć pasujące rekordy (sequential scan).\nZ indeksem, silnik może odczytać tylko te dane, które spełniają warunek — znacznie szybciej i przy mniejszym zużyciu zasobów.\nKorzyści z indeksów:\n\n⏱️ Szybsze wyszukiwanie danych, szczególnie w dużych tabelach\n\n💾 Ograniczenie operacji I/O, bo baza czyta mniej bloków z dysku\n\n🔄 Przyspieszenie sortowania i łączenia tabel (JOIN), jeśli indeks obejmuje kolumny używane w warunkach\n\n\n\n\nNajczęściej spotykane:\n\nB-Tree (balanced tree) – najpopularniejszy typ, sprawdza się w większości wyszukiwań, zakresów i sortowań\n\nHash – szybki dostęp po dokładnej wartości (nie obsługuje zakresów)\n\nBitmap – efektywny dla kolumn o małej liczbie unikalnych wartości, np. płeć lub status\n\nKompozytowe – obejmują kilka kolumn, przydatne przy filtrach i sortowaniach wielokolumnowych\n\n\n\n\n\nKolumny używane w WHERE – aby szybciej wyszukać dane\n\nKolumny używane w JOIN – przyspiesza łączenie tabel\n\nKolumny w ORDER BY lub GROUP BY – pomaga szybciej sortować i grupować wyniki\n\nKolumny unikalne lub klucze główne – zapewnia integralność danych i przyspiesza wyszukiwanie\n\n\n\n\nIndeksy przyspieszają odczyt, ale mają też koszty:\n\n🔄 Spowolnienie operacji INSERT/UPDATE/DELETE, bo indeksy trzeba aktualizować\n\n💾 Zwiększone zużycie pamięci i przestrzeni dyskowej\n\n⚖️ Trzeba wybrać optymalny zestaw indeksów, żeby nie pogorszyć ogólnej wydajności"
  },
  {
    "objectID": "lectures/wyklad_sql_sekcje4_5.html#sekcja-5-praktyczne-przykłady-użycia-indeksów",
    "href": "lectures/wyklad_sql_sekcje4_5.html#sekcja-5-praktyczne-przykłady-użycia-indeksów",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL – Sekcje 4 i 5",
    "section": "🧪 Sekcja 5 – Praktyczne przykłady użycia indeksów",
    "text": "🧪 Sekcja 5 – Praktyczne przykłady użycia indeksów\nW tej sekcji pokażemy, jak indeksy wpływają na plan wykonania zapytania i rzeczywisty czas wykonania.\n\n🔹 Przykład w PostgreSQL\nMamy tabelę orders:\nCREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  customer_id INTEGER,\n  order_date DATE,\n  total DECIMAL\n);\n\nScenariusz A – brak indeksu\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\nWynik może wyglądać tak:\nSeq Scan on orders  (cost=0.00..450.00 rows=3 width=48)\n  Filter: (customer_id = 42)\nExecution Time: 22.5 ms\n\nBaza przeszukuje całą tabelę (Seq Scan), co jest kosztowne przy dużej liczbie rekordów.\n\n\n\nScenariusz B – z indeksem\nDodajemy indeks na kolumnie customer_id:\nCREATE INDEX idx_orders_customer ON orders(customer_id);\nPo wykonaniu tego samego zapytania:\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\nPlan wykonania:\nIndex Scan using idx_orders_customer on orders  (cost=0.29..8.50 rows=3 width=48)\n  Index Cond: (customer_id = 42)\nExecution Time: 0.030 ms\n➡️ Widać ogromną poprawę wydajności: baza odczytuje tylko pasujące wiersze zamiast całej tabeli.\n\n\n\n🔹 Indeksy a JOIN\nPrzy łączeniu tabel:\nSELECT o.id, c.name\nFROM orders o\nJOIN customers c ON o.customer_id = c.id\nWHERE c.region = 'Europe';\n\nIndeks na customers.id i orders.customer_id przyspiesza JOIN\n\nIndeks na customers.region przyspiesza filtrowanie po regionie\n\n\n\n🔹 Wskazówki praktyczne\n\nTwórz indeksy tylko na kolumnach, które są często filtrowane lub sortowane\n\nAnalizuj plany wykonania przy użyciu EXPLAIN i EXPLAIN ANALYZE\n\nZwracaj uwagę na koszt operacji (cost=…) i liczbę wierszy (rows=...)\n\nPamiętaj o balansie: zbyt wiele indeksów może spowolnić zapis danych"
  },
  {
    "objectID": "lectures/wyklad6.html",
    "href": "lectures/wyklad6.html",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "",
    "text": "Optymalizacja zapytań SQL to jeden z najważniejszych elementów pracy z bazami danych.\nDotyczy zarówno programistów aplikacji, jak i administratorów baz danych (DBA).\nCelem jest takie przygotowanie zapytań, struktur danych i indeksów, aby uzyskać maksymalną wydajność przy minimalnym obciążeniu systemu.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#dlaczego-optymalizacja-jest-ważna",
    "href": "lectures/wyklad6.html#dlaczego-optymalizacja-jest-ważna",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "💡 Dlaczego optymalizacja jest ważna?",
    "text": "💡 Dlaczego optymalizacja jest ważna?\nKażde zapytanie SQL, nawet najprostsze, wymaga od silnika bazy danych wykonania określonych operacji: odczytu danych z dysku, przetworzenia warunków WHERE, wykonania JOIN, GROUP BY, ORDER BY, a następnie zwrócenia wyników użytkownikowi.\nJeśli baza danych zawiera miliony rekordów, to nawet niewielkie różnice w sposobie wykonania zapytania mogą oznaczać:\n\nróżnicę między milisekundami a sekundami,\n\nobciążenie jednego wątku zamiast całego serwera,\n\nlub zużycie gigabajtów pamięci i I/O bez potrzeby.\n\n\n🧠 „Optymalizacja zapytań SQL to nie sztuka pisania krótszego kodu,\nlecz umiejętność zmuszenia silnika bazy danych do pracy mądrze, a nie ciężko.”",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#jak-działa-zapytanie-w-silniku-bazy-danych",
    "href": "lectures/wyklad6.html#jak-działa-zapytanie-w-silniku-bazy-danych",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "⚙️ Jak działa zapytanie w silniku bazy danych?",
    "text": "⚙️ Jak działa zapytanie w silniku bazy danych?\nAby zrozumieć optymalizację, musimy wiedzieć, co dzieje się z zapytaniem od momentu jego wysłania do bazy danych.\nSilnik SQL analizuje składnię zapytania, przepisuje je logicznie, wybiera najtańszy plan wykonania i dopiero wtedy odczytuje dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#co-wpływa-na-wydajność-zapytań-sql",
    "href": "lectures/wyklad6.html#co-wpływa-na-wydajność-zapytań-sql",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "🧩 Co wpływa na wydajność zapytań SQL?",
    "text": "🧩 Co wpływa na wydajność zapytań SQL?\nWydajność zapytań zależy zarówno od tego, jak zapytanie jest napisane, jak i od tego, jak zorganizowane są dane w bazie:\n\n🔹 Struktura zapytania\n\nZłożoność klauzul WHERE, JOIN, ORDER BY\nZagnieżdżone podzapytania (subqueries)\nUżycie funkcji agregujących (COUNT, SUM, AVG)\n\n\n\n🔹 Architektura danych\n\nIlość danych w tabelach\n\nIndeksy (ich liczba, rodzaj i aktualność)\n\nKlucze główne i obce (PRIMARY KEY, FOREIGN KEY)\n\nStopień normalizacji lub denormalizacji danych\n\n\n\n🔹 Stan środowiska bazy\n\nDostępna pamięć RAM\n\nBuforowanie i cache dyskowy\n\nStatystyki tabel (ANALYZE, UPDATE STATISTICS)\n\nObciążenie serwera (inne procesy, sesje, transakcje)",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#przykład-znaczenia-optymalizacji",
    "href": "lectures/wyklad6.html#przykład-znaczenia-optymalizacji",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "📊 Przykład znaczenia optymalizacji",
    "text": "📊 Przykład znaczenia optymalizacji\nWyobraźmy sobie tabelę orders z 10 milionami zamówień.\nChcemy znaleźć wszystkie zamówienia z ostatnich 30 dni:\nSELECT * FROM orders WHERE order_date &gt;= CURRENT_DATE - INTERVAL '30 days';\n\nScenariusz A – brak indeksu\nSilnik musi przeskanować całą tabelę (tzw. Seq Scan). Każdy wiersz jest sprawdzany, czy spełnia warunek order_date &gt;= ....\n\n⏱️ Czas wykonania: ~3.2 s\n\n💾 Operacje I/O: wysokie\n\n\n\nScenariusz B – z indeksem\nDodajemy indeks:\nCREATE INDEX idx_orders_date ON orders(order_date);\nSilnik teraz korzysta z Index Scan, czyli odczytu tylko fragmentu danych pasujących do warunku.\n\n⏱️ Czas wykonania: ~0.03 s\n\n💾 Operacje I/O: minimalne\n\n➡️ 100× szybsze zapytanie – bez zmiany jednej linijki logiki, tylko dzięki optymalizacji struktury danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#czym-jest-optymalizator-zapytań",
    "href": "lectures/wyklad6.html#czym-jest-optymalizator-zapytań",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "🧠 Czym jest optymalizator zapytań?",
    "text": "🧠 Czym jest optymalizator zapytań?\nOptymalizator analizuje zapytanie i decyduje, w jaki sposób najlepiej pobrać dane.\nNie zmienia logiki zapytania, ale może całkowicie zmienić:\n\nkolejność operacji,\n\nsposób łączenia tabel (JOIN order),\n\nwybór indeksów,\n\nmetodę sortowania lub agregacji.\n\n\n💡 Optymalizator to planista — nie wykonuje zapytania sam,\nale układa plan działania tak, by wynik uzyskać jak najszybciej i najtaniej.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#etapy-przetwarzania-zapytania",
    "href": "lectures/wyklad6.html#etapy-przetwarzania-zapytania",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "🔄 Etapy przetwarzania zapytania",
    "text": "🔄 Etapy przetwarzania zapytania\nDla przykładu:\nSELECT name, salary \nFROM employees \nWHERE department_id = 10 AND salary &gt; 5000;\nSilnik przechodzi przez kilka logicznych etapów:\n\n1. Parsing (analiza składniowa)\n\nsprawdza poprawność składni SQL,\n\nweryfikuje istnienie tabel i kolumn,\n\ntworzy drzewo zapytania (parse tree).\n\n\n\n2. Rewriting (przepisanie logiczne)\n\nupraszcza warunki (WHERE TRUE, podwójne filtry),\n\nzamienia IN na EXISTS,\n\nłączy filtry logiczne (AND, OR),\n\nmoże przenosić warunki do podzapytań (predicate pushdown).\n\n\n\n3. Optimization (planowanie kosztowe)\nOptymalizator analizuje różne plany wykonania: - który indeks użyć,\n- w jakiej kolejności łączyć tabele,\n- jakiego algorytmu użyć (hash join, merge join, nested loop).\nKażdy plan ma przypisany koszt (cost estimate) oparty na: - liczbie wierszy,\n- selektywności warunków,\n- dostępnych indeksach,\n- statystykach i kosztach I/O oraz CPU.\n\n🧮 Optymalizator nie wykonuje zapytań — symuluje scenariusze i wybiera ten o najniższym koszcie.\n\n\n\n4. Execution Plan (plan wykonania)\nPo wyborze najlepszego planu, optymalizator przekazuje go do modułu wykonawczego.\nPlan opisuje krok po kroku, jak dane zostaną pobrane i przetworzone.\nMożemy go podejrzeć poleceniem:\nEXPLAIN SELECT ...\nlub\nEXPLAIN ANALYZE SELECT ...",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#co-to-jest-plan-zapytania",
    "href": "lectures/wyklad6.html#co-to-jest-plan-zapytania",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "⚙️ Co to jest plan zapytania?",
    "text": "⚙️ Co to jest plan zapytania?\nPlan zapytania to opis kroków, jakie silnik bazy danych musi wykonać, by uzyskać wynik.\nKażdy krok reprezentuje konkretną operację — np.: - Scan (odczyt danych z tabeli lub indeksu), - Join (łączenie danych z kilku tabel), - Sort (sortowanie wyników), - Aggregate (sumowanie, grupowanie, liczenie).\nKażdy z tych kroków ma przypisany szacowany koszt — liczbową wartość określającą, ile operacji CPU, I/O lub pamięci wymaga jego wykonanie.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#składnia-polecenia-explain",
    "href": "lectures/wyklad6.html#składnia-polecenia-explain",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "🧩 Składnia polecenia EXPLAIN",
    "text": "🧩 Składnia polecenia EXPLAIN\nW większości systemów baz danych można użyć EXPLAIN na początku dowolnego zapytania:\nEXPLAIN SELECT * FROM employees WHERE department_id = 10;\nAby uzyskać więcej szczegółów, można dodać:\nEXPLAIN ANALYZE SELECT * FROM employees WHERE department_id = 10;\n📊 Różnica:\n\nEXPLAIN — pokazuje plan teoretyczny (na podstawie statystyk i kosztów),\nEXPLAIN ANALYZE — faktycznie wykonuje zapytanie i pokazuje rzeczywisty czas oraz liczbę przetworzonych wierszy.\n\n\n🧠 Przykład w PostgreSQL\nZałóżmy, że mamy tabelę:\nCREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  customer_id INTEGER,\n  order_date DATE,\n  total DECIMAL\n);\n\nCREATE INDEX idx_orders_customer ON orders(customer_id);\ni wykonujemy zapytanie:\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\n\n\n🔹 Wynik (plan zapytania):\nIndex Scan using idx_orders_customer on orders  (cost=0.29..8.50 rows=3 width=48)\n  Index Cond: (customer_id = 42)\nPlanning Time: 0.100 ms\nExecution Time: 0.030 ms\n\n\n\n\n\n\n\nElement\nZnaczenie\n\n\n\n\nIndex Scan\nBaza odczytuje dane przy użyciu indeksu (nie pełny skan tabeli).\n\n\nidx_orders_customer\nNazwa użytego indeksu.\n\n\ncost=0.29..8.50\nSzacowany koszt (startowy i całkowity). Im mniejszy, tym lepiej.\n\n\nrows=3\nSzacowana liczba wierszy, które spełnią warunek.\n\n\nwidth=48\nŚredni rozmiar jednego wiersza (w bajtach).\n\n\nIndex Cond\nWarunek, który został użyty do przeszukania indeksu.\n\n\nExecution Time\nFaktyczny czas wykonania (tylko w EXPLAIN ANALYZE).\n\n\n\n\n\n🔎 Porównanie: brak indeksu\nJeśli usuniemy indeks i uruchomimy to samo zapytanie:\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\notrzymamy:\nSeq Scan on orders  (cost=0.00..450.00 rows=3 width=48)\n  Filter: (customer_id = 42)\nExecution Time: 22.5 ms\n📉 Różnica:\n\nBaza musi przeskanować całą tabelę (Seq Scan),\nPomimo tego, że wynik jest ten sam, wykonanie jest znacznie wolniejsze.\n\n💬 EXPLAIN pokazuje, że problemem nie jest zapytanie, lecz brak indeksu.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#jak-korzystać-z-explain-w-praktyce",
    "href": "lectures/wyklad6.html#jak-korzystać-z-explain-w-praktyce",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "🧮 Jak korzystać z EXPLAIN w praktyce",
    "text": "🧮 Jak korzystać z EXPLAIN w praktyce\n\nSprawdzaj, czy używany jest indeks\n\nJeśli widzisz Seq Scan lub SCAN TABLE, to znak, że indeks nie jest wykorzystywany.\n\nZwracaj uwagę na kolejność JOINów\n\nCzasami odwrócenie kolejności tabel w zapytaniu może dać inny plan i lepszy czas.\n\nAnalizuj koszty (cost=…)\n\nPorównuj plany z różnymi indeksami i filtrami — wybieraj ten o niższym koszcie.\n\nUżywaj EXPLAIN ANALYZE tylko testowo\n\nW środowisku produkcyjnym EXPLAIN ANALYZE faktycznie wykonuje zapytanie, więc może być kosztowne.\n\nPorównuj teoretyczny i rzeczywisty plan\n\nJeśli szacunki (rows, cost) mocno różnią się od rzeczywistego czasu, oznacza to:\n\nbrak aktualnych statystyk,\nzły indeks,\nlub błędne założenia optymalizatora.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#indeksy-w-sql",
    "href": "lectures/wyklad6.html#indeksy-w-sql",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "🗂️ Indeksy w SQL",
    "text": "🗂️ Indeksy w SQL\nIndeksy to podstawowe narzędzie optymalizacji zapytań, które pozwala bazie danych szybko znaleźć potrzebne wiersze, bez konieczności skanowania całej tabeli.\nMożna je porównać do spisu treści w książce — zamiast czytać każdy rozdział, patrzymy od razu na właściwą stronę.\n\n🔹 Dlaczego indeksy są ważne?\nBez indeksu baza danych musi sprawdzić każdy wiersz tabeli, by znaleźć pasujące rekordy (sequential scan).\nZ indeksem, silnik może odczytać tylko te dane, które spełniają warunek — znacznie szybciej i przy mniejszym zużyciu zasobów.\nKorzyści z indeksów:\n\n⏱️ Szybsze wyszukiwanie danych, szczególnie w dużych tabelach\n\n💾 Ograniczenie operacji I/O, bo baza czyta mniej bloków z dysku\n\n🔄 Przyspieszenie sortowania i łączenia tabel (JOIN), jeśli indeks obejmuje kolumny używane w warunkach\n\n\n\n🔹 Rodzaje indeksów\nNajczęściej spotykane:\n\nB-Tree (balanced tree) – najpopularniejszy typ, sprawdza się w większości wyszukiwań, zakresów i sortowań\n\nHash – szybki dostęp po dokładnej wartości (nie obsługuje zakresów)\n\nBitmap – efektywny dla kolumn o małej liczbie unikalnych wartości, np. płeć lub status\n\nKompozytowe – obejmują kilka kolumn, przydatne przy filtrach i sortowaniach wielokolumnowych\n\n\n\n🔹 Co indeksuje?\n\nKolumny używane w WHERE – aby szybciej wyszukać dane\n\nKolumny używane w JOIN – przyspiesza łączenie tabel\n\nKolumny w ORDER BY lub GROUP BY – pomaga szybciej sortować i grupować wyniki\n\nKolumny unikalne lub klucze główne – zapewnia integralność danych i przyspiesza wyszukiwanie\n\n\n\n🔹 Wady nadmiaru indeksów\nIndeksy przyspieszają odczyt, ale mają też koszty:\n\n🔄 Spowolnienie operacji INSERT/UPDATE/DELETE, bo indeksy trzeba aktualizować\n\n💾 Zwiększone zużycie pamięci i przestrzeni dyskowej\n\n⚖️ Trzeba wybrać optymalny zestaw indeksów, żeby nie pogorszyć ogólnej wydajności",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#praktyczne-aspekty-użycia-indeksów",
    "href": "lectures/wyklad6.html#praktyczne-aspekty-użycia-indeksów",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "Praktyczne aspekty użycia indeksów",
    "text": "Praktyczne aspekty użycia indeksów\nW tej sekcji rozszerzamy temat indeksów, unikając powtórzenia wcześniejszych przykładów z SELECT po customer_id.\nPrzy łączeniu tabel indeksy znacząco przyspieszają zapytania:\nSELECT o.id, c.name\nFROM orders o\nJOIN customers c ON o.customer_id = c.id\nWHERE c.region = 'Europe';\n\nIndeks na customers.id i orders.customer_id przyspiesza JOIN\nIndeks na customers.region przyspiesza filtrowanie po regionie",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad6.html#indeksy-a-sortowanie-i-grupowanie",
    "href": "lectures/wyklad6.html#indeksy-a-sortowanie-i-grupowanie",
    "title": "🧭 Wprowadzenie do optymalizacji zapytań SQL",
    "section": "Indeksy a sortowanie i grupowanie",
    "text": "Indeksy a sortowanie i grupowanie\nIndeksy na kolumnach używanych w ORDER BY lub GROUP BY pozwalają uniknąć kosztownych operacji sortowania w pamięci:\nSELECT customer_id, SUM(total) \nFROM orders \nGROUP BY customer_id \nORDER BY SUM(total) DESC;\n\nIndeks na customer_id może przyspieszyć agregację\nIndeks kompozytowy z kolumną używaną w ORDER BY może wyeliminować dodatkowe sortowanie\n\n🔹 Wpływ indeksów na modyfikacje danych\n\nOperacje INSERT, UPDATE, DELETE wymagają aktualizacji indeksów\nZbyt wiele indeksów może spowolnić zapis danych\nW praktyce wybieramy najbardziej potrzebne indeksy i monitorujemy ich wpływ\n\n🔹 Wskazówki praktyczne\n\nTwórz indeksy tylko na kolumnach często filtrowanych lub sortowanych\nAnalizuj plany wykonania (EXPLAIN, EXPLAIN ANALYZE)\nZwracaj uwagę na koszt operacji (cost=…) i liczbę wierszy (rows=…)\nRównoważ czas odczytu i zapis danych – nie każdy indeks jest opłacalny",
    "crumbs": [
      "Książki",
      "Wykłady",
      "🧭 Wprowadzenie do optymalizacji zapytań SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html",
    "href": "lectures/wyklad5.html",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "",
    "text": "Złe zaprojektowanie struktury bazy danych prowadzi do wielu problemów:\n\n\nTo powielanie tych samych informacji w różnych miejscach bazy.\nPrzykład: jeśli w każdej tabeli z zamówieniami przechowujemy pełne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordów.\n\n\n\nBłędy i niekonsekwencje wynikające z nadmiarowej struktury danych.\n\nAnomalia aktualizacji – zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykładowcy w kilku wierszach tabeli.\nAnomalia wstawiania – brak możliwości dodania danych bez istnienia innych.\nNp. nie można dodać nowego kursu, dopóki nie zapisze się na niego student.\nAnomalia usuwania – usunięcie rekordu powoduje utratę innych informacji.\nNp. usunięcie ostatniego studenta z kursu powoduje utratę danych o samym kursie.\n\n👉 Wniosek: błędy projektowe utrudniają utrzymanie spójności danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#problemy-złego-projektu-bazy-danych",
    "href": "lectures/wyklad5.html#problemy-złego-projektu-bazy-danych",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "",
    "text": "Złe zaprojektowanie struktury bazy danych prowadzi do wielu problemów:\n\n\nTo powielanie tych samych informacji w różnych miejscach bazy.\nPrzykład: jeśli w każdej tabeli z zamówieniami przechowujemy pełne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordów.\n\n\n\nBłędy i niekonsekwencje wynikające z nadmiarowej struktury danych.\n\nAnomalia aktualizacji – zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykładowcy w kilku wierszach tabeli.\nAnomalia wstawiania – brak możliwości dodania danych bez istnienia innych.\nNp. nie można dodać nowego kursu, dopóki nie zapisze się na niego student.\nAnomalia usuwania – usunięcie rekordu powoduje utratę innych informacji.\nNp. usunięcie ostatniego studenta z kursu powoduje utratę danych o samym kursie.\n\n👉 Wniosek: błędy projektowe utrudniają utrzymanie spójności danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#zależności-funkcjonalne",
    "href": "lectures/wyklad5.html#zależności-funkcjonalne",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "2. Zależności funkcjonalne",
    "text": "2. Zależności funkcjonalne\n\n🔹 Definicja\nZależność funkcjonalna (ang. functional dependency) opisuje relację między atrybutami w tabeli.\nMówimy, że atrybut B jest funkcyjnie zależny od atrybutu A (zapis:\nA → B), jeśli każdej wartości A odpowiada dokładnie jedna wartość B.\n\n\n🔹 Przykłady\n\nNrIndeksu → Imię, Nazwisko, Kierunek\n(każdy numer indeksu jednoznacznie identyfikuje studenta)\nKurs → Sala, Prowadzący\n(dany kurs odbywa się zawsze w tej samej sali, prowadzony przez tę samą osobę)\n\n\n\n🔹 Klucze\n\nKlucz główny (primary key) – jednoznacznie identyfikuje wiersz tabeli.\n\nKlucz kandydujący (candidate key) – minimalny zestaw atrybutów, który może być kluczem.\n\nKlucz obcy (foreign key) – wskazuje na klucz główny w innej tabeli i tworzy powiązanie między tabelami.\n\n\n\n🔹 Typy zależności\n\nZależność pełna – atrybut zależy od całego klucza złożonego.\n\nZależność częściowa – atrybut zależy tylko od części klucza.\n\nZależność przechodnia – atrybut zależy pośrednio od klucza (A → B → C).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#formy-normalne-1nf-3nf-bcnf",
    "href": "lectures/wyklad5.html#formy-normalne-1nf-3nf-bcnf",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "3. Formy normalne (1NF – 3NF, BCNF)",
    "text": "3. Formy normalne (1NF – 3NF, BCNF)\nNormalizacja to proces przekształcania tabel w taki sposób, aby usunąć redundancję i zapobiec anomaliom.\n\n🧩 Pierwsza postać normalna (1NF)\n\nWszystkie wartości w tabeli są atomowe (niepodzielne).\n\nBrak list, zbiorów lub kolumn powtarzających się.\n\n✅ Każda kolumna ma jedną wartość w komórce.\nPrzykład (naruszenie 1NF):\n\n\n\nStudent\nNrIndeksu\nKursy\n\n\n\n\nJan Nowak\n12345\nBazy danych, Programowanie\n\n\n\n✅ Poprawnie:\nTworzymy osobną tabelę STUDENT_KURS, gdzie każdy kurs to osobny rekord.\n\n\n\n🧩 Druga postać normalna (2NF)\n\nTabela jest w 1NF i wszystkie atrybuty niekluczowe zależą w pełni od całego klucza głównego.\n\nDotyczy tabel z kluczem złożonym.\n\nPrzykład:\nTabela ZAPISY(StudentID, KursID, Sala)\n→ atrybut Sala zależy tylko od KursID, a nie od całego klucza (StudentID, KursID).\nRozwiązanie: wydziel tabelę KURS(KursID, Sala).\n\n\n\n🧩 Trzecia postać normalna (3NF)\n\nTabela jest w 2NF i nie zawiera zależności przechodnich.\n\nKażdy atrybut niekluczowy zależy bezpośrednio od klucza głównego.\n\nPrzykład:\nNrIndeksu → Kierunek, Kierunek → Dziekan\n➡️ Dziekan zależy pośrednio od NrIndeksu.\nRozwiązanie: osobna tabela KIERUNEK(Dziekan, Kierunek).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#diagramy-erd-entityrelationship-diagram",
    "href": "lectures/wyklad5.html#diagramy-erd-entityrelationship-diagram",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "4. Diagramy ERD (Entity–Relationship Diagram)",
    "text": "4. Diagramy ERD (Entity–Relationship Diagram)\nDiagram ERD jest graficznym sposobem przedstawienia modelu konceptualnego bazy danych.\n\n🔹 Główne elementy ERD\n\nEncja (Entity) – obiekt, o którym przechowujemy dane (np. Student, Kurs).\n\nAtrybut (Attribute) – właściwość encji (np. Imię, Nazwisko, NrIndeksu).\n\nRelacja (Relationship) – powiązanie między encjami (np. Student zapisuje się na Kurs).\n\nKardynalność (Cardinality) – określa liczność relacji:\n\n1:1 (jeden do jednego)\n\n1:N (jeden do wielu)\n\nN:M (wielu do wielu)\n\n\nIdentyfikator (Primary Key) – atrybut jednoznacznie identyfikujący encję.\n\n\n\n🔹 Przykład:\nSTUDENT (NrIndeksu, Imię, Nazwisko, Kierunek)\nKURS (KursID, Nazwa, Prowadzący)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nRelacja między STUDENT a KURS: N:M poprzez encję pośredniczącą ZAPIS.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#proces-projektowania-bazy-danych",
    "href": "lectures/wyklad5.html#proces-projektowania-bazy-danych",
    "title": "Jak uniknąć błędów w projektowaniu?",
    "section": "5. Proces projektowania bazy danych",
    "text": "5. Proces projektowania bazy danych\nProjektowanie bazy to proces etapowy:\n\nAnaliza wymagań – zrozumienie, jakie dane są potrzebne i jakie operacje będą wykonywane.\n\nModel konceptualny – opis danych w postaci ERD.\n\nModel logiczny – zamiana modelu ERD na relacyjny schemat tabel.\n\nModel fizyczny – implementacja w konkretnym systemie DBMS (np. PostgreSQL, MySQL).\n\n\nDokumentacja SQLite\nDokumentacja PostgreSQL\nA. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Jak uniknąć błędów w projektowaniu?"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Celem wykładu jest zapoznanie się z podstawami relacyjnych baz danych — ich historią, pojęciami, architekturą, strukturą danych oraz zasadami integralności. Po tym wykładzie student powinien rozumieć, czym jest baza danych, jak działa DBMS, co oznacza model relacyjny oraz jakie są klucze i reguły spójności danych.\n\n\n\nBazy danych nie są wynalazkiem XXI wieku — ich początki sięgają lat 60. XX wieku, gdy organizacje zaczęły gromadzić coraz większe ilości danych.\n\n\nPierwsze systemy przechowywały dane w plikach na dyskach. Choć były proste, miały poważne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudność w utrzymaniu spójności\nBrak uniwersalnych narzędzi do wyszukiwania\n\n💡 Zadanie: Na jakich innych obiektach, oprócz plików, można pracować w systemach operacyjnych?\n\n\n\nW latach 60. i 70. pojawiły się pierwsze systemy zarządzania bazami danych (DBMS). Zapewniały:\n\ncentralną kontrolę danych,\nintegralność i bezpieczeństwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n\nWczesne systemy wykorzystywały struktury drzewiaste lub grafowe. Były skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n\nW 1970 roku Edgar F. Codd zaproponował model relacyjny danych, w którym:\n\ndane są przechowywane w tabelach (relacjach),\nkażda tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystość,\nelastyczność (łatwo dodawać nowe tabele),\nbezpieczeństwo i spójność danych.\n\n\n\n\nWraz z rozwojem modelu relacyjnego powstał SQL (Structured Query Language) – język do tworzenia, modyfikowania i pobierania danych.\nDziś SQL jest fundamentem większości systemów: od aplikacji biurowych po duże systemy korporacyjne. Nawet współczesne rozwiązania NoSQL często nawiązują do idei relacyjnych.\n\n\n\n\n\n\n\nDane – surowe fakty, liczby, teksty, które same w sobie niewiele znaczą. 👉 np. 25, Warszawa, 12345\nInformacja – dane zinterpretowane i zorganizowane w kontekście. 👉 np. „25 klientów z Warszawy złożyło zamówienie w ostatnim tygodniu”.\n\nDane to materiał, informacja to znaczenie.\n\n\n\nZorganizowany zbiór danych umożliwiający ich łatwe przeszukiwanie, aktualizację i analizę.\nCechy:\n\nStrukturalność\nCentralizacja\nTrwałość i bezpieczeństwo\n\nPrzykłady:\n\nLista kontaktów w telefonie\nSystem rezerwacji hotelowej\nSklep internetowy\n\nTermin ,,baza danych’’ uzywany jest na wiele róznych sposobów, ale na wykładzie baza danych oznacza zbiór danych przechowywanych w pewien zorganizowany sposób. Najprościej wyobrazić sobie bazę danych jako szafkę na dokumenty. Jest to miejsce umozliwiające przechowywanie informacji, niezaleznie od ich typu i sposobu organizacji.\n\n\n\nBardzo często uzywamy terminu “baza danych” do określenia oprogramowania bazy danych, którego uzywamy. Takie podejście jest błędne i powoduje wiele nieporozumień. Oprogramowanie BD nazywane jest poprawnie sustemem zarządzania bazą danych (SZBD) lub (DBMS - Database Management System). Sama baza danych jest pojemnikiem tworzonym i modyfikowanym przez SZBD. Konkretna postać BD zienia się w zalezności od zastosowań.\nOprogramowanie do tworzenia, modyfikowania i przetwarzania baz danych.\nFunkcje DBMS:\n\nTworzenie i modyfikacja schematów\nOperacje CRUD (Create, Read, Update, Delete)\nZarządzanie bezpieczeństwem i uprawnieniami\nOptymalizacja zapytań\n\nPrzykłady: MySQL, PostgreSQL, Oracle, SQL Server, SQLite.\n\n\n\n\nSystemy baz danych są zorganizowane według poziomów abstrakcji, co pozwala oddzielić sposób przechowywania danych od ich widoku dla użytkownika.\n\n\n\nPoziom fizyczny (wewnętrzny)\n\n\nopisuje sposób przechowywania danych (pliki, indeksy, struktury).\n\n\nPoziom logiczny (pośredni)\n\n\nopisuje strukturę danych (tabele, relacje, typy danych).\n\n\nPoziom zewnętrzny (widok użytkownika)\n\n\npokazuje dane z perspektywy użytkownika lub aplikacji.\n\nZmiany w jednym poziomie nie wymagają zmian w pozostałych — to tzw. niezależność danych.\n\n\n\nFormalny model trójpoziomowy:\n\npoziom wewnętrzny – fizyczne przechowywanie danych,\npoziom pojęciowy – logiczna struktura bazy,\npoziom zewnętrzny – widoki użytkowników.\n\nZalety:\n\nizolacja danych,\nbezpieczeństwo,\nelastyczność i skalowalność.\n\n\n\n\n\n\n\nTABELA to:\n\nZbiór danych o tej samej strukturze.\nUporządkowana lista zawierająca dane określonego typu\n\nKażda tabela opisuje jeden typ obiektów (np. Studenci, Kursy).\nNajwazniejsze, ze tabela przechowuje dane jednego typu. W jednej tabeli nie pojawi się jednocześnie lista kontaktów i lista zamówień. &gt; Uwaga: Technicznie taka tabela jest mozliwa do realizacji ale pobieranie konkretnych elementów &gt; byłoby znacznie utrudnione.\n\nUwaga: Kazda tabela posiada nazwę pozwalającą jednoznacznie ją zidentyfikować. Nazwa zawsze jest unikalna - zadna inna tabela nie moze mieć takiej samej nazwy.\n\n\n\n\nPojedynczy rekord w tabeli (np. dane jednego studenta).\n\n\n\nWłaściwość obiektu – ma nazwę i typ danych (np. Imię, Nazwisko, NrIndeksu).\n\n\n\nZbiór dopuszczalnych wartości atrybutu (np. liczby całkowite, ciągi znaków do 50 znaków).\n\n\n\n\nSchemat relacji – struktura tabeli (nazwy kolumn, typy).\nInstancja relacji – aktualna zawartość tabeli.\n\n\n\n\n\n\n\n\njednoznacznie identyfikuje każdy rekord,\nnie może mieć wartości NULL.\n\nPrzykład: NrIndeksu w tabeli Studenci.\n\n\n\n\nkażdy atrybut (lub ich kombinacja), który mógłby być kluczem głównym. Przykład: NrIndeksu i PESEL – wybieramy jeden jako główny.\n\n\n\n\n\natrybut wskazujący na klucz główny w innej tabeli. Przykład: NrIndeksu w tabeli Oceny odnosi się do Studenci.\n\n\n\n\n\nIntegralność encji – każda krotka musi być jednoznacznie identyfikowana.\nIntegralność referencyjna – wartości kluczy obcych muszą istnieć w tabelach nadrzędnych.\nIntegralność dziedzinowa – wartości atrybutów muszą mieścić się w swoich domenach.\n\n\n\n\n\n\n\n\nKto zaproponował model relacyjny danych?\n\n\nDonald Knuth\nEdgar F. Codd\nBill Gates\nCharles Bachman\n\n\nCo opisuje poziom logiczny w architekturze ANSI/SPARC?\n\n\nSposób fizycznego zapisu danych\nWidok danych przez użytkownika\nStrukturę danych i relac\n\n✏️ Pytania otwarte / opisowe\n\nWyjaśnij różnicę między danymi a informacją.\nWymień i krótko opisz trzy poziomy abstrakcji w modelu ANSI/SPARC.\nCo to jest klucz główny i jakie są jego cechy?\nPodaj przykład relacji i wskaż w niej krotki oraz atrybuty.\nDlaczego model relacyjny okazał się przełomem w historii baz danych?\nJakie są trzy podstawowe zasady integralności danych?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#wprowadzenie-i-cele-wykładu",
    "href": "lectures/wyklad1.html#wprowadzenie-i-cele-wykładu",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Celem wykładu jest zapoznanie się z podstawami relacyjnych baz danych — ich historią, pojęciami, architekturą, strukturą danych oraz zasadami integralności. Po tym wykładzie student powinien rozumieć, czym jest baza danych, jak działa DBMS, co oznacza model relacyjny oraz jakie są klucze i reguły spójności danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "href": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Bazy danych nie są wynalazkiem XXI wieku — ich początki sięgają lat 60. XX wieku, gdy organizacje zaczęły gromadzić coraz większe ilości danych.\n\n\nPierwsze systemy przechowywały dane w plikach na dyskach. Choć były proste, miały poważne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudność w utrzymaniu spójności\nBrak uniwersalnych narzędzi do wyszukiwania\n\n💡 Zadanie: Na jakich innych obiektach, oprócz plików, można pracować w systemach operacyjnych?\n\n\n\nW latach 60. i 70. pojawiły się pierwsze systemy zarządzania bazami danych (DBMS). Zapewniały:\n\ncentralną kontrolę danych,\nintegralność i bezpieczeństwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n\nWczesne systemy wykorzystywały struktury drzewiaste lub grafowe. Były skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n\nW 1970 roku Edgar F. Codd zaproponował model relacyjny danych, w którym:\n\ndane są przechowywane w tabelach (relacjach),\nkażda tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystość,\nelastyczność (łatwo dodawać nowe tabele),\nbezpieczeństwo i spójność danych.\n\n\n\n\nWraz z rozwojem modelu relacyjnego powstał SQL (Structured Query Language) – język do tworzenia, modyfikowania i pobierania danych.\nDziś SQL jest fundamentem większości systemów: od aplikacji biurowych po duże systemy korporacyjne. Nawet współczesne rozwiązania NoSQL często nawiązują do idei relacyjnych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "href": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Dane – surowe fakty, liczby, teksty, które same w sobie niewiele znaczą. 👉 np. 25, Warszawa, 12345\nInformacja – dane zinterpretowane i zorganizowane w kontekście. 👉 np. „25 klientów z Warszawy złożyło zamówienie w ostatnim tygodniu”.\n\nDane to materiał, informacja to znaczenie.\n\n\n\nZorganizowany zbiór danych umożliwiający ich łatwe przeszukiwanie, aktualizację i analizę.\nCechy:\n\nStrukturalność\nCentralizacja\nTrwałość i bezpieczeństwo\n\nPrzykłady:\n\nLista kontaktów w telefonie\nSystem rezerwacji hotelowej\nSklep internetowy\n\nTermin ,,baza danych’’ uzywany jest na wiele róznych sposobów, ale na wykładzie baza danych oznacza zbiór danych przechowywanych w pewien zorganizowany sposób. Najprościej wyobrazić sobie bazę danych jako szafkę na dokumenty. Jest to miejsce umozliwiające przechowywanie informacji, niezaleznie od ich typu i sposobu organizacji.\n\n\n\nBardzo często uzywamy terminu “baza danych” do określenia oprogramowania bazy danych, którego uzywamy. Takie podejście jest błędne i powoduje wiele nieporozumień. Oprogramowanie BD nazywane jest poprawnie sustemem zarządzania bazą danych (SZBD) lub (DBMS - Database Management System). Sama baza danych jest pojemnikiem tworzonym i modyfikowanym przez SZBD. Konkretna postać BD zienia się w zalezności od zastosowań.\nOprogramowanie do tworzenia, modyfikowania i przetwarzania baz danych.\nFunkcje DBMS:\n\nTworzenie i modyfikacja schematów\nOperacje CRUD (Create, Read, Update, Delete)\nZarządzanie bezpieczeństwem i uprawnieniami\nOptymalizacja zapytań\n\nPrzykłady: MySQL, PostgreSQL, Oracle, SQL Server, SQLite.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#architektura-systemów-baz-danych",
    "href": "lectures/wyklad1.html#architektura-systemów-baz-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Systemy baz danych są zorganizowane według poziomów abstrakcji, co pozwala oddzielić sposób przechowywania danych od ich widoku dla użytkownika.\n\n\n\nPoziom fizyczny (wewnętrzny)\n\n\nopisuje sposób przechowywania danych (pliki, indeksy, struktury).\n\n\nPoziom logiczny (pośredni)\n\n\nopisuje strukturę danych (tabele, relacje, typy danych).\n\n\nPoziom zewnętrzny (widok użytkownika)\n\n\npokazuje dane z perspektywy użytkownika lub aplikacji.\n\nZmiany w jednym poziomie nie wymagają zmian w pozostałych — to tzw. niezależność danych.\n\n\n\nFormalny model trójpoziomowy:\n\npoziom wewnętrzny – fizyczne przechowywanie danych,\npoziom pojęciowy – logiczna struktura bazy,\npoziom zewnętrzny – widoki użytkowników.\n\nZalety:\n\nizolacja danych,\nbezpieczeństwo,\nelastyczność i skalowalność.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#model-relacyjny",
    "href": "lectures/wyklad1.html#model-relacyjny",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "TABELA to:\n\nZbiór danych o tej samej strukturze.\nUporządkowana lista zawierająca dane określonego typu\n\nKażda tabela opisuje jeden typ obiektów (np. Studenci, Kursy).\nNajwazniejsze, ze tabela przechowuje dane jednego typu. W jednej tabeli nie pojawi się jednocześnie lista kontaktów i lista zamówień. &gt; Uwaga: Technicznie taka tabela jest mozliwa do realizacji ale pobieranie konkretnych elementów &gt; byłoby znacznie utrudnione.\n\nUwaga: Kazda tabela posiada nazwę pozwalającą jednoznacznie ją zidentyfikować. Nazwa zawsze jest unikalna - zadna inna tabela nie moze mieć takiej samej nazwy.\n\n\n\n\nPojedynczy rekord w tabeli (np. dane jednego studenta).\n\n\n\nWłaściwość obiektu – ma nazwę i typ danych (np. Imię, Nazwisko, NrIndeksu).\n\n\n\nZbiór dopuszczalnych wartości atrybutu (np. liczby całkowite, ciągi znaków do 50 znaków).\n\n\n\n\nSchemat relacji – struktura tabeli (nazwy kolumn, typy).\nInstancja relacji – aktualna zawartość tabeli.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#klucze-i-integralność-danych",
    "href": "lectures/wyklad1.html#klucze-i-integralność-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "jednoznacznie identyfikuje każdy rekord,\nnie może mieć wartości NULL.\n\nPrzykład: NrIndeksu w tabeli Studenci.\n\n\n\n\nkażdy atrybut (lub ich kombinacja), który mógłby być kluczem głównym. Przykład: NrIndeksu i PESEL – wybieramy jeden jako główny.\n\n\n\n\n\natrybut wskazujący na klucz główny w innej tabeli. Przykład: NrIndeksu w tabeli Oceny odnosi się do Studenci.\n\n\n\n\n\nIntegralność encji – każda krotka musi być jednoznacznie identyfikowana.\nIntegralność referencyjna – wartości kluczy obcych muszą istnieć w tabelach nadrzędnych.\nIntegralność dziedzinowa – wartości atrybutów muszą mieścić się w swoich domenach.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#zestaw-pytań-testowych",
    "href": "lectures/wyklad1.html#zestaw-pytań-testowych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Kto zaproponował model relacyjny danych?\n\n\nDonald Knuth\nEdgar F. Codd\nBill Gates\nCharles Bachman\n\n\nCo opisuje poziom logiczny w architekturze ANSI/SPARC?\n\n\nSposób fizycznego zapisu danych\nWidok danych przez użytkownika\nStrukturę danych i relac\n\n✏️ Pytania otwarte / opisowe\n\nWyjaśnij różnicę między danymi a informacją.\nWymień i krótko opisz trzy poziomy abstrakcji w modelu ANSI/SPARC.\nCo to jest klucz główny i jakie są jego cechy?\nPodaj przykład relacji i wskaż w niej krotki oraz atrybuty.\nDlaczego model relacyjny okazał się przełomem w historii baz danych?\nJakie są trzy podstawowe zasady integralności danych?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "",
    "text": "Każdy projekt bazy danych zaczyna się od zrozumienia czego oczekuje użytkownik. Bez tego łatwo stworzyć system, który jest poprawny technicznie, ale bezużyteczny w praktyce.\nPrzykład 1 – biblioteka\nBiblioteka chce mieć system, który przechowuje dane o:\n\nksiążkach (tytuł, autor, rok wydania, ISBN),\nczytelnikach (imię, nazwisko, numer karty bibliotecznej),\nwypożyczeniach (jaka książka, który czytelnik, kiedy wypożyczona i kiedy oddana).\n\nPrzykład 2 – sklep internetowy\nSklep potrzebuje informacji o:\n\nklientach (imię, adres, e-mail),\nproduktach (nazwa, cena, kategoria),\nzamówieniach (który klient, jakie produkty, kiedy złożono, status zamówienia).\n\n👉 Zwróć uwagę:\n\nw bibliotece najważniejszy jest związek wypożyczeń,\nw sklepie – związek zamówień.\n\nJuż na tym etapie widać, że kluczowe są powiązania, a nie tylko same dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#analiza-wymagań-użytkownika",
    "href": "lectures/wyklad2.html#analiza-wymagań-użytkownika",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "",
    "text": "Każdy projekt bazy danych zaczyna się od zrozumienia czego oczekuje użytkownik. Bez tego łatwo stworzyć system, który jest poprawny technicznie, ale bezużyteczny w praktyce.\nPrzykład 1 – biblioteka\nBiblioteka chce mieć system, który przechowuje dane o:\n\nksiążkach (tytuł, autor, rok wydania, ISBN),\nczytelnikach (imię, nazwisko, numer karty bibliotecznej),\nwypożyczeniach (jaka książka, który czytelnik, kiedy wypożyczona i kiedy oddana).\n\nPrzykład 2 – sklep internetowy\nSklep potrzebuje informacji o:\n\nklientach (imię, adres, e-mail),\nproduktach (nazwa, cena, kategoria),\nzamówieniach (który klient, jakie produkty, kiedy złożono, status zamówienia).\n\n👉 Zwróć uwagę:\n\nw bibliotece najważniejszy jest związek wypożyczeń,\nw sklepie – związek zamówień.\n\nJuż na tym etapie widać, że kluczowe są powiązania, a nie tylko same dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#diagramy-encjazwiązek",
    "href": "lectures/wyklad2.html#diagramy-encjazwiązek",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Diagramy encja–związek",
    "text": "Diagramy encja–związek\nModel ERD (Entity–Relationship Diagram) pozwala w przejrzysty sposób przedstawić jakie obiekty istnieją w systemie i jak są ze sobą powiązane.\n\nEncje rysujemy jako prostokąty.\nPrzykład: „Student”, „Książka”, „Zamówienie”.\nAtrybuty zapisujemy jako elipsy i łączymy z encją.\n„Student” → Imię, Nazwisko, NrIndeksu.\nZwiązki przedstawiamy jako romby.\n„Student” \\(\\to\\) „Wypożycza” \\(\\to\\) „Książka”.\n\nPrzykład wizualny do opowiedzenia:\n\nWyobraźcie sobie trzy prostokąty: „Student”, „Książka” i „Bibliotekarz”.\nŁączymy je rombem „Wypożycza”.\nDodajemy atrybuty: do studenta „NrIndeksu”, do książki „ISBN”, a do związku „Data wypożyczenia”.\n\n👉 Dzięki temu widzimy nie tylko obiekty, ale i relacje między nimi.\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#typy-związków",
    "href": "lectures/wyklad2.html#typy-związków",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Typy związków",
    "text": "Typy związków\nZwiązek 1:1 (jeden do jednego)\n\nKażdy obiekt jednej encji odpowiada najwyżej jednemu obiektowi drugiej encji.\nPrzykład: każdy człowiek ma jedno unikalne PESEL.\n\nZwiązek 1:N (jeden do wielu)\n\nJeden obiekt encji A może być powiązany z wieloma obiektami encji B, ale nie odwrotnie.\nPrzykład: jeden wykładowca prowadzi wiele kursów, ale każdy kurs ma dokładnie jednego prowadzącego.\n\nZwiązek N:M (wiele do wielu)\n\nJeden obiekt encji A może być powiązany z wieloma obiektami encji B i odwrotnie.\nPrzykład: studenci zapisują się na wiele kursów, a każdy kurs realizowany jest przez wielu studentów.\n\nMini-case: kino\n\nEncje: „Film”, „Widz”, „Seans”.\nWidzowie mogą oglądać wiele filmów, a każdy film może być oglądany przez wielu widzów. To klasyczne N:M.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#atrybuty-proste-złożone-wielowartościowe",
    "href": "lectures/wyklad2.html#atrybuty-proste-złożone-wielowartościowe",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Atrybuty proste, złożone, wielowartościowe",
    "text": "Atrybuty proste, złożone, wielowartościowe\n\nAtrybut prosty – nie da się go podzielić: „Data urodzenia”, „PESEL”.\nAtrybut złożony – składa się z mniejszych: „Adres” → „Ulica”, „Kod pocztowy”, „Miasto”.\nAtrybut wielowartościowy – może mieć wiele wartości dla jednej encji: „Numery telefonów” dla jednego studenta.\n\n👉 To ważne, bo w późniejszym projektowaniu relacyjnym atrybut wielowartościowy często trzeba przekształcić w oddzielną tabelę.\nPrzykład:\n\nStudent może mieć wiele adresów e-mail.\nW modelu ER narysujemy atrybut „Email” jako elipsę podwójną.\nW modelu relacyjnym – stworzymy tabelę „AdresyEmail” powiązaną z tabelą „Studenci”.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#przykłady-całościowe",
    "href": "lectures/wyklad2.html#przykłady-całościowe",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Przykłady całościowe",
    "text": "Przykłady całościowe\nNa koniec możemy omówić kilka kompletnych mini-systemów, żeby pokazać różne rodzaje encji, związków i atrybutów.\nPrzykład A – System rezerwacji hotelu\n\nEncje: „Pokój”, „Gość”, „Rezerwacja”.\nZwiązki: Gość „rezerwuje” Pokój.\nAtrybuty: Rezerwacja ma datę początku, datę końca i status.\n\nPrzykład B – Uczelnia\n\nEncje: „Student”, „Kurs”, „Wykładowca”.\nZwiązki: Student „zapisuje się na” Kurs, Wykładowca „prowadzi” Kurs.\nAtrybuty: Student – imię, nazwisko, nr indeksu. Kurs – nazwa, punktacja ECTS.\n\nPrzykład C – Sklep internetowy\n\nEncje: „Klient”, „Produkt”, „Zamówienie”.\nZwiązki: Klient „składa” Zamówienie, Zamówienie „zawiera” Produkt.\nAtrybuty: Produkt – cena, opis; Zamówienie – data, status.\n\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#podsumowanie",
    "href": "lectures/wyklad2.html#podsumowanie",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Podsumowanie",
    "text": "Podsumowanie\n\nProjektowanie bazy danych zaczynamy od analizy wymagań użytkownika.\nModel ER pozwala uporządkować wiedzę w postaci encje–atrybuty–związki.\nWyróżniamy związki 1:1, 1:N, N:M oraz atrybuty proste, złożone i wielowartościowe.\nDiagram ERD to narzędzie komunikacji – łączy świat użytkownika ze światem projektanta i programisty.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "Ben Forta - SQL w mnieniu oka. Helion. 2020.\nThomas Nield - Pierwsze kroki z SQL. Praktyczne podejście dla początkujących. O’Reilly: 2016"
  },
  {
    "objectID": "ksiazki.html#książki",
    "href": "ksiazki.html#książki",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "Ben Forta - SQL w mnieniu oka. Helion. 2020.\nThomas Nield - Pierwsze kroki z SQL. Praktyczne podejście dla początkujących. O’Reilly: 2016"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: zimowy",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#projektowanie-relacyjnych-baz-danych",
    "href": "index.html#projektowanie-relacyjnych-baz-danych",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: zimowy",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogólne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykład WEL21EA1S0:\n\n\n02.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n06.10.2025 Poniedziałek 8.00 - 9.30. b 61 s 104\n\n\n09.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n16.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n21.10.2025 Wtorek 8.00 - 9.35 b 61 s 116\n\n27.10.2025 Poniedziałek 9.50 - 11.25 b 61 s 104\n30.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n\nLaboratorium:",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "",
    "text": "Celem dzisiejszego wykładu jest pokazanie, jak przejść od koncepcyjnego modelu ERD (Entity–Relationship Diagram), który opisuje co chcemy przechowywać, do modelu relacyjnego, który mówi jak te dane będą fizycznie zorganizowane w tabelach.\n👉 Innymi słowy — dziś „przekładamy” logikę świata rzeczywistego na język tabel, kolumn i kluczy.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#cel-wykładu",
    "href": "lectures/wyklad3.html#cel-wykładu",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "",
    "text": "Celem dzisiejszego wykładu jest pokazanie, jak przejść od koncepcyjnego modelu ERD (Entity–Relationship Diagram), który opisuje co chcemy przechowywać, do modelu relacyjnego, który mówi jak te dane będą fizycznie zorganizowane w tabelach.\n👉 Innymi słowy — dziś „przekładamy” logikę świata rzeczywistego na język tabel, kolumn i kluczy.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#wprowadzenie",
    "href": "lectures/wyklad3.html#wprowadzenie",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "1. Wprowadzenie",
    "text": "1. Wprowadzenie\nZacznijmy od prostego pytania do grupy:\n„Czy narysowany diagram ERD to już baza danych?”\nWiększość studentów odpowie, że nie — i mają rację. ERD to tylko opis pojęć i powiązań między nimi, coś w rodzaju mapy koncepcyjnej. Dopiero model relacyjny pozwala tę mapę zaimplementować w systemie DBMS – czyli stworzyć konkretne tabele, relacje i klucze.\n\nPrzykład porównawczy:\nERD to jak plan architektoniczny domu.\nModel relacyjny to już projekt budowlany z wymiarami i materiałami.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#przypomnienie-podstawowych-pojęć",
    "href": "lectures/wyklad3.html#przypomnienie-podstawowych-pojęć",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Przypomnienie podstawowych pojęć",
    "text": "Przypomnienie podstawowych pojęć\nZanim przejdziemy do reguł, powtórzmy szybko:\n\nEncja – obiekt, o którym przechowujemy dane (np. Student, Kurs, Produkt).\nAtrybut – właściwość tego obiektu (np. imię, nazwisko, cena).\nZwiązek (relationship) – powiązanie między encjami (np. Student zapisuje się na Kurs).\nKrotka (tuple) – pojedynczy wiersz tabeli (np. dane jednego studenta).\nDomena – dopuszczalne wartości dla atrybutu (np. liczby od 1 do 5 dla oceny).\n\n👉 Wszystkie te pojęcia znajdą swoje odpowiedniki w modelu relacyjnym.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#proces-mapowania-transformacji",
    "href": "lectures/wyklad3.html#proces-mapowania-transformacji",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Proces mapowania (transformacji)",
    "text": "Proces mapowania (transformacji)\nTeraz przechodzimy do sedna: jak zamienić ERD w zestaw tabel.\nMożna to potraktować jak przepis: krok po kroku.\n\n🔹 1. Encje \\(\\to\\) Tabele\nKażda encja z modelu ER staje się tabelą w modelu relacyjnym.\nKażdy atrybut encji staje się kolumną.\nWyobraźmy sobie, że prostokąty z diagramu ER zamieniamy w tabele SQL.\nWszystkie elipsy (atrybuty) stają się kolumnami.\nPrzykład:\n\nEncja: STUDENT (NrIndeksu, Imię, Nazwisko, RokStudiow)\n\nRelacja: STUDENT(NrIndeksu, Imię, Nazwisko, RokStudiow)\n\n\n🔹 2. Atrybuty złożone\nAtrybut złożony to taki, który sam składa się z kilku części.\nW modelu relacyjnym nie ma takiej konstrukcji, więc trzeba go rozbić.\nPrzykład:\nAdres = (Ulica, KodPocztowy, Miasto)\n„Zauważmy, że dzięki temu możemy np. wyszukiwać po samym mieście, co nie byłoby możliwe, gdyby cały adres był jednym polem tekstowym.”\n\n\n🔹 3. Atrybuty wielowartościowe\nAtrybut wielowartościowy to taki, który może mieć więcej niż jedną wartość dla jednej encji.\nPrzykład: Student może mieć wiele adresów e-mail.\nW modelu relacyjnym nie możemy trzymać wielu wartości w jednej kolumnie, więc: ➡️ Tworzymy osobną tabelę.\nEMAIL(NrIndeksu, Email)\n\nKlucz główny: (NrIndeksu, Email)\nNrIndeksu to klucz obcy do tabeli STUDENT.\n\n„To moment, w którym ERD zaczyna się rozrastać — z jednej encji robią się dwie tabele.\nAle dzięki temu baza pozostaje spójna i czytelna.”\n\n\n🔹 4. Związki 1:1\nZwiązek „jeden do jednego” oznacza, że każdemu rekordowi z jednej tabeli odpowiada najwyżej jeden rekord z drugiej.\nPrzykład:\n\nKażda osoba ma dokładnie jeden paszport.\n\nOSOBA(PESEL, Imię, Nazwisko)\nPASZPORT(NrPaszportu, DataWażności, PESEL)\nDodajemy PESEL jako klucz obcy w tabeli PASZPORT.\n„Jeśli obie strony są naprawdę w relacji 1:1, można też rozważyć połączenie tych tabel — ale zwykle zostawia się je osobno, gdy przechowują różne grupy informacji\n\n\n🔹 5. Związki 1:N\nTo najczęstszy przypadek w praktyce.\nPrzykład: Jeden wykładowca prowadzi wiele kursów.\nWYKŁADOWCA(IDWykładowcy, Imię, Nazwisko)\nKURS(IDKursu, Nazwa, IDWykładowcy)\nIDWykładowcy w tabeli KURS jest kluczem obcym.\n„Pamiętajcie: klucz obcy zawsze dodajemy po stronie N, czyli po tej, gdzie może być więcej rekordów.”\n\n\n🔹 6. Związki N:M\nTo przypadek „wiele do wielu” — np. student może uczestniczyć w wielu kursach, a każdy kurs ma wielu studentów.\nW tym wypadku nie da się dodać klucza obcego do jednej z tabel, więc tworzymy tabelę pośredniczącą.\nSTUDENT(NrIndeksu, Imię, Nazwisko)\nKURS(IDKursu, Nazwa)\nZAPIS(NrIndeksu, IDKursu, DataZapisu)\n„Ta trzecia tabela to tak naprawdę odwzorowanie związku. Dzięki niej możemy np. zapisać dodatkowe informacje o relacji — np. datę zapisania się na kurs.”\n\n\n5. Jak projektować dobre tabele?\nKiedy masz już relacje, czas je zdefiniować w SQL.\nTu warto podkreślić kilka zasad:\n\nCzytelne nazwy (jednolite, najlepiej w liczbie pojedynczej).\nTypy danych dopasowane do zawartości.\nOgraniczenia (constraints):\nPRIMARY KEY – jednoznaczna identyfikacja,\nFOREIGN KEY – zapewnia spójność,\nNOT NULL, UNIQUE, CHECK – wymuszają poprawność danych.\n\nPrzykład SQL:\nCREATE TABLE STUDENT (\n  NrIndeksu CHAR(6) PRIMARY KEY,\n  Imie VARCHAR(30) NOT NULL,\n  Nazwisko VARCHAR(40) NOT NULL\n);\n„To dopiero teraz jest konkretna implementacja — coś, co można utworzyć w PostgreSQL, MySQL czy Oracle.\nAle zanim napiszemy SQL, zawsze powinniśmy mieć dobrze przemyślany model relacyjny.”\n\n\n6. Ćwiczenie praktyczne\n\nZadanie: Zaprojektuj schemat relacyjny dla firmy, w której pracownicy realizują projekty. Każdy projekt ma wielu pracowników, a każdy pracownik może uczestniczyć w wielu projektach. Dodatkowo pamiętamy od kiedy pracownik uczestniczy w projekcie.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#podsumowanie",
    "href": "lectures/wyklad3.html#podsumowanie",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Podsumowanie:",
    "text": "Podsumowanie:\n„Dziś nauczyliśmy się tłumaczyć język analityków (ERD) na język baz danych (model relacyjny).”\n\nEncje → tabele\nAtrybuty → kolumny\nZwiązki → klucze obce lub tabele pośrednie\nAtrybuty złożone → rozbijamy\nAtrybuty wielowartościowe → osobne tabele\n\n👉 W kolejnym wykładzie przejdziemy do normalizacji, czyli porządkowania tabel, by unikać błędów i redundancji.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html",
    "href": "lectures/wyklad4.html",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKażdy wiersz (row) = rekord / krotka\n\nKażda kolumna (column) = atrybut\n\nDziedzina (domain) = zbiór dopuszczalnych wartości w kolumnie\n\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "href": "lectures/wyklad4.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKażdy wiersz (row) = rekord / krotka\n\nKażda kolumna (column) = atrybut\n\nDziedzina (domain) = zbiór dopuszczalnych wartości w kolumnie\n\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#klucze-i-więzy-integralności",
    "href": "lectures/wyklad4.html#klucze-i-więzy-integralności",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "2️⃣ Klucze i więzy integralności",
    "text": "2️⃣ Klucze i więzy integralności\n\n🔸 Klucz główny (PRIMARY KEY)\n\nUnikalnie identyfikuje każdy wiersz w tabeli.\nNie może być NULL.\n\n\n\n🔸 Klucz obcy (FOREIGN KEY)\n\nOdwołuje się do innej tabeli (relacja między tabelami).\n\n\n\n🔸 Inne więzy:\n\nUNIQUE – unikalność wartości w kolumnie.\nNOT NULL – kolumna nie może mieć wartości pustej.\nCHECK – warunek logiczny na wartość kolumny.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#schemat-bazy-danych-przykład-biblioteka",
    "href": "lectures/wyklad4.html#schemat-bazy-danych-przykład-biblioteka",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "3️⃣ Schemat bazy danych – przykład „Biblioteka”",
    "text": "3️⃣ Schemat bazy danych – przykład „Biblioteka”\n\nTabele:\n\nAutorzy (autor_id, imie, nazwisko)\nKsiazki (ksiazka_id, tytul, rok, autor_id)\n\n\n\nRelacja:\n\nKsiazki.autor_id \\(\\to\\) Autorzy.autor_id (klucz obcy)",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#tworzenie-tabel-ddl-data-definition-language",
    "href": "lectures/wyklad4.html#tworzenie-tabel-ddl-data-definition-language",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "4️⃣ Tworzenie tabel (DDL – Data Definition Language)",
    "text": "4️⃣ Tworzenie tabel (DDL – Data Definition Language)\nPolecenie CREATE TABLE służy do utworzenia nowej tabeli w bazie danych.\nW tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz różne więzy integralności, takie jak PRIMARY KEY, NOT NULL czy FOREIGN KEY.\nKażda tabela powinna mieć kolumnę, która jednoznacznie identyfikuje każdy wiersz – to właśnie klucz główny.\nW przykładzie poniżej tworzymy dwie tabele: Autorzy i Ksiazki, które będą ze sobą powiązane relacją klucz główny–klucz obcy.\n\nPrzykład w SQLite i PostgreSQL\nCREATE TABLE Autorzy (\n    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT\n    imie         TEXT NOT NULL,\n    nazwisko     TEXT NOT NULL\n);\n\nCREATE TABLE Ksiazki (\n    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja\n    tytul        VARCHAR(200) NOT NULL,\n    rok          INTEGER CHECK (rok &gt; 0),\n    autor_id     INTEGER,\n    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)\n);\n\nW SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.\nW PostgreSQL SERIAL lub GENERATED ALWAYS AS IDENTITY.\n\nW powyższym przykładzie tabela Autorzy przechowuje dane o autorach, a tabela Ksiazki – dane o książkach. Kolumna autor_id w tabeli Ksiazki jest kluczem obcym i wskazuje, który autor napisał daną książkę. Dzięki więzom integralności baza pilnuje, aby każda książka miała poprawnego autora. Takie powiązania są podstawą modelu relacyjnego.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#modyfikacja-i-usuwanie-tabel",
    "href": "lectures/wyklad4.html#modyfikacja-i-usuwanie-tabel",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "5️⃣ Modyfikacja i usuwanie tabel",
    "text": "5️⃣ Modyfikacja i usuwanie tabel\nALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;\n\nDROP TABLE Ksiazki;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#wstawianie-danych-dml-data-manipulation-language",
    "href": "lectures/wyklad4.html#wstawianie-danych-dml-data-manipulation-language",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "6️⃣ Wstawianie danych (DML – Data Manipulation Language)",
    "text": "6️⃣ Wstawianie danych (DML – Data Manipulation Language)\nPolecenie INSERT INTO służy do wprowadzania nowych wierszy (rekordów) do tabeli. Wartości muszą być zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.). Można dodać jeden lub wiele rekordów w jednym poleceniu. Poniżej wstawiamy kilku autorów oraz ich książki do utworzonych wcześniej tabel.\nINSERT INTO Autorzy (imie, nazwisko) VALUES\n('Adam', 'Mickiewicz'),\n('Henryk', 'Sienkiewicz'),\n('Bolesław', 'Prus');\n\nINSERT INTO Ksiazki (tytul, rok, autor_id) VALUES\n('Pan Tadeusz', 1834, 1),\n('Quo Vadis', 1896, 2),\n('Lalka', 1890, 3);\nKażdy rekord reprezentuje jedną pozycję w tabeli. Polecenie INSERT wymaga podania wartości w tej samej kolejności, w jakiej wymieniono kolumny. Jeśli nie podamy jakiejś kolumny, a ma ona zdefiniowaną wartość domyślną (DEFAULT), baza wstawi ją automatycznie. Dzięki temu możemy stopniowo budować zawartość naszej bazy danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#wybieranie-danych-select",
    "href": "lectures/wyklad4.html#wybieranie-danych-select",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "7️⃣ Wybieranie danych – SELECT",
    "text": "7️⃣ Wybieranie danych – SELECT\n\n🧩 Podstawowy SELECT\nPolecenie SELECT jest najczęściej używanym poleceniem SQL i służy do pobierania danych z tabel. Pozwala określić, które kolumny chcemy zobaczyć i z których tabel dane mają pochodzić. Jeśli użyjemy gwiazdki *, oznacza to, że wybieramy wszystkie kolumny. Poniższe zapytanie zwraca wszystkich autorów z tabeli Autorzy.\nSELECT * FROM Autorzy;\n\n\n🧩 Wybór konkretnych kolumn\nSELECT imie, nazwisko FROM Autorzy;\nWynik to pełna tabela z kolumnami autor_id, imie i nazwisko. Często jednak potrzebujemy tylko części danych, np. imienia i nazwiska – wtedy podajemy konkretne kolumny:\n\n\n🧩 Nadawanie aliasów\nSELECT imie AS \"Imię\", nazwisko AS \"Nazwisko\" FROM Autorzy;\nTakie zapytania pomagają ograniczyć ilość danych i zwiększyć czytelność wyników. Warto też nadawać aliasy (AS), które pozwalają zmienić nazwę kolumn w wynikach i nadać im bardziej opisowy wygląd.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#filtrowanie-where",
    "href": "lectures/wyklad4.html#filtrowanie-where",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "8️⃣ Filtrowanie – WHERE",
    "text": "8️⃣ Filtrowanie – WHERE\nKiedy chcemy wybrać tylko część danych, używamy klauzuli WHERE. Dzięki niej możemy ustawić warunki, jakie muszą spełniać rekordy, by pojawiły się w wyniku. To bardzo potężne narzędzie, które pozwala np. wyszukiwać książki z konkretnego roku lub autora. W poniższym przykładzie wybieramy książki wydane po roku 1850.\nSELECT * FROM Ksiazki\nWHERE rok &gt; 1850;\n\n🧠 Operatory:\nMożemy też stosować inne operatory:\n\n=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=\nLIKE ‘Q%’ → zaczyna się na Q\nIN (…)\nBETWEEN 1800 AND 1900\nIS NULL, IS NOT NULL\n\nNa przykład, aby znaleźć wszystkie książki, których tytuł zawiera literę „a”, używamy wzorca z LIKE:\nSELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';\nKlauzula WHERE pozwala więc filtrować dane na wiele sposobów, co czyni zapytania SQL bardzo elastycznymi.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#sortowanie-order-by",
    "href": "lectures/wyklad4.html#sortowanie-order-by",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "9️⃣ Sortowanie – ORDER BY",
    "text": "9️⃣ Sortowanie – ORDER BY\nPo pobraniu danych często chcemy uporządkować je według określonego kryterium. Do tego służy klauzula ORDER BY, dzięki której możemy sortować rosnąco (ASC) lub malejąco (DESC). Sortowanie działa na dowolnej kolumnie, także tych, które nie są wyświetlane w wyniku. W przykładzie poniżej porządkujemy książki według roku wydania od najnowszej do najstarszej.\nSELECT * FROM Ksiazki ORDER BY rok DESC;\nJeśli nie podamy kierunku sortowania, domyślnie jest to ASC (rosnąco). Można też sortować według kilku kolumn jednocześnie, np. najpierw po autorze, a potem po roku. Sortowanie poprawia czytelność wyników i pozwala szybciej analizować dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#grupowanie-i-agregacja-group-by-having",
    "href": "lectures/wyklad4.html#grupowanie-i-agregacja-group-by-having",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "🔟 Grupowanie i agregacja – GROUP BY, HAVING",
    "text": "🔟 Grupowanie i agregacja – GROUP BY, HAVING\nCzasem chcemy policzyć, ile danych należy do danej kategorii – np. ilu autorów napisało więcej niż jedną książkę. Do tego służy GROUP BY, które grupuje dane według wybranej kolumny. W połączeniu z funkcjami agregującymi, takimi jak COUNT(), AVG(), SUM(), MIN() czy MAX(), daje duże możliwości analizy. Klauzula HAVING pozwala odfiltrować grupy po obliczeniu agregacji.\nSELECT autor_id, COUNT(*) AS liczba_ksiazek\nFROM Ksiazki\nGROUP BY autor_id\nHAVING COUNT(*) &gt; 1;\nTo zapytanie zwraca tylko tych autorów, którzy mają więcej niż jedną książkę. Różnica między WHERE a HAVING polega na tym, że WHERE filtruje pojedyncze wiersze przed grupowaniem, a HAVING filtruje całe grupy po agregacji. Wyniki można potem łączyć z innymi tabelami, by uzyskać bardziej opisowe raporty.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#łączenie-tabel-join",
    "href": "lectures/wyklad4.html#łączenie-tabel-join",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "1️⃣1️⃣ Łączenie tabel – JOIN",
    "text": "1️⃣1️⃣ Łączenie tabel – JOIN\nW relacyjnym modelu danych informacje są rozproszone w różnych tabelach, które łączy się przy pomocy kluczy obcych. Polecenie JOIN pozwala zestawić dane z kilku tabel na podstawie wspólnej kolumny. Najczęściej używany jest INNER JOIN, który zwraca tylko rekordy, dla których istnieje dopasowanie w obu tabelach. W przykładzie łączymy tabelę Ksiazki z Autorzy, aby zobaczyć tytuł książki i jej autora.\n\n🔹 INNER JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\nWynikiem będzie lista książek wraz z imieniem i nazwiskiem autora. Jeśli chcemy, aby w wynikach pojawiły się także książki bez autora (lub autorzy bez książek), używamy odpowiednio LEFT JOIN lub RIGHT JOIN. Łączenie tabel to fundament relacyjnych baz danych – dzięki niemu dane są spójne i nie trzeba ich powielać.\n\n\n🔹 LEFT JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nLEFT JOIN Autorzy a ON k.autor_id = a.autor_id;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#aktualizacja-i-usuwanie-danych",
    "href": "lectures/wyklad4.html#aktualizacja-i-usuwanie-danych",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "1️⃣2️⃣ Aktualizacja i usuwanie danych",
    "text": "1️⃣2️⃣ Aktualizacja i usuwanie danych\nPolecenie UPDATE pozwala modyfikować dane już istniejące w tabeli. Zawsze należy używać klauzuli WHERE, aby zmiana nie objęła wszystkich rekordów. Z kolei DELETE służy do usuwania rekordów – również z warunkiem, by nie usunąć wszystkiego przez pomyłkę. Przykład poniżej pokazuje, jak zmienić rok wydania książki i usunąć starsze pozycje.\nUPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';\n\nDELETE FROM Ksiazki WHERE rok &lt; 1850;\nUPDATE pozwala też aktualizować wiele kolumn naraz, a nawet wykonywać obliczenia. Z kolei DELETE usuwa rekordy z tabeli, ale nie zmienia struktury bazy. Warto zawsze testować warunek WHERE wcześniej przy pomocy SELECT, by uniknąć niechcianych usunięć.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#podsumowanie",
    "href": "lectures/wyklad4.html#podsumowanie",
    "title": "Model Relacyjny i podstawy SQL",
    "section": "Podsumowanie",
    "text": "Podsumowanie\nSQL jest językiem deklaratywnym – opisujemy co chcemy uzyskać, a nie jak to zrobić. Dzięki temu użytkownik nie musi znać szczegółów działania bazy danych, wystarczy, że opisze warunki i strukturę zapytania. Poznane dziś polecenia (CREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY) to fundament pracy z bazami danych. Opanowanie ich pozwala budować i analizować nawet bardzo złożone systemy informacyjne.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model Relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html",
    "href": "lectures/wyklad7.html",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Podzapytanie to zapytanie wewnątrz innego zapytania SQL. Służy do wykonywania bardziej złożonych operacji, kiedy jedno zapytanie potrzebuje wyników innego.\nMożemy je traktować jak „mini-zapytania”, które dostarczają danych do zapytania głównego.\nPodzapytania mogą występować w różnych miejscach:\n\nw klauzuli WHERE – do filtrowania danych,\nw klauzuli FROM – jako tymczasowa tabela,\nw klauzuli SELECT – do obliczeń w każdej krotce,\nw konstrukcjach EXISTS, IN, ALL, ANY – do testowania warunków logicznych.\n\n\n\nTo najczęstszy typ podzapytania.\nZapytanie główne wybiera dane na podstawie wartości zwróconej przez podzapytanie.\n\n\nZnajdź książki napisane przez autora o nazwisku Sienkiewicz.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id = (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko = 'Sienkiewicz'\n);\n\n\n\n\nPodzapytanie wewnętrzne szuka identyfikatora autora autor_id, którego nazwisko to Sienkiewicz.\nZapytanie główne wybiera z tabeli Ksiazki tylko te rekordy, w których autor_id jest równy wynikowi podzapytania.\n\n\n🔸 Takie podzapytanie musi zwrócić jedną wartość (scalar subquery) – w przeciwnym razie wystąpi błąd.\n\n\n\n\n\nJeśli podzapytanie zwraca więcej niż jeden rekord, używamy operatora IN.\n\n\nZnajdź wszystkie książki autorów, których nazwiska zaczynają się na literę M.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id IN (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko LIKE 'M%'\n);\n\n\n\n\nPodzapytanie wewnętrzne zwraca listę identyfikatorów autorów, np. [1, 5, 7].\nZapytanie główne wybiera książki, których autor_id znajduje się na tej liście.\n\n\n🔸 Operator IN można traktować jak porównanie z „wieloma wartościami jednocześnie”.\n\n\n\n\n\nPodzapytanie może też zwracać pojedynczą wartość (skalarną) i być użyte w liście kolumn.\n\n\nWyświetl listę autorów wraz z liczbą ich książek.\nSELECT\n    a.imie,\n    a.nazwisko,\n    (\n        SELECT COUNT(*)\n        FROM Ksiazki k\n        WHERE k.autor_id = a.autor_id\n    ) AS liczba_ksiazek\nFROM Autorzy a;\n\n\n\n\nDla każdego autora (a.autor_id) wykonuje się osobne podzapytanie, które liczy książki przypisane do tego autora.\nWynik jest dodawany jako nowa kolumna liczba_ksiazek.\n\n\n🔸 To tzw. podzapytanie skorelowane (correlated subquery), ponieważ odnosi się do kolumny z zapytania głównego.\n\n\n\n\n\nPodzapytanie może tworzyć tymczasową tabelę w sekcji FROM. Takie rozwiązanie nazywa się derived table i pozwala na pracę z przetworzonymi danymi.\n\n\nPolicz średni rok wydania książek, a następnie wybierz te, które są starsze od średniej.\nSELECT tytul, rok\nFROM (\n    SELECT *\n    FROM Ksiazki\n) AS K\nWHERE K.rok &lt; (\n    SELECT AVG(rok) FROM Ksiazki\n);\n\n\n\n\nPodzapytanie w FROM tworzy tymczasową tabelę K.\nW klauzuli WHERE używamy innego podzapytania, które liczy średni rok wydania.\nWynik to książki starsze od średniej publikacji.\n\n\n\n\n\nTo podzapytanie, które odwołuje się do kolumn z zapytania głównego. Wykonuje się dla każdego wiersza osobno – dlatego bywa wolniejsze, ale bardzo elastyczne.\n\n\nZnajdź najstarszą książkę każdego autora.\nSELECT k.tytul, k.rok, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id\nWHERE k.rok = (\n    SELECT MIN(rok)\n    FROM Ksiazki\n    WHERE autor_id = k.autor_id\n);\n\n\n\n\nDla każdego wiersza w tabeli Ksiazki podzapytanie szuka najmniejszego roku dla tego samego autora.\nPorównanie k.rok = (MIN(rok)) sprawia, że zostaje tylko najstarsza książka każdego autora.\n\n\n\n\n\nOperator EXISTS sprawdza, czy podzapytanie zwróciło jakiekolwiek wiersze. Nie liczy ich — interesuje nas jedynie, czy wynik istnieje (TRUE/FALSE).\n\n\nZnajdź autorów, którzy napisali przynajmniej jedną książkę.\nSELECT imie, nazwisko\nFROM Autorzy a\nWHERE EXISTS (\n    SELECT 1\n    FROM Ksiazki k\n    WHERE k.autor_id = a.autor_id\n);\n\n\n\n\nDla każdego autora sprawdzane jest, czy istnieje co najmniej jeden wiersz w tabeli Ksiazki z tym samym autor_id.\nJeśli tak — warunek EXISTS zwraca TRUE, a autor pojawia się w wyniku.\n\n\n\n\n\nOperator ALL wymaga, aby warunek był spełniony dla wszystkich wyników podzapytania. Operator ANY (lub SOME) – aby warunek był spełniony dla przynajmniej jednego.\n\n\nZnajdź książki wydane wcześniej niż wszystkie książki Prusa.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE rok &lt; ALL (\n    SELECT rok\n    FROM Ksiazki\n    WHERE autor_id = (\n        SELECT autor_id FROM Autorzy WHERE nazwisko = 'Prus'\n    )\n);\n\n\n\n\nPodzapytanie wewnętrzne zwraca lata publikacji książek Prusa.\nZapytanie główne wybiera tylko te książki, których rok jest mniejszy niż wszystkie te wartości.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTyp podzapytania\nMiejsce użycia\nZwracany wynik\nTypowe operatory\nPrzykład zastosowania\n\n\n\n\nJednowartościowe (scalar)\nWHERE, SELECT\nPojedyncza wartość (1 rekord, 1 kolumna)\n=, &lt;, &gt;\nAutor o nazwisku „Sienkiewicz”\n\n\nWielowartościowe (multivalue)\nWHERE\nLista wartości (wiele rekordów)\nIN, NOT IN\nAutorzy, których nazwisko zaczyna się na „M”\n\n\nKorelowane (correlated)\nWHERE, SELECT\nZmienny wynik dla każdego wiersza\n=, EXISTS\nNajstarsza książka danego autora\n\n\nZagnieżdżone w FROM (tabela pochodna)\nFROM\nZbiór wierszy (tymczasowa tabela)\n—\nŚredni rok wydania książek i porównanie ze średnią\n\n\nZ operatorem EXISTS / NOT EXISTS\nWHERE\nPrawda / Fałsz (czy istnieje wynik)\nEXISTS, NOT EXISTS\nAutorzy, którzy napisali przynajmniej jedną książkę\n\n\nZ operatorem ALL / ANY / SOME\nWHERE\nPorównanie z wieloma wartościami\nALL, ANY, SOME\nKsiążki starsze niż wszystkie książki Prusa",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-w-klauzuli-where-jednowartościowe",
    "href": "lectures/wyklad7.html#podzapytanie-w-klauzuli-where-jednowartościowe",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "To najczęstszy typ podzapytania.\nZapytanie główne wybiera dane na podstawie wartości zwróconej przez podzapytanie.\n\n\nZnajdź książki napisane przez autora o nazwisku Sienkiewicz.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id = (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko = 'Sienkiewicz'\n);\n\n\n\n\nPodzapytanie wewnętrzne szuka identyfikatora autora autor_id, którego nazwisko to Sienkiewicz.\nZapytanie główne wybiera z tabeli Ksiazki tylko te rekordy, w których autor_id jest równy wynikowi podzapytania.\n\n\n🔸 Takie podzapytanie musi zwrócić jedną wartość (scalar subquery) – w przeciwnym razie wystąpi błąd.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-zwracające-wiele-wartości-operator-in",
    "href": "lectures/wyklad7.html#podzapytanie-zwracające-wiele-wartości-operator-in",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Jeśli podzapytanie zwraca więcej niż jeden rekord, używamy operatora IN.\n\n\nZnajdź wszystkie książki autorów, których nazwiska zaczynają się na literę M.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id IN (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko LIKE 'M%'\n);\n\n\n\n\nPodzapytanie wewnętrzne zwraca listę identyfikatorów autorów, np. [1, 5, 7].\nZapytanie główne wybiera książki, których autor_id znajduje się na tej liście.\n\n\n🔸 Operator IN można traktować jak porównanie z „wieloma wartościami jednocześnie”.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-w-klauzuli-select",
    "href": "lectures/wyklad7.html#podzapytanie-w-klauzuli-select",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Podzapytanie może też zwracać pojedynczą wartość (skalarną) i być użyte w liście kolumn.\n\n\nWyświetl listę autorów wraz z liczbą ich książek.\nSELECT\n    a.imie,\n    a.nazwisko,\n    (\n        SELECT COUNT(*)\n        FROM Ksiazki k\n        WHERE k.autor_id = a.autor_id\n    ) AS liczba_ksiazek\nFROM Autorzy a;\n\n\n\n\nDla każdego autora (a.autor_id) wykonuje się osobne podzapytanie, które liczy książki przypisane do tego autora.\nWynik jest dodawany jako nowa kolumna liczba_ksiazek.\n\n\n🔸 To tzw. podzapytanie skorelowane (correlated subquery), ponieważ odnosi się do kolumny z zapytania głównego.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-w-klauzuli-from-tabela-pochodna",
    "href": "lectures/wyklad7.html#podzapytanie-w-klauzuli-from-tabela-pochodna",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Podzapytanie może tworzyć tymczasową tabelę w sekcji FROM. Takie rozwiązanie nazywa się derived table i pozwala na pracę z przetworzonymi danymi.\n\n\nPolicz średni rok wydania książek, a następnie wybierz te, które są starsze od średniej.\nSELECT tytul, rok\nFROM (\n    SELECT *\n    FROM Ksiazki\n) AS K\nWHERE K.rok &lt; (\n    SELECT AVG(rok) FROM Ksiazki\n);\n\n\n\n\nPodzapytanie w FROM tworzy tymczasową tabelę K.\nW klauzuli WHERE używamy innego podzapytania, które liczy średni rok wydania.\nWynik to książki starsze od średniej publikacji.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#korelowane-podzapytanie-correlated-subquery",
    "href": "lectures/wyklad7.html#korelowane-podzapytanie-correlated-subquery",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "To podzapytanie, które odwołuje się do kolumn z zapytania głównego. Wykonuje się dla każdego wiersza osobno – dlatego bywa wolniejsze, ale bardzo elastyczne.\n\n\nZnajdź najstarszą książkę każdego autora.\nSELECT k.tytul, k.rok, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id\nWHERE k.rok = (\n    SELECT MIN(rok)\n    FROM Ksiazki\n    WHERE autor_id = k.autor_id\n);\n\n\n\n\nDla każdego wiersza w tabeli Ksiazki podzapytanie szuka najmniejszego roku dla tego samego autora.\nPorównanie k.rok = (MIN(rok)) sprawia, że zostaje tylko najstarsza książka każdego autora.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#podzapytanie-z-exists",
    "href": "lectures/wyklad7.html#podzapytanie-z-exists",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Operator EXISTS sprawdza, czy podzapytanie zwróciło jakiekolwiek wiersze. Nie liczy ich — interesuje nas jedynie, czy wynik istnieje (TRUE/FALSE).\n\n\nZnajdź autorów, którzy napisali przynajmniej jedną książkę.\nSELECT imie, nazwisko\nFROM Autorzy a\nWHERE EXISTS (\n    SELECT 1\n    FROM Ksiazki k\n    WHERE k.autor_id = a.autor_id\n);\n\n\n\n\nDla każdego autora sprawdzane jest, czy istnieje co najmniej jeden wiersz w tabeli Ksiazki z tym samym autor_id.\nJeśli tak — warunek EXISTS zwraca TRUE, a autor pojawia się w wyniku.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#porównania-z-all-any",
    "href": "lectures/wyklad7.html#porównania-z-all-any",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "",
    "text": "Operator ALL wymaga, aby warunek był spełniony dla wszystkich wyników podzapytania. Operator ANY (lub SOME) – aby warunek był spełniony dla przynajmniej jednego.\n\n\nZnajdź książki wydane wcześniej niż wszystkie książki Prusa.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE rok &lt; ALL (\n    SELECT rok\n    FROM Ksiazki\n    WHERE autor_id = (\n        SELECT autor_id FROM Autorzy WHERE nazwisko = 'Prus'\n    )\n);\n\n\n\n\nPodzapytanie wewnętrzne zwraca lata publikacji książek Prusa.\nZapytanie główne wybiera tylko te książki, których rok jest mniejszy niż wszystkie te wartości.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTyp podzapytania\nMiejsce użycia\nZwracany wynik\nTypowe operatory\nPrzykład zastosowania\n\n\n\n\nJednowartościowe (scalar)\nWHERE, SELECT\nPojedyncza wartość (1 rekord, 1 kolumna)\n=, &lt;, &gt;\nAutor o nazwisku „Sienkiewicz”\n\n\nWielowartościowe (multivalue)\nWHERE\nLista wartości (wiele rekordów)\nIN, NOT IN\nAutorzy, których nazwisko zaczyna się na „M”\n\n\nKorelowane (correlated)\nWHERE, SELECT\nZmienny wynik dla każdego wiersza\n=, EXISTS\nNajstarsza książka danego autora\n\n\nZagnieżdżone w FROM (tabela pochodna)\nFROM\nZbiór wierszy (tymczasowa tabela)\n—\nŚredni rok wydania książek i porównanie ze średnią\n\n\nZ operatorem EXISTS / NOT EXISTS\nWHERE\nPrawda / Fałsz (czy istnieje wynik)\nEXISTS, NOT EXISTS\nAutorzy, którzy napisali przynajmniej jedną książkę\n\n\nZ operatorem ALL / ANY / SOME\nWHERE\nPorównanie z wieloma wartościami\nALL, ANY, SOME\nKsiążki starsze niż wszystkie książki Prusa",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#tworzenie-widoku",
    "href": "lectures/wyklad7.html#tworzenie-widoku",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "🔹 1. Tworzenie widoku",
    "text": "🔹 1. Tworzenie widoku\nWidok tworzymy za pomocą polecenia CREATE VIEW.\n\nPrzykład:\nUtwórz widok wyświetlający listę książek wraz z nazwiskiem autora.\nCREATE VIEW Widok_Ksiazki_Autorzy AS\nSELECT\n    k.tytul,\n    k.rok,\n    a.imie,\n    a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\n➡️ Po utworzeniu widoku można z niego korzystać tak, jak z każdej innej tabeli:\nSELECT * FROM Widok_Ksiazki_Autorzy;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#widoki-jako-warstwa-abstrakcji",
    "href": "lectures/wyklad7.html#widoki-jako-warstwa-abstrakcji",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "🔹 2. Widoki jako warstwa abstrakcji",
    "text": "🔹 2. Widoki jako warstwa abstrakcji\nWidoki działają jak poziom pośredni między użytkownikiem a fizyczną strukturą bazy danych. Użytkownik nie musi znać szczegółów łączenia tabel, kluczy obcych czy kolumn — wystarczy, że zna nazwę widoku.\n\nPrzykład:\nWidok pokazujący tylko podstawowe dane o książkach:\nCREATE VIEW Widok_Biblioteka_Publiczna AS\nSELECT tytul, rok\nFROM Ksiazki;\n➡️ Użytkownik może wykonać:\nSELECT * FROM Widok_Biblioteka_Publiczna;\ni otrzymać uproszczony zestaw danych bez dostępu do tabel źródłowych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#widoki-oparte-na-podzapytaniach",
    "href": "lectures/wyklad7.html#widoki-oparte-na-podzapytaniach",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "🔹 3. Widoki oparte na podzapytaniach",
    "text": "🔹 3. Widoki oparte na podzapytaniach\nWidoki mogą zawierać podzapytania — dzięki temu można tworzyć widoki analityczne, raportowe, czy agregujące dane.\n\nPrzykład:\nWidok pokazujący liczbę książek napisanych przez każdego autora:\nCREATE VIEW Widok_LiczbaKsiazek AS\nSELECT\n    a.autor_id,\n    a.imie,\n    a.nazwisko,\n    COUNT(k.ksiazka_id) AS liczba_ksiazek\nFROM Autorzy a\nLEFT JOIN Ksiazki k ON a.autor_id = k.autor_id\nGROUP BY a.autor_id, a.imie, a.nazwisko;\n➡️ Następnie możemy wykonać:\nSELECT * FROM Widok_LiczbaKsiazek WHERE liczba_ksiazek &gt; 3;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#aktualizowalność-widoków",
    "href": "lectures/wyklad7.html#aktualizowalność-widoków",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "🔹 4. Aktualizowalność widoków",
    "text": "🔹 4. Aktualizowalność widoków\nNie każdy widok można modyfikować (czyli wykonywać INSERT, UPDATE, DELETE).\nWidoki są aktualizowalne, jeśli:\n\nodnoszą się tylko do jednej tabeli,\nnie zawierają GROUP BY, DISTINCT, UNION, HAVING ani funkcji agregujących,\nnie zawierają podzapytań w klauzuli SELECT.\n\nJeśli widok jest bardziej złożony (np. z JOIN lub GROUP BY), staje się tylko do odczytu.\n\nPrzykład – widok aktualizowalny:\nCREATE VIEW Widok_AutorzyPodstawowi AS\nSELECT autor_id, imie, nazwisko\nFROM Autorzy;\nMożemy:\nUPDATE Widok_AutorzyPodstawowi\nSET nazwisko = 'Nowak'\nWHERE autor_id = 1;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#usuwanie-i-modyfikacja-widoków",
    "href": "lectures/wyklad7.html#usuwanie-i-modyfikacja-widoków",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "🔹 5. Usuwanie i modyfikacja widoków",
    "text": "🔹 5. Usuwanie i modyfikacja widoków\nAby usunąć widok:\nDROP VIEW Widok_LiczbaKsiazek;\nAby zmienić definicję widoku:\nCREATE OR REPLACE VIEW Widok_LiczbaKsiazek AS\nSELECT nazwisko, COUNT(*) AS liczba\nFROM Autorzy a\nJOIN Ksiazki k ON a.autor_id = k.autor_id\nGROUP BY nazwisko;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#zalety-i-wady-widoków",
    "href": "lectures/wyklad7.html#zalety-i-wady-widoków",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "🔹 6. Zalety i wady widoków",
    "text": "🔹 6. Zalety i wady widoków\n✅ Zalety:\n\nUproszczenie złożonych zapytań (abstrakcja)\nZwiększenie bezpieczeństwa – ograniczony dostęp do danych\nReużywalność – jedno miejsce definicji raportu\nMożliwość definiowania logicznych perspektyw danych\n\n⚠️ Wady:\n\nWydajność – każde odwołanie do widoku powoduje wykonanie zapytania źródłowego\nOgraniczona aktualizowalność\nZłożone widoki mogą utrudniać debugowanie i optymalizację\n\n\n🧩 Przykład praktyczny – widok zagnieżdżony\nWidoki można zagnieżdżać – jeden widok może korzystać z innego.\nCREATE VIEW Widok_StarsiAutorzy AS\nSELECT autor_id, imie, nazwisko\nFROM Autorzy\nWHERE rok_urodzenia &lt; 1950;\n\nCREATE VIEW Widok_StarsiAutorzy_LiczbaKsiazek AS\nSELECT\n    sa.imie,\n    sa.nazwisko,\n    COUNT(k.ksiazka_id) AS liczba_ksiazek\nFROM Widok_StarsiAutorzy sa\nJOIN Ksiazki k ON sa.autor_id = k.autor_id\nGROUP BY sa.imie, sa.nazwisko;\n➡️ Teraz możesz wykonać:\n\nSELECT * FROM Widok_StarsiAutorzy_LiczbaKsiazek\nWHERE liczba_ksiazek &gt; 2;\nWidoki pozwalają budować hierarchię logicznych perspektyw danych — od prostych po analityczne.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad7.html#najważniejsze-wnioski",
    "href": "lectures/wyklad7.html#najważniejsze-wnioski",
    "title": "Podzapytania (Subqueries) i Widoki (Views) w SQL",
    "section": "📘 Najważniejsze wnioski",
    "text": "📘 Najważniejsze wnioski\n\nWidoki nie przechowują danych, lecz definicję zapytania.\nMożna je traktować jak „tabele wirtualne”.\nUłatwiają zarządzanie dostępem do danych i tworzenie raportów.\nProste widoki są aktualizowalne, złożone — tylko do odczytu.\nMożna je zagnieżdżać, tworząc coraz bardziej rozbudowane analizy.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Podzapytania (Subqueries) i Widoki (Views) w SQL"
    ]
  },
  {
    "objectID": "lectures/plan.html",
    "href": "lectures/plan.html",
    "title": "Projektowanie Relacyjnych Baz Danych",
    "section": "",
    "text": "Wykład 1: Wprowadzenie do baz danych i model relacyjny • Historia i ewolucja baz danych • Podstawowe pojęcia: dane, informacja, baza danych, DBMS • Architektura systemów baz danych (ANSI/SPARC, poziomy abstrakcji) • Model relacyjny: relacje, krotki, atrybuty, domeny • Klucze (główny, obcy, kandydujące) i integralność danych\n⸻\nWykład 2: Projektowanie koncepcyjne – model ER (Entity-Relationship) • Analiza wymagań użytkownika • Diagramy encja-związek (ERD): encje, atrybuty, związki • Typy związków: 1:1, 1:N, N:M • Atrybuty proste, złożone, wielowartościowe • Ćwiczenia: tworzenie ERD dla prostego systemu\n⸻\nWykład 3: Od modelu ER do modelu relacyjnego • Reguły transformacji ERD na schemat relacyjny • Mapowanie encji i związków • Schemat relacyjny – projektowanie tabel • Ćwiczenia: przejście od ERD do relacji\n⸻\nWykład 4: Normalizacja baz danych • Redundancja i anomalia danych (wstawiania, modyfikacji, usuwania) • Klucze funkcyjne i zależności funkcyjne • Postacie normalne: 1NF, 2NF, 3NF, BCNF • Przykłady normalizacji i denormalizacji\n⸻\nWykład 5: Wprowadzenie do SQL – definicja danych (DDL) • Podstawowe elementy składni SQL • Tworzenie baz danych i tabel (CREATE DATABASE, CREATE TABLE) • Typy danych w SQL • Ograniczenia integralności (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL) • Modyfikacja schematu (ALTER TABLE, DROP TABLE)\n⸻\nWykład 6: SQL – manipulacja danymi (DML) • Wstawianie danych (INSERT) • Aktualizacja i usuwanie danych (UPDATE, DELETE) • Podstawowe zapytania (SELECT, FROM, WHERE) • Operatory logiczne i porównania • Operacje na zbiorach (UNION, INTERSECT, EXCEPT)\n⸻\nWykład 7: SQL – zapytania złożone i funkcje • Łączenia tabel (JOIN: INNER, LEFT, RIGHT, FULL) • Funkcje agregujące (COUNT, SUM, AVG, MIN, MAX) • Grupowanie i filtrowanie grup (GROUP BY, HAVING) • Podzapytania (subqueries) • Krótki wstęp do indeksów i wydajności zapytań"
  }
]