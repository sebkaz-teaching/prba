[
  {
    "objectID": "lectures/plan.html",
    "href": "lectures/plan.html",
    "title": "Projektowanie Relacyjnych Baz Danych",
    "section": "",
    "text": "Wykład 1: Wprowadzenie do baz danych i model relacyjny • Historia i ewolucja baz danych • Podstawowe pojęcia: dane, informacja, baza danych, DBMS • Architektura systemów baz danych (ANSI/SPARC, poziomy abstrakcji) • Model relacyjny: relacje, krotki, atrybuty, domeny • Klucze (główny, obcy, kandydujące) i integralność danych\n⸻\nWykład 2: Projektowanie koncepcyjne – model ER (Entity-Relationship) • Analiza wymagań użytkownika • Diagramy encja-związek (ERD): encje, atrybuty, związki • Typy związków: 1:1, 1:N, N:M • Atrybuty proste, złożone, wielowartościowe • Ćwiczenia: tworzenie ERD dla prostego systemu\n⸻\nWykład 3: Od modelu ER do modelu relacyjnego • Reguły transformacji ERD na schemat relacyjny • Mapowanie encji i związków • Schemat relacyjny – projektowanie tabel • Ćwiczenia: przejście od ERD do relacji\n⸻\nWykład 4: Normalizacja baz danych • Redundancja i anomalia danych (wstawiania, modyfikacji, usuwania) • Klucze funkcyjne i zależności funkcyjne • Postacie normalne: 1NF, 2NF, 3NF, BCNF • Przykłady normalizacji i denormalizacji\n⸻\nWykład 5: Wprowadzenie do SQL – definicja danych (DDL) • Podstawowe elementy składni SQL • Tworzenie baz danych i tabel (CREATE DATABASE, CREATE TABLE) • Typy danych w SQL • Ograniczenia integralności (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, NOT NULL) • Modyfikacja schematu (ALTER TABLE, DROP TABLE)\n⸻\nWykład 6: SQL – manipulacja danymi (DML) • Wstawianie danych (INSERT) • Aktualizacja i usuwanie danych (UPDATE, DELETE) • Podstawowe zapytania (SELECT, FROM, WHERE) • Operatory logiczne i porównania • Operacje na zbiorach (UNION, INTERSECT, EXCEPT)\n⸻\nWykład 7: SQL – zapytania złożone i funkcje • Łączenia tabel (JOIN: INNER, LEFT, RIGHT, FULL) • Funkcje agregujące (COUNT, SUM, AVG, MIN, MAX) • Grupowanie i filtrowanie grup (GROUP BY, HAVING) • Podzapytania (subqueries) • Krótki wstęp do indeksów i wydajności zapytań"
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "",
    "text": "Celem dzisiejszego wykładu jest pokazanie, jak przejść od koncepcyjnego modelu ERD (Entity–Relationship Diagram), który opisuje co chcemy przechowywać, do modelu relacyjnego, który mówi jak te dane będą fizycznie zorganizowane w tabelach.\n👉 Innymi słowy — dziś „przekładamy” logikę świata rzeczywistego na język tabel, kolumn i kluczy.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#cel-wykładu",
    "href": "lectures/wyklad3.html#cel-wykładu",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "",
    "text": "Celem dzisiejszego wykładu jest pokazanie, jak przejść od koncepcyjnego modelu ERD (Entity–Relationship Diagram), który opisuje co chcemy przechowywać, do modelu relacyjnego, który mówi jak te dane będą fizycznie zorganizowane w tabelach.\n👉 Innymi słowy — dziś „przekładamy” logikę świata rzeczywistego na język tabel, kolumn i kluczy.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#wprowadzenie",
    "href": "lectures/wyklad3.html#wprowadzenie",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "1. Wprowadzenie",
    "text": "1. Wprowadzenie\nZacznijmy od prostego pytania do grupy:\n„Czy narysowany diagram ERD to już baza danych?”\nWiększość studentów odpowie, że nie — i mają rację. ERD to tylko opis pojęć i powiązań między nimi, coś w rodzaju mapy koncepcyjnej. Dopiero model relacyjny pozwala tę mapę zaimplementować w systemie DBMS – czyli stworzyć konkretne tabele, relacje i klucze.\n\nPrzykład porównawczy:\nERD to jak plan architektoniczny domu.\nModel relacyjny to już projekt budowlany z wymiarami i materiałami.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#przypomnienie-podstawowych-pojęć",
    "href": "lectures/wyklad3.html#przypomnienie-podstawowych-pojęć",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Przypomnienie podstawowych pojęć",
    "text": "Przypomnienie podstawowych pojęć\nZanim przejdziemy do reguł, powtórzmy szybko:\n\nEncja – obiekt, o którym przechowujemy dane (np. Student, Kurs, Produkt).\nAtrybut – właściwość tego obiektu (np. imię, nazwisko, cena).\nZwiązek (relationship) – powiązanie między encjami (np. Student zapisuje się na Kurs).\nKrotka (tuple) – pojedynczy wiersz tabeli (np. dane jednego studenta).\nDomena – dopuszczalne wartości dla atrybutu (np. liczby od 1 do 5 dla oceny).\n\n👉 Wszystkie te pojęcia znajdą swoje odpowiedniki w modelu relacyjnym.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#proces-mapowania-transformacji",
    "href": "lectures/wyklad3.html#proces-mapowania-transformacji",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Proces mapowania (transformacji)",
    "text": "Proces mapowania (transformacji)\nTeraz przechodzimy do sedna: jak zamienić ERD w zestaw tabel.\nMożna to potraktować jak przepis: krok po kroku.\n\n🔹 1. Encje \\(\\to\\) Tabele\nKażda encja z modelu ER staje się tabelą w modelu relacyjnym.\nKażdy atrybut encji staje się kolumną.\nWyobraźmy sobie, że prostokąty z diagramu ER zamieniamy w tabele SQL.\nWszystkie elipsy (atrybuty) stają się kolumnami.\nPrzykład:\n\nEncja: STUDENT (NrIndeksu, Imię, Nazwisko, RokStudiow)\n\nRelacja: STUDENT(NrIndeksu, Imię, Nazwisko, RokStudiow)\n\n\n🔹 2. Atrybuty złożone\nAtrybut złożony to taki, który sam składa się z kilku części.\nW modelu relacyjnym nie ma takiej konstrukcji, więc trzeba go rozbić.\nPrzykład:\nAdres = (Ulica, KodPocztowy, Miasto)\n„Zauważmy, że dzięki temu możemy np. wyszukiwać po samym mieście, co nie byłoby możliwe, gdyby cały adres był jednym polem tekstowym.”\n\n\n🔹 3. Atrybuty wielowartościowe\nAtrybut wielowartościowy to taki, który może mieć więcej niż jedną wartość dla jednej encji.\nPrzykład: Student może mieć wiele adresów e-mail.\nW modelu relacyjnym nie możemy trzymać wielu wartości w jednej kolumnie, więc: ➡️ Tworzymy osobną tabelę.\nEMAIL(NrIndeksu, Email)\n\nKlucz główny: (NrIndeksu, Email)\nNrIndeksu to klucz obcy do tabeli STUDENT.\n\n„To moment, w którym ERD zaczyna się rozrastać — z jednej encji robią się dwie tabele.\nAle dzięki temu baza pozostaje spójna i czytelna.”\n\n\n🔹 4. Związki 1:1\nZwiązek „jeden do jednego” oznacza, że każdemu rekordowi z jednej tabeli odpowiada najwyżej jeden rekord z drugiej.\nPrzykład:\n\nKażda osoba ma dokładnie jeden paszport.\n\nOSOBA(PESEL, Imię, Nazwisko)\nPASZPORT(NrPaszportu, DataWażności, PESEL)\nDodajemy PESEL jako klucz obcy w tabeli PASZPORT.\n„Jeśli obie strony są naprawdę w relacji 1:1, można też rozważyć połączenie tych tabel — ale zwykle zostawia się je osobno, gdy przechowują różne grupy informacji\n\n\n🔹 5. Związki 1:N\nTo najczęstszy przypadek w praktyce.\nPrzykład: Jeden wykładowca prowadzi wiele kursów.\nWYKŁADOWCA(IDWykładowcy, Imię, Nazwisko)\nKURS(IDKursu, Nazwa, IDWykładowcy)\nIDWykładowcy w tabeli KURS jest kluczem obcym.\n„Pamiętajcie: klucz obcy zawsze dodajemy po stronie N, czyli po tej, gdzie może być więcej rekordów.”\n\n\n🔹 6. Związki N:M\nTo przypadek „wiele do wielu” — np. student może uczestniczyć w wielu kursach, a każdy kurs ma wielu studentów.\nW tym wypadku nie da się dodać klucza obcego do jednej z tabel, więc tworzymy tabelę pośredniczącą.\nSTUDENT(NrIndeksu, Imię, Nazwisko)\nKURS(IDKursu, Nazwa)\nZAPIS(NrIndeksu, IDKursu, DataZapisu)\n„Ta trzecia tabela to tak naprawdę odwzorowanie związku. Dzięki niej możemy np. zapisać dodatkowe informacje o relacji — np. datę zapisania się na kurs.”\n\n\n5. Jak projektować dobre tabele?\nKiedy masz już relacje, czas je zdefiniować w SQL.\nTu warto podkreślić kilka zasad:\n\nCzytelne nazwy (jednolite, najlepiej w liczbie pojedynczej).\nTypy danych dopasowane do zawartości.\nOgraniczenia (constraints):\nPRIMARY KEY – jednoznaczna identyfikacja,\nFOREIGN KEY – zapewnia spójność,\nNOT NULL, UNIQUE, CHECK – wymuszają poprawność danych.\n\nPrzykład SQL:\nCREATE TABLE STUDENT (\n  NrIndeksu CHAR(6) PRIMARY KEY,\n  Imie VARCHAR(30) NOT NULL,\n  Nazwisko VARCHAR(40) NOT NULL\n);\n„To dopiero teraz jest konkretna implementacja — coś, co można utworzyć w PostgreSQL, MySQL czy Oracle.\nAle zanim napiszemy SQL, zawsze powinniśmy mieć dobrze przemyślany model relacyjny.”\n\n\n6. Ćwiczenie praktyczne\n\nZadanie: Zaprojektuj schemat relacyjny dla firmy, w której pracownicy realizują projekty. Każdy projekt ma wielu pracowników, a każdy pracownik może uczestniczyć w wielu projektach. Dodatkowo pamiętamy od kiedy pracownik uczestniczy w projekcie.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#podsumowanie",
    "href": "lectures/wyklad3.html#podsumowanie",
    "title": "Od modelu ER do modelu relacyjnego",
    "section": "Podsumowanie:",
    "text": "Podsumowanie:\n„Dziś nauczyliśmy się tłumaczyć język analityków (ERD) na język baz danych (model relacyjny).”\n\nEncje → tabele\nAtrybuty → kolumny\nZwiązki → klucze obce lub tabele pośrednie\nAtrybuty złożone → rozbijamy\nAtrybuty wielowartościowe → osobne tabele\n\n👉 W kolejnym wykładzie przejdziemy do normalizacji, czyli porządkowania tabel, by unikać błędów i redundancji.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od modelu ER do modelu relacyjnego"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: zimowy",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#projektowanie-relacyjnych-baz-danych",
    "href": "index.html#projektowanie-relacyjnych-baz-danych",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: zimowy",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogólne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykład WEL21EA1S0:\n\n\n02.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n06.10.2025 Poniedziałek 8.00 - 9.30. b 61 s 104\n\n\n09.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n16.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n20.10.2025 Poniedziałek 9.50 - 11.25 b 61 s 104\n27.10.2025 Poniedziałek 9.50 - 11.25 b 61 s 104\n30.10.2025 Czwartek 8.00 - 9.30. b 61 s 104\n\n\n\nLaboratorium:",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "Ben Forta - SQL w mnieniu oka. Helion. 2020.\nThomas Nield - Pierwsze kroki z SQL. Praktyczne podejście dla początkujących. O’Reilly: 2016"
  },
  {
    "objectID": "ksiazki.html#książki",
    "href": "ksiazki.html#książki",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "Ben Forta - SQL w mnieniu oka. Helion. 2020.\nThomas Nield - Pierwsze kroki z SQL. Praktyczne podejście dla początkujących. O’Reilly: 2016"
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "",
    "text": "Każdy projekt bazy danych zaczyna się od zrozumienia czego oczekuje użytkownik. Bez tego łatwo stworzyć system, który jest poprawny technicznie, ale bezużyteczny w praktyce.\nPrzykład 1 – biblioteka\nBiblioteka chce mieć system, który przechowuje dane o:\n\nksiążkach (tytuł, autor, rok wydania, ISBN),\nczytelnikach (imię, nazwisko, numer karty bibliotecznej),\nwypożyczeniach (jaka książka, który czytelnik, kiedy wypożyczona i kiedy oddana).\n\nPrzykład 2 – sklep internetowy\nSklep potrzebuje informacji o:\n\nklientach (imię, adres, e-mail),\nproduktach (nazwa, cena, kategoria),\nzamówieniach (który klient, jakie produkty, kiedy złożono, status zamówienia).\n\n👉 Zwróć uwagę:\n\nw bibliotece najważniejszy jest związek wypożyczeń,\nw sklepie – związek zamówień.\n\nJuż na tym etapie widać, że kluczowe są powiązania, a nie tylko same dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#analiza-wymagań-użytkownika",
    "href": "lectures/wyklad2.html#analiza-wymagań-użytkownika",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "",
    "text": "Każdy projekt bazy danych zaczyna się od zrozumienia czego oczekuje użytkownik. Bez tego łatwo stworzyć system, który jest poprawny technicznie, ale bezużyteczny w praktyce.\nPrzykład 1 – biblioteka\nBiblioteka chce mieć system, który przechowuje dane o:\n\nksiążkach (tytuł, autor, rok wydania, ISBN),\nczytelnikach (imię, nazwisko, numer karty bibliotecznej),\nwypożyczeniach (jaka książka, który czytelnik, kiedy wypożyczona i kiedy oddana).\n\nPrzykład 2 – sklep internetowy\nSklep potrzebuje informacji o:\n\nklientach (imię, adres, e-mail),\nproduktach (nazwa, cena, kategoria),\nzamówieniach (który klient, jakie produkty, kiedy złożono, status zamówienia).\n\n👉 Zwróć uwagę:\n\nw bibliotece najważniejszy jest związek wypożyczeń,\nw sklepie – związek zamówień.\n\nJuż na tym etapie widać, że kluczowe są powiązania, a nie tylko same dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#diagramy-encjazwiązek",
    "href": "lectures/wyklad2.html#diagramy-encjazwiązek",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Diagramy encja–związek",
    "text": "Diagramy encja–związek\nModel ERD (Entity–Relationship Diagram) pozwala w przejrzysty sposób przedstawić jakie obiekty istnieją w systemie i jak są ze sobą powiązane.\n\nEncje rysujemy jako prostokąty.\nPrzykład: „Student”, „Książka”, „Zamówienie”.\nAtrybuty zapisujemy jako elipsy i łączymy z encją.\n„Student” → Imię, Nazwisko, NrIndeksu.\nZwiązki przedstawiamy jako romby.\n„Student” \\(\\to\\) „Wypożycza” \\(\\to\\) „Książka”.\n\nPrzykład wizualny do opowiedzenia:\n\nWyobraźcie sobie trzy prostokąty: „Student”, „Książka” i „Bibliotekarz”.\nŁączymy je rombem „Wypożycza”.\nDodajemy atrybuty: do studenta „NrIndeksu”, do książki „ISBN”, a do związku „Data wypożyczenia”.\n\n👉 Dzięki temu widzimy nie tylko obiekty, ale i relacje między nimi.\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#typy-związków",
    "href": "lectures/wyklad2.html#typy-związków",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Typy związków",
    "text": "Typy związków\nZwiązek 1:1 (jeden do jednego)\n\nKażdy obiekt jednej encji odpowiada najwyżej jednemu obiektowi drugiej encji.\nPrzykład: każdy człowiek ma jedno unikalne PESEL.\n\nZwiązek 1:N (jeden do wielu)\n\nJeden obiekt encji A może być powiązany z wieloma obiektami encji B, ale nie odwrotnie.\nPrzykład: jeden wykładowca prowadzi wiele kursów, ale każdy kurs ma dokładnie jednego prowadzącego.\n\nZwiązek N:M (wiele do wielu)\n\nJeden obiekt encji A może być powiązany z wieloma obiektami encji B i odwrotnie.\nPrzykład: studenci zapisują się na wiele kursów, a każdy kurs realizowany jest przez wielu studentów.\n\nMini-case: kino\n\nEncje: „Film”, „Widz”, „Seans”.\nWidzowie mogą oglądać wiele filmów, a każdy film może być oglądany przez wielu widzów. To klasyczne N:M.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#atrybuty-proste-złożone-wielowartościowe",
    "href": "lectures/wyklad2.html#atrybuty-proste-złożone-wielowartościowe",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Atrybuty proste, złożone, wielowartościowe",
    "text": "Atrybuty proste, złożone, wielowartościowe\n\nAtrybut prosty – nie da się go podzielić: „Data urodzenia”, „PESEL”.\nAtrybut złożony – składa się z mniejszych: „Adres” → „Ulica”, „Kod pocztowy”, „Miasto”.\nAtrybut wielowartościowy – może mieć wiele wartości dla jednej encji: „Numery telefonów” dla jednego studenta.\n\n👉 To ważne, bo w późniejszym projektowaniu relacyjnym atrybut wielowartościowy często trzeba przekształcić w oddzielną tabelę.\nPrzykład:\n\nStudent może mieć wiele adresów e-mail.\nW modelu ER narysujemy atrybut „Email” jako elipsę podwójną.\nW modelu relacyjnym – stworzymy tabelę „AdresyEmail” powiązaną z tabelą „Studenci”.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#przykłady-całościowe",
    "href": "lectures/wyklad2.html#przykłady-całościowe",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Przykłady całościowe",
    "text": "Przykłady całościowe\nNa koniec możemy omówić kilka kompletnych mini-systemów, żeby pokazać różne rodzaje encji, związków i atrybutów.\nPrzykład A – System rezerwacji hotelu\n\nEncje: „Pokój”, „Gość”, „Rezerwacja”.\nZwiązki: Gość „rezerwuje” Pokój.\nAtrybuty: Rezerwacja ma datę początku, datę końca i status.\n\nPrzykład B – Uczelnia\n\nEncje: „Student”, „Kurs”, „Wykładowca”.\nZwiązki: Student „zapisuje się na” Kurs, Wykładowca „prowadzi” Kurs.\nAtrybuty: Student – imię, nazwisko, nr indeksu. Kurs – nazwa, punktacja ECTS.\n\nPrzykład C – Sklep internetowy\n\nEncje: „Klient”, „Produkt”, „Zamówienie”.\nZwiązki: Klient „składa” Zamówienie, Zamówienie „zawiera” Produkt.\nAtrybuty: Produkt – cena, opis; Zamówienie – data, status.\n\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#podsumowanie",
    "href": "lectures/wyklad2.html#podsumowanie",
    "title": "Projektowanie koncepcyjne – model ER (Entity-Relationship)",
    "section": "Podsumowanie",
    "text": "Podsumowanie\n\nProjektowanie bazy danych zaczynamy od analizy wymagań użytkownika.\nModel ER pozwala uporządkować wiedzę w postaci encje–atrybuty–związki.\nWyróżniamy związki 1:1, 1:N, N:M oraz atrybuty proste, złożone i wielowartościowe.\nDiagram ERD to narzędzie komunikacji – łączy świat użytkownika ze światem projektanta i programisty.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Projektowanie koncepcyjne – model ER (Entity-Relationship)"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Celem wykładu jest zapoznanie się z podstawami relacyjnych baz danych — ich historią, pojęciami, architekturą, strukturą danych oraz zasadami integralności. Po tym wykładzie student powinien rozumieć, czym jest baza danych, jak działa DBMS, co oznacza model relacyjny oraz jakie są klucze i reguły spójności danych.\n\n\n\nBazy danych nie są wynalazkiem XXI wieku — ich początki sięgają lat 60. XX wieku, gdy organizacje zaczęły gromadzić coraz większe ilości danych.\n\n\nPierwsze systemy przechowywały dane w plikach na dyskach. Choć były proste, miały poważne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudność w utrzymaniu spójności\nBrak uniwersalnych narzędzi do wyszukiwania\n\n💡 Zadanie: Na jakich innych obiektach, oprócz plików, można pracować w systemach operacyjnych?\n\n\n\nW latach 60. i 70. pojawiły się pierwsze systemy zarządzania bazami danych (DBMS). Zapewniały:\n\ncentralną kontrolę danych,\nintegralność i bezpieczeństwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n\nWczesne systemy wykorzystywały struktury drzewiaste lub grafowe. Były skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n\nW 1970 roku Edgar F. Codd zaproponował model relacyjny danych, w którym:\n\ndane są przechowywane w tabelach (relacjach),\nkażda tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystość,\nelastyczność (łatwo dodawać nowe tabele),\nbezpieczeństwo i spójność danych.\n\n\n\n\nWraz z rozwojem modelu relacyjnego powstał SQL (Structured Query Language) – język do tworzenia, modyfikowania i pobierania danych.\nDziś SQL jest fundamentem większości systemów: od aplikacji biurowych po duże systemy korporacyjne. Nawet współczesne rozwiązania NoSQL często nawiązują do idei relacyjnych.\n\n\n\n\n\n\n\nDane – surowe fakty, liczby, teksty, które same w sobie niewiele znaczą. 👉 np. 25, Warszawa, 12345\nInformacja – dane zinterpretowane i zorganizowane w kontekście. 👉 np. „25 klientów z Warszawy złożyło zamówienie w ostatnim tygodniu”.\n\nDane to materiał, informacja to znaczenie.\n\n\n\nZorganizowany zbiór danych umożliwiający ich łatwe przeszukiwanie, aktualizację i analizę.\nCechy:\n\nStrukturalność\nCentralizacja\nTrwałość i bezpieczeństwo\n\nPrzykłady:\n\nLista kontaktów w telefonie\nSystem rezerwacji hotelowej\nSklep internetowy\n\n\n\n\nOprogramowanie do tworzenia, modyfikowania i przetwarzania baz danych.\nFunkcje DBMS:\n\nTworzenie i modyfikacja schematów\nOperacje CRUD (Create, Read, Update, Delete)\nZarządzanie bezpieczeństwem i uprawnieniami\nOptymalizacja zapytań\n\nPrzykłady: MySQL, PostgreSQL, Oracle, SQL Server, SQLite.\n\n\n\n\nSystemy baz danych są zorganizowane według poziomów abstrakcji, co pozwala oddzielić sposób przechowywania danych od ich widoku dla użytkownika.\n\n\n\nPoziom fizyczny (wewnętrzny)\n\n\nopisuje sposób przechowywania danych (pliki, indeksy, struktury).\n\n\nPoziom logiczny (pośredni)\n\n\nopisuje strukturę danych (tabele, relacje, typy danych).\n\n\nPoziom zewnętrzny (widok użytkownika)\n\n\npokazuje dane z perspektywy użytkownika lub aplikacji.\n\nZmiany w jednym poziomie nie wymagają zmian w pozostałych — to tzw. niezależność danych.\n\n\n\nFormalny model trójpoziomowy: - poziom wewnętrzny – fizyczne przechowywanie danych, - poziom pojęciowy – logiczna struktura bazy, - poziom zewnętrzny – widoki użytkowników.\nZalety: - izolacja danych, - bezpieczeństwo, - elastyczność i skalowalność.\n\n\n\n\n\n\nZbiór danych o tej samej strukturze. Każda tabela opisuje jeden typ obiektów (np. Studenci, Kursy).\n\n\n\nPojedynczy rekord w tabeli (np. dane jednego studenta).\n\n\n\nWłaściwość obiektu – ma nazwę i typ danych (np. Imię, Nazwisko, NrIndeksu).\n\n\n\nZbiór dopuszczalnych wartości atrybutu (np. liczby całkowite, ciągi znaków do 50 znaków).\n\n\n\n\nSchemat relacji – struktura tabeli (nazwy kolumn, typy).\nInstancja relacji – aktualna zawartość tabeli.\n\n\n\n\n\n\n\n\njednoznacznie identyfikuje każdy rekord,\nnie może mieć wartości NULL.\n\nPrzykład: NrIndeksu w tabeli Studenci.\n\n\n\n\nkażdy atrybut (lub ich kombinacja), który mógłby być kluczem głównym. Przykład: NrIndeksu i PESEL – wybieramy jeden jako główny.\n\n\n\n\n\natrybut wskazujący na klucz główny w innej tabeli. Przykład: NrIndeksu w tabeli Oceny odnosi się do Studenci.\n\n\n\n\n\nIntegralność encji – każda krotka musi być jednoznacznie identyfikowana.\nIntegralność referencyjna – wartości kluczy obcych muszą istnieć w tabelach nadrzędnych.\nIntegralność dziedzinowa – wartości atrybutów muszą mieścić się w swoich domenach.\n\n\n\n\n\n\n\n\nKto zaproponował model relacyjny danych?\n\n\nDonald Knuth\nEdgar F. Codd\nBill Gates\nCharles Bachman\n\n\nCo opisuje poziom logiczny w architekturze ANSI/SPARC?\n\n\nSposób fizycznego zapisu danych\nWidok danych przez użytkownika\nStrukturę danych i relac\n\n✏️ Pytania otwarte / opisowe\n\nWyjaśnij różnicę między danymi a informacją.\nWymień i krótko opisz trzy poziomy abstrakcji w modelu ANSI/SPARC.\nCo to jest klucz główny i jakie są jego cechy?\nPodaj przykład relacji i wskaż w niej krotki oraz atrybuty.\nDlaczego model relacyjny okazał się przełomem w historii baz danych?\nJakie są trzy podstawowe zasady integralności danych?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#wprowadzenie-i-cele-wykładu",
    "href": "lectures/wyklad1.html#wprowadzenie-i-cele-wykładu",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Celem wykładu jest zapoznanie się z podstawami relacyjnych baz danych — ich historią, pojęciami, architekturą, strukturą danych oraz zasadami integralności. Po tym wykładzie student powinien rozumieć, czym jest baza danych, jak działa DBMS, co oznacza model relacyjny oraz jakie są klucze i reguły spójności danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "href": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Bazy danych nie są wynalazkiem XXI wieku — ich początki sięgają lat 60. XX wieku, gdy organizacje zaczęły gromadzić coraz większe ilości danych.\n\n\nPierwsze systemy przechowywały dane w plikach na dyskach. Choć były proste, miały poważne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudność w utrzymaniu spójności\nBrak uniwersalnych narzędzi do wyszukiwania\n\n💡 Zadanie: Na jakich innych obiektach, oprócz plików, można pracować w systemach operacyjnych?\n\n\n\nW latach 60. i 70. pojawiły się pierwsze systemy zarządzania bazami danych (DBMS). Zapewniały:\n\ncentralną kontrolę danych,\nintegralność i bezpieczeństwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n\nWczesne systemy wykorzystywały struktury drzewiaste lub grafowe. Były skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n\nW 1970 roku Edgar F. Codd zaproponował model relacyjny danych, w którym:\n\ndane są przechowywane w tabelach (relacjach),\nkażda tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystość,\nelastyczność (łatwo dodawać nowe tabele),\nbezpieczeństwo i spójność danych.\n\n\n\n\nWraz z rozwojem modelu relacyjnego powstał SQL (Structured Query Language) – język do tworzenia, modyfikowania i pobierania danych.\nDziś SQL jest fundamentem większości systemów: od aplikacji biurowych po duże systemy korporacyjne. Nawet współczesne rozwiązania NoSQL często nawiązują do idei relacyjnych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "href": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Dane – surowe fakty, liczby, teksty, które same w sobie niewiele znaczą. 👉 np. 25, Warszawa, 12345\nInformacja – dane zinterpretowane i zorganizowane w kontekście. 👉 np. „25 klientów z Warszawy złożyło zamówienie w ostatnim tygodniu”.\n\nDane to materiał, informacja to znaczenie.\n\n\n\nZorganizowany zbiór danych umożliwiający ich łatwe przeszukiwanie, aktualizację i analizę.\nCechy:\n\nStrukturalność\nCentralizacja\nTrwałość i bezpieczeństwo\n\nPrzykłady:\n\nLista kontaktów w telefonie\nSystem rezerwacji hotelowej\nSklep internetowy\n\n\n\n\nOprogramowanie do tworzenia, modyfikowania i przetwarzania baz danych.\nFunkcje DBMS:\n\nTworzenie i modyfikacja schematów\nOperacje CRUD (Create, Read, Update, Delete)\nZarządzanie bezpieczeństwem i uprawnieniami\nOptymalizacja zapytań\n\nPrzykłady: MySQL, PostgreSQL, Oracle, SQL Server, SQLite.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#architektura-systemów-baz-danych",
    "href": "lectures/wyklad1.html#architektura-systemów-baz-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Systemy baz danych są zorganizowane według poziomów abstrakcji, co pozwala oddzielić sposób przechowywania danych od ich widoku dla użytkownika.\n\n\n\nPoziom fizyczny (wewnętrzny)\n\n\nopisuje sposób przechowywania danych (pliki, indeksy, struktury).\n\n\nPoziom logiczny (pośredni)\n\n\nopisuje strukturę danych (tabele, relacje, typy danych).\n\n\nPoziom zewnętrzny (widok użytkownika)\n\n\npokazuje dane z perspektywy użytkownika lub aplikacji.\n\nZmiany w jednym poziomie nie wymagają zmian w pozostałych — to tzw. niezależność danych.\n\n\n\nFormalny model trójpoziomowy: - poziom wewnętrzny – fizyczne przechowywanie danych, - poziom pojęciowy – logiczna struktura bazy, - poziom zewnętrzny – widoki użytkowników.\nZalety: - izolacja danych, - bezpieczeństwo, - elastyczność i skalowalność.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#model-relacyjny",
    "href": "lectures/wyklad1.html#model-relacyjny",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Zbiór danych o tej samej strukturze. Każda tabela opisuje jeden typ obiektów (np. Studenci, Kursy).\n\n\n\nPojedynczy rekord w tabeli (np. dane jednego studenta).\n\n\n\nWłaściwość obiektu – ma nazwę i typ danych (np. Imię, Nazwisko, NrIndeksu).\n\n\n\nZbiór dopuszczalnych wartości atrybutu (np. liczby całkowite, ciągi znaków do 50 znaków).\n\n\n\n\nSchemat relacji – struktura tabeli (nazwy kolumn, typy).\nInstancja relacji – aktualna zawartość tabeli.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#klucze-i-integralność-danych",
    "href": "lectures/wyklad1.html#klucze-i-integralność-danych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "jednoznacznie identyfikuje każdy rekord,\nnie może mieć wartości NULL.\n\nPrzykład: NrIndeksu w tabeli Studenci.\n\n\n\n\nkażdy atrybut (lub ich kombinacja), który mógłby być kluczem głównym. Przykład: NrIndeksu i PESEL – wybieramy jeden jako główny.\n\n\n\n\n\natrybut wskazujący na klucz główny w innej tabeli. Przykład: NrIndeksu w tabeli Oceny odnosi się do Studenci.\n\n\n\n\n\nIntegralność encji – każda krotka musi być jednoznacznie identyfikowana.\nIntegralność referencyjna – wartości kluczy obcych muszą istnieć w tabelach nadrzędnych.\nIntegralność dziedzinowa – wartości atrybutów muszą mieścić się w swoich domenach.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#zestaw-pytań-testowych",
    "href": "lectures/wyklad1.html#zestaw-pytań-testowych",
    "title": "Wprowadzenie do relacyjnych baz danych",
    "section": "",
    "text": "Kto zaproponował model relacyjny danych?\n\n\nDonald Knuth\nEdgar F. Codd\nBill Gates\nCharles Bachman\n\n\nCo opisuje poziom logiczny w architekturze ANSI/SPARC?\n\n\nSposób fizycznego zapisu danych\nWidok danych przez użytkownika\nStrukturę danych i relac\n\n✏️ Pytania otwarte / opisowe\n\nWyjaśnij różnicę między danymi a informacją.\nWymień i krótko opisz trzy poziomy abstrakcji w modelu ANSI/SPARC.\nCo to jest klucz główny i jakie są jego cechy?\nPodaj przykład relacji i wskaż w niej krotki oraz atrybuty.\nDlaczego model relacyjny okazał się przełomem w historii baz danych?\nJakie są trzy podstawowe zasady integralności danych?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Wprowadzenie do relacyjnych baz danych"
    ]
  }
]