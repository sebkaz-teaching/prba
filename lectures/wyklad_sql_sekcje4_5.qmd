---
title: "ğŸ§­ Wprowadzenie do optymalizacji zapytaÅ„ SQL â€“ Sekcje 4 i 5"
format: html
---

## ğŸ—‚ï¸ Sekcja 4 â€“ Indeksy w SQL

Indeksy to **podstawowe narzÄ™dzie optymalizacji zapytaÅ„**, ktÃ³re pozwala bazie danych szybko znaleÅºÄ‡ potrzebne wiersze, bez koniecznoÅ›ci skanowania caÅ‚ej tabeli.  
MoÅ¼na je porÃ³wnaÄ‡ do **spisu treÅ›ci w ksiÄ…Å¼ce** â€” zamiast czytaÄ‡ kaÅ¼dy rozdziaÅ‚, patrzymy od razu na wÅ‚aÅ›ciwÄ… stronÄ™.

### ğŸ”¹ Dlaczego indeksy sÄ… waÅ¼ne?

Bez indeksu baza danych musi sprawdziÄ‡ kaÅ¼dy wiersz tabeli, by znaleÅºÄ‡ pasujÄ…ce rekordy (**sequential scan**).  
Z indeksem, silnik moÅ¼e odczytaÄ‡ **tylko te dane**, ktÃ³re speÅ‚niajÄ… warunek â€” znacznie szybciej i przy mniejszym zuÅ¼yciu zasobÃ³w.

KorzyÅ›ci z indeksÃ³w:

- â±ï¸ **Szybsze wyszukiwanie** danych, szczegÃ³lnie w duÅ¼ych tabelach  
- ğŸ’¾ **Ograniczenie operacji I/O**, bo baza czyta mniej blokÃ³w z dysku  
- ğŸ”„ **Przyspieszenie sortowania i Å‚Ä…czenia tabel** (`JOIN`), jeÅ›li indeks obejmuje kolumny uÅ¼ywane w warunkach

### ğŸ”¹ Rodzaje indeksÃ³w

NajczÄ™Å›ciej spotykane:

1. **B-Tree (balanced tree)** â€“ najpopularniejszy typ, sprawdza siÄ™ w wiÄ™kszoÅ›ci wyszukiwaÅ„, zakresÃ³w i sortowaÅ„  
2. **Hash** â€“ szybki dostÄ™p po dokÅ‚adnej wartoÅ›ci (nie obsÅ‚uguje zakresÃ³w)  
3. **Bitmap** â€“ efektywny dla kolumn o maÅ‚ej liczbie unikalnych wartoÅ›ci, np. pÅ‚eÄ‡ lub status  
4. **Kompozytowe** â€“ obejmujÄ… kilka kolumn, przydatne przy filtrach i sortowaniach wielokolumnowych

### ğŸ”¹ Co indeksuje?

- **Kolumny uÅ¼ywane w WHERE** â€“ aby szybciej wyszukaÄ‡ dane  
- **Kolumny uÅ¼ywane w JOIN** â€“ przyspiesza Å‚Ä…czenie tabel  
- **Kolumny w ORDER BY lub GROUP BY** â€“ pomaga szybciej sortowaÄ‡ i grupowaÄ‡ wyniki  
- **Kolumny unikalne lub klucze gÅ‚Ã³wne** â€“ zapewnia integralnoÅ›Ä‡ danych i przyspiesza wyszukiwanie

### ğŸ”¹ Wady nadmiaru indeksÃ³w

Indeksy przyspieszajÄ… odczyt, ale majÄ… teÅ¼ koszty:

- ğŸ”„ **Spowolnienie operacji INSERT/UPDATE/DELETE**, bo indeksy trzeba aktualizowaÄ‡  
- ğŸ’¾ **ZwiÄ™kszone zuÅ¼ycie pamiÄ™ci i przestrzeni dyskowej**  
- âš–ï¸ Trzeba wybraÄ‡ **optymalny zestaw indeksÃ³w**, Å¼eby nie pogorszyÄ‡ ogÃ³lnej wydajnoÅ›ci

---

## ğŸ§ª Sekcja 5 â€“ Praktyczne przykÅ‚ady uÅ¼ycia indeksÃ³w

W tej sekcji pokaÅ¼emy, jak indeksy wpÅ‚ywajÄ… na plan wykonania zapytania i rzeczywisty czas wykonania.

### ğŸ”¹ PrzykÅ‚ad w PostgreSQL

Mamy tabelÄ™ `orders`:

```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  customer_id INTEGER,
  order_date DATE,
  total DECIMAL
);
```

#### Scenariusz A â€“ brak indeksu

```sql
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 42;
```

Wynik moÅ¼e wyglÄ…daÄ‡ tak:

```sql
Seq Scan on orders  (cost=0.00..450.00 rows=3 width=48)
  Filter: (customer_id = 42)
Execution Time: 22.5 ms
```

> Baza przeszukuje caÅ‚Ä… tabelÄ™ (Seq Scan), co jest kosztowne przy duÅ¼ej liczbie rekordÃ³w.

#### Scenariusz B â€“ z indeksem

Dodajemy indeks na kolumnie `customer_id`:

```sql
CREATE INDEX idx_orders_customer ON orders(customer_id);
```

Po wykonaniu tego samego zapytania:

```sql
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 42;
```

Plan wykonania:

```sql
Index Scan using idx_orders_customer on orders  (cost=0.29..8.50 rows=3 width=48)
  Index Cond: (customer_id = 42)
Execution Time: 0.030 ms
```

â¡ï¸ WidaÄ‡ ogromnÄ… poprawÄ™ wydajnoÅ›ci: baza odczytuje tylko pasujÄ…ce wiersze zamiast caÅ‚ej tabeli.

### ğŸ”¹ Indeksy a JOIN

Przy Å‚Ä…czeniu tabel:

```sql
SELECT o.id, c.name
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE c.region = 'Europe';
```

- Indeks na `customers.id` i `orders.customer_id` przyspiesza JOIN  
- Indeks na `customers.region` przyspiesza filtrowanie po regionie

### ğŸ”¹ WskazÃ³wki praktyczne

- TwÃ³rz indeksy **tylko na kolumnach, ktÃ³re sÄ… czÄ™sto filtrowane lub sortowane**  
- Analizuj plany wykonania przy uÅ¼yciu `EXPLAIN` i `EXPLAIN ANALYZE`  
- Zwracaj uwagÄ™ na **koszt operacji (cost=...)** i liczbÄ™ wierszy (`rows=...`)  
- PamiÄ™taj o balansie: zbyt wiele indeksÃ³w moÅ¼e spowolniÄ‡ zapis danych

---
