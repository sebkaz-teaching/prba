---
title: "Podzapytania (Subqueries) i Widoki (Views) w SQL"
---

# 1ï¸âƒ£3ï¸âƒ£ Podzapytania (Subqueries) w SQL

Podzapytanie to **zapytanie wewnÄ…trz innego zapytania SQL**. 
SÅ‚uÅ¼y do wykonywania bardziej zÅ‚oÅ¼onych operacji, kiedy jedno zapytanie potrzebuje wynikÃ³w innego.  
MoÅ¼emy je traktowaÄ‡ jak â€mini-zapytaniaâ€, ktÃ³re dostarczajÄ… danych do zapytania gÅ‚Ã³wnego.

Podzapytania mogÄ… wystÄ™powaÄ‡ w rÃ³Å¼nych miejscach:

- w klauzuli **WHERE** â€“ do filtrowania danych,
- w klauzuli **FROM** â€“ jako tymczasowa tabela,
- w klauzuli **SELECT** â€“ do obliczeÅ„ w kaÅ¼dej krotce,
- w konstrukcjach **EXISTS**, **IN**, **ALL**, **ANY** â€“ do testowania warunkÃ³w logicznych.


## ğŸ”¹ 1. Podzapytanie w klauzuli WHERE (jednowartoÅ›ciowe)

To najczÄ™stszy typ podzapytania.  
Zapytanie gÅ‚Ã³wne wybiera dane na podstawie **wartoÅ›ci zwrÃ³conej przez podzapytanie**.

### ğŸ§© PrzykÅ‚ad:

ZnajdÅº ksiÄ…Å¼ki napisane przez autora o nazwisku *Sienkiewicz*.

```sql
SELECT tytul, rok
FROM Ksiazki
WHERE autor_id = (
    SELECT autor_id
    FROM Autorzy
    WHERE nazwisko = 'Sienkiewicz'
);
```

### ğŸ“˜ Opis dziaÅ‚ania:

1.	Podzapytanie wewnÄ™trzne szuka identyfikatora autora autor_id, ktÃ³rego nazwisko to Sienkiewicz.
2.	Zapytanie gÅ‚Ã³wne wybiera z tabeli Ksiazki tylko te rekordy, w ktÃ³rych autor_id jest rÃ³wny wynikowi podzapytania.

> ğŸ”¸ Takie podzapytanie musi zwrÃ³ciÄ‡ jednÄ… wartoÅ›Ä‡ (scalar subquery) â€“ w przeciwnym razie wystÄ…pi bÅ‚Ä…d.

## ğŸ”¹ 2. Podzapytanie zwracajÄ…ce wiele wartoÅ›ci (operator IN)

JeÅ›li podzapytanie zwraca wiÄ™cej niÅ¼ jeden rekord, uÅ¼ywamy operatora IN.

### ğŸ§© PrzykÅ‚ad:

ZnajdÅº wszystkie ksiÄ…Å¼ki autorÃ³w, ktÃ³rych nazwiska zaczynajÄ… siÄ™ na literÄ™ M.

```sql
SELECT tytul, rok
FROM Ksiazki
WHERE autor_id IN (
    SELECT autor_id
    FROM Autorzy
    WHERE nazwisko LIKE 'M%'
);
```

### ğŸ“˜ Opis dziaÅ‚ania:

- Podzapytanie wewnÄ™trzne zwraca listÄ™ identyfikatorÃ³w autorÃ³w, np. [1, 5, 7].
- Zapytanie gÅ‚Ã³wne wybiera ksiÄ…Å¼ki, ktÃ³rych autor_id znajduje siÄ™ na tej liÅ›cie.

> ğŸ”¸ Operator IN moÅ¼na traktowaÄ‡ jak porÃ³wnanie z â€wieloma wartoÅ›ciami jednoczeÅ›nieâ€.


## ğŸ”¹ 3. Podzapytanie w klauzuli SELECT

Podzapytanie moÅ¼e teÅ¼ zwracaÄ‡ pojedynczÄ… wartoÅ›Ä‡ (skalarnÄ…) i byÄ‡ uÅ¼yte w liÅ›cie kolumn.

### ğŸ§© PrzykÅ‚ad:

WyÅ›wietl listÄ™ autorÃ³w wraz z liczbÄ… ich ksiÄ…Å¼ek.

```sql
SELECT
    a.imie,
    a.nazwisko,
    (
        SELECT COUNT(*)
        FROM Ksiazki k
        WHERE k.autor_id = a.autor_id
    ) AS liczba_ksiazek
FROM Autorzy a;

```

### ğŸ“˜ Opis dziaÅ‚ania:

- Dla kaÅ¼dego autora (a.autor_id) wykonuje siÄ™ osobne podzapytanie,
ktÃ³re liczy ksiÄ…Å¼ki przypisane do tego autora.
- Wynik jest dodawany jako nowa kolumna liczba_ksiazek.

> ğŸ”¸ To tzw. podzapytanie skorelowane (correlated subquery), poniewaÅ¼ odnosi siÄ™ do kolumny z zapytania gÅ‚Ã³wnego.

## ğŸ”¹ 4. Podzapytanie w klauzuli FROM (tabela pochodna)

Podzapytanie moÅ¼e tworzyÄ‡ tymczasowÄ… tabelÄ™ w sekcji FROM.
Takie rozwiÄ…zanie nazywa siÄ™ derived table i pozwala na pracÄ™ z przetworzonymi danymi.

### ğŸ§© PrzykÅ‚ad:

Policz Å›redni rok wydania ksiÄ…Å¼ek, a nastÄ™pnie wybierz te, ktÃ³re sÄ… starsze od Å›redniej.

```sql
SELECT tytul, rok
FROM (
    SELECT *
    FROM Ksiazki
) AS K
WHERE K.rok < (
    SELECT AVG(rok) FROM Ksiazki
);
```

### ğŸ“˜ Opis dziaÅ‚ania:

- Podzapytanie w FROM tworzy tymczasowÄ… tabelÄ™ K.
- W klauzuli WHERE uÅ¼ywamy innego podzapytania, ktÃ³re liczy Å›redni rok wydania.
- Wynik to ksiÄ…Å¼ki starsze od Å›redniej publikacji.

## ğŸ”¹ 5. Korelowane podzapytanie (correlated subquery)

To podzapytanie, ktÃ³re odwoÅ‚uje siÄ™ do kolumn z zapytania gÅ‚Ã³wnego.
Wykonuje siÄ™ dla kaÅ¼dego wiersza osobno â€“ dlatego bywa wolniejsze, ale bardzo elastyczne.

### ğŸ§© PrzykÅ‚ad:

ZnajdÅº najstarszÄ… ksiÄ…Å¼kÄ™ kaÅ¼dego autora.

```sql
SELECT k.tytul, k.rok, a.nazwisko
FROM Ksiazki k
JOIN Autorzy a ON k.autor_id = a.autor_id
WHERE k.rok = (
    SELECT MIN(rok)
    FROM Ksiazki
    WHERE autor_id = k.autor_id
);

```

### ğŸ“˜ Opis dziaÅ‚ania:

- Dla kaÅ¼dego wiersza w tabeli Ksiazki podzapytanie szuka najmniejszego roku dla tego samego autora.
- PorÃ³wnanie k.rok = (MIN(rok)) sprawia, Å¼e zostaje tylko najstarsza ksiÄ…Å¼ka kaÅ¼dego autora.

## ğŸ”¹ 6. Podzapytanie z EXISTS

Operator EXISTS sprawdza, czy podzapytanie zwrÃ³ciÅ‚o jakiekolwiek wiersze.
Nie liczy ich â€” interesuje nas jedynie, czy wynik istnieje (TRUE/FALSE).

### ğŸ§© PrzykÅ‚ad:

ZnajdÅº autorÃ³w, ktÃ³rzy napisali przynajmniej jednÄ… ksiÄ…Å¼kÄ™.
```sql
SELECT imie, nazwisko
FROM Autorzy a
WHERE EXISTS (
    SELECT 1
    FROM Ksiazki k
    WHERE k.autor_id = a.autor_id
);

```

### ğŸ“˜ Opis dziaÅ‚ania:

- Dla kaÅ¼dego autora sprawdzane jest, czy istnieje co najmniej jeden wiersz w tabeli Ksiazki z tym samym autor_id.
- JeÅ›li tak â€” warunek EXISTS zwraca TRUE, a autor pojawia siÄ™ w wyniku.


## ğŸ”¹ 7. PorÃ³wnania z ALL / ANY

Operator ALL wymaga, aby warunek byÅ‚ speÅ‚niony dla wszystkich wynikÃ³w podzapytania.
Operator ANY (lub SOME) â€“ aby warunek byÅ‚ speÅ‚niony dla przynajmniej jednego.

### ğŸ§© PrzykÅ‚ad:

ZnajdÅº ksiÄ…Å¼ki wydane wczeÅ›niej niÅ¼ wszystkie ksiÄ…Å¼ki Prusa.
```sql
SELECT tytul, rok
FROM Ksiazki
WHERE rok < ALL (
    SELECT rok
    FROM Ksiazki
    WHERE autor_id = (
        SELECT autor_id FROM Autorzy WHERE nazwisko = 'Prus'
    )
);
```

### ğŸ“˜ Opis dziaÅ‚ania:

- Podzapytanie wewnÄ™trzne zwraca lata publikacji ksiÄ…Å¼ek Prusa.
- Zapytanie gÅ‚Ã³wne wybiera tylko te ksiÄ…Å¼ki, ktÃ³rych rok jest mniejszy niÅ¼ wszystkie te wartoÅ›ci.



### ğŸ§® Podsumowanie typÃ³w podzapytaÅ„ w SQL

| **Typ podzapytania** | **Miejsce uÅ¼ycia** | **Zwracany wynik** | **Typowe operatory** | **PrzykÅ‚ad zastosowania** |
|------------------------|--------------------|--------------------|----------------------|----------------------------|
| **JednowartoÅ›ciowe (scalar)** | `WHERE`, `SELECT` | Pojedyncza wartoÅ›Ä‡ (1 rekord, 1 kolumna) | `=`, `<`, `>` | Autor o nazwisku â€Sienkiewiczâ€ |
| **WielowartoÅ›ciowe (multivalue)** | `WHERE` | Lista wartoÅ›ci (wiele rekordÃ³w) | `IN`, `NOT IN` | Autorzy, ktÃ³rych nazwisko zaczyna siÄ™ na â€Mâ€ |
| **Korelowane (correlated)** | `WHERE`, `SELECT` | Zmienny wynik dla kaÅ¼dego wiersza | `=`, `EXISTS` | Najstarsza ksiÄ…Å¼ka danego autora |
| **ZagnieÅ¼dÅ¼one w FROM (tabela pochodna)** | `FROM` | ZbiÃ³r wierszy (tymczasowa tabela) | â€” | Åšredni rok wydania ksiÄ…Å¼ek i porÃ³wnanie ze Å›redniÄ… |
| **Z operatorem EXISTS / NOT EXISTS** | `WHERE` | Prawda / FaÅ‚sz (czy istnieje wynik) | `EXISTS`, `NOT EXISTS` | Autorzy, ktÃ³rzy napisali przynajmniej jednÄ… ksiÄ…Å¼kÄ™ |
| **Z operatorem ALL / ANY / SOME** | `WHERE` | PorÃ³wnanie z wieloma wartoÅ›ciami | `ALL`, `ANY`, `SOME` | KsiÄ…Å¼ki starsze niÅ¼ wszystkie ksiÄ…Å¼ki Prusa |


# 1ï¸âƒ£4ï¸âƒ£ Widoki (VIEW) w SQL

Widoki (ang. *views*) to **wirtualne tabele**, ktÃ³re przechowujÄ… **zdefiniowane zapytania SQL**.  
Nie przechowujÄ… one fizycznie danych â€“ jedynie **zapamiÄ™tujÄ… zapytanie**, ktÃ³re moÅ¼na pÃ³Åºniej traktowaÄ‡ tak, jakby byÅ‚o tabelÄ….

Widok jest wiÄ™c **logiczna reprezentacjÄ…** danych, utworzonÄ… na podstawie jednej lub kilku tabel.  
DziÄ™ki widokom moÅ¼na:
- uproÅ›ciÄ‡ skomplikowane zapytania,
- ukryÄ‡ zÅ‚oÅ¼onoÅ›Ä‡ bazy przed uÅ¼ytkownikiem,
- zwiÄ™kszyÄ‡ bezpieczeÅ„stwo (np. pokazywaÄ‡ tylko wybrane kolumny),
- tworzyÄ‡ â€staÅ‚e raportyâ€ z danych dynamicznych.

---

## ğŸ”¹ 1. Tworzenie widoku

Widok tworzymy za pomocÄ… polecenia `CREATE VIEW`.

### PrzykÅ‚ad:
UtwÃ³rz widok wyÅ›wietlajÄ…cy listÄ™ ksiÄ…Å¼ek wraz z nazwiskiem autora.

```sql
CREATE VIEW Widok_Ksiazki_Autorzy AS
SELECT
    k.tytul,
    k.rok,
    a.imie,
    a.nazwisko
FROM Ksiazki k
JOIN Autorzy a ON k.autor_id = a.autor_id;
```

â¡ï¸ Po utworzeniu widoku moÅ¼na z niego korzystaÄ‡ tak, jak z kaÅ¼dej innej tabeli:

```sql
SELECT * FROM Widok_Ksiazki_Autorzy;
```

## ğŸ”¹ 2. Widoki jako warstwa abstrakcji

Widoki dziaÅ‚ajÄ… jak poziom poÅ›redni miÄ™dzy uÅ¼ytkownikiem a fizycznÄ… strukturÄ… bazy danych.
UÅ¼ytkownik nie musi znaÄ‡ szczegÃ³Å‚Ã³w Å‚Ä…czenia tabel, kluczy obcych czy kolumn â€” wystarczy, Å¼e zna nazwÄ™ widoku.

### PrzykÅ‚ad:

Widok pokazujÄ…cy tylko podstawowe dane o ksiÄ…Å¼kach:
```sql
CREATE VIEW Widok_Biblioteka_Publiczna AS
SELECT tytul, rok
FROM Ksiazki;
```

â¡ï¸ UÅ¼ytkownik moÅ¼e wykonaÄ‡:
```sql
SELECT * FROM Widok_Biblioteka_Publiczna;

```
i otrzymaÄ‡ uproszczony zestaw danych bez dostÄ™pu do tabel ÅºrÃ³dÅ‚owych.

## ğŸ”¹ 3. Widoki oparte na podzapytaniach

Widoki mogÄ… zawieraÄ‡ podzapytania â€” dziÄ™ki temu moÅ¼na tworzyÄ‡ widoki analityczne, raportowe, czy agregujÄ…ce dane.

### PrzykÅ‚ad:

Widok pokazujÄ…cy liczbÄ™ ksiÄ…Å¼ek napisanych przez kaÅ¼dego autora:

```sql
CREATE VIEW Widok_LiczbaKsiazek AS
SELECT
    a.autor_id,
    a.imie,
    a.nazwisko,
    COUNT(k.ksiazka_id) AS liczba_ksiazek
FROM Autorzy a
LEFT JOIN Ksiazki k ON a.autor_id = k.autor_id
GROUP BY a.autor_id, a.imie, a.nazwisko;
```

â¡ï¸ NastÄ™pnie moÅ¼emy wykonaÄ‡:

```sqml
SELECT * FROM Widok_LiczbaKsiazek WHERE liczba_ksiazek > 3;
```

## ğŸ”¹ 4. AktualizowalnoÅ›Ä‡ widokÃ³w

Nie kaÅ¼dy widok moÅ¼na modyfikowaÄ‡ (czyli wykonywaÄ‡ INSERT, UPDATE, DELETE).

Widoki sÄ… aktualizowalne, jeÅ›li:

- odnoszÄ… siÄ™ tylko do jednej tabeli,
- nie zawierajÄ… GROUP BY, DISTINCT, UNION, HAVING ani funkcji agregujÄ…cych,
- nie zawierajÄ… podzapytaÅ„ w klauzuli SELECT.

JeÅ›li widok jest bardziej zÅ‚oÅ¼ony (np. z JOIN lub GROUP BY), staje siÄ™ tylko do odczytu.

### PrzykÅ‚ad â€“ widok aktualizowalny:
```sql
CREATE VIEW Widok_AutorzyPodstawowi AS
SELECT autor_id, imie, nazwisko
FROM Autorzy;
```
MoÅ¼emy:

```sql
UPDATE Widok_AutorzyPodstawowi
SET nazwisko = 'Nowak'
WHERE autor_id = 1;
```

## ğŸ”¹ 5. Usuwanie i modyfikacja widokÃ³w

Aby usunÄ…Ä‡ widok:
```sql
DROP VIEW Widok_LiczbaKsiazek;
```
Aby zmieniÄ‡ definicjÄ™ widoku:
```sql
CREATE OR REPLACE VIEW Widok_LiczbaKsiazek AS
SELECT nazwisko, COUNT(*) AS liczba
FROM Autorzy a
JOIN Ksiazki k ON a.autor_id = k.autor_id
GROUP BY nazwisko;
```

## ğŸ”¹ 6. Zalety i wady widokÃ³w

âœ… Zalety:

- Uproszczenie zÅ‚oÅ¼onych zapytaÅ„ (abstrakcja)
- ZwiÄ™kszenie bezpieczeÅ„stwa â€“ ograniczony dostÄ™p do danych
- ReuÅ¼ywalnoÅ›Ä‡ â€“ jedno miejsce definicji raportu
- MoÅ¼liwoÅ›Ä‡ definiowania logicznych perspektyw danych

âš ï¸ Wady:

- WydajnoÅ›Ä‡ â€“ kaÅ¼de odwoÅ‚anie do widoku powoduje wykonanie zapytania ÅºrÃ³dÅ‚owego
- Ograniczona aktualizowalnoÅ›Ä‡
- ZÅ‚oÅ¼one widoki mogÄ… utrudniaÄ‡ debugowanie i optymalizacjÄ™

### ğŸ§© PrzykÅ‚ad praktyczny â€“ widok zagnieÅ¼dÅ¼ony

Widoki moÅ¼na zagnieÅ¼dÅ¼aÄ‡ â€“ jeden widok moÅ¼e korzystaÄ‡ z innego.
```sql
CREATE VIEW Widok_StarsiAutorzy AS
SELECT autor_id, imie, nazwisko
FROM Autorzy
WHERE rok_urodzenia < 1950;

CREATE VIEW Widok_StarsiAutorzy_LiczbaKsiazek AS
SELECT
    sa.imie,
    sa.nazwisko,
    COUNT(k.ksiazka_id) AS liczba_ksiazek
FROM Widok_StarsiAutorzy sa
JOIN Ksiazki k ON sa.autor_id = k.autor_id
GROUP BY sa.imie, sa.nazwisko;

```

â¡ï¸ Teraz moÅ¼esz wykonaÄ‡:
```sql

SELECT * FROM Widok_StarsiAutorzy_LiczbaKsiazek
WHERE liczba_ksiazek > 2;
```


Widoki pozwalajÄ… budowaÄ‡ hierarchiÄ™ logicznych perspektyw danych â€” od prostych po analityczne.

## ğŸ“˜ NajwaÅ¼niejsze wnioski

- Widoki nie przechowujÄ… danych, lecz definicjÄ™ zapytania.
- MoÅ¼na je traktowaÄ‡ jak â€tabele wirtualneâ€.
- UÅ‚atwiajÄ… zarzÄ…dzanie dostÄ™pem do danych i tworzenie raportÃ³w.
- Proste widoki sÄ… aktualizowalne, zÅ‚oÅ¼one â€” tylko do odczytu.
- MoÅ¼na je zagnieÅ¼dÅ¼aÄ‡, tworzÄ…c coraz bardziej rozbudowane analizy.