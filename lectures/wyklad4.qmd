---
title: "Model Relacyjny i podstawy SQL"
---


## 1ï¸âƒ£ Model relacyjny â€“ przypomnienie i pojÄ™cia podstawowe

### ğŸ”¹ Relacja = tabela

- Dane przechowywane w **tabelach** (relations)
- KaÅ¼dy **wiersz (row)** = rekord / krotka  
- KaÅ¼da **kolumna (column)** = atrybut  
- **Dziedzina (domain)** = zbiÃ³r dopuszczalnych wartoÅ›ci w kolumnie

| id | imie | nazwisko | rok_urodzenia |
|----|-------|------------|----------------|
| 1  | Adam  | Mickiewicz | 1798 |
| 2  | Henryk | Sienkiewicz | 1846 |


## 2ï¸âƒ£ Klucze i wiÄ™zy integralnoÅ›ci

### ğŸ”¸ Klucz gÅ‚Ã³wny (PRIMARY KEY)
- Unikalnie identyfikuje kaÅ¼dy wiersz w tabeli.
- Nie moÅ¼e byÄ‡ `NULL`.

### ğŸ”¸ Klucz obcy (FOREIGN KEY)
- OdwoÅ‚uje siÄ™ do innej tabeli (relacja miÄ™dzy tabelami).

### ğŸ”¸ Inne wiÄ™zy:
- `UNIQUE` â€“ unikalnoÅ›Ä‡ wartoÅ›ci w kolumnie.
- `NOT NULL` â€“ kolumna nie moÅ¼e mieÄ‡ wartoÅ›ci pustej.
- `CHECK` â€“ warunek logiczny na wartoÅ›Ä‡ kolumny.


## 3ï¸âƒ£ Schemat bazy danych â€“ przykÅ‚ad â€Bibliotekaâ€

### Tabele:
- **Autorzy** (`autor_id`, `imie`, `nazwisko`)
- **Ksiazki** (`ksiazka_id`, `tytul`, `rok`, `autor_id`)

### Relacja:
- `Ksiazki.autor_id` $\to$ `Autorzy.autor_id` (klucz obcy)


## 4ï¸âƒ£ Tworzenie tabel (DDL â€“ Data Definition Language)

Polecenie `CREATE TABLE` sÅ‚uÅ¼y do utworzenia nowej tabeli w bazie danych.  
W tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz rÃ³Å¼ne wiÄ™zy integralnoÅ›ci, takie jak `PRIMARY KEY`, `NOT NULL` czy `FOREIGN KEY`.  
KaÅ¼da tabela powinna mieÄ‡ kolumnÄ™, ktÃ³ra jednoznacznie identyfikuje kaÅ¼dy wiersz â€“ to wÅ‚aÅ›nie klucz gÅ‚Ã³wny.  
W przykÅ‚adzie poniÅ¼ej tworzymy dwie tabele: **Autorzy** i **Ksiazki**, ktÃ³re bÄ™dÄ… ze sobÄ… powiÄ…zane relacjÄ… klucz gÅ‚Ã³wnyâ€“klucz obcy.



### PrzykÅ‚ad w **SQLite** i **PostgreSQL**

```sql
CREATE TABLE Autorzy (
    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT
    imie         TEXT NOT NULL,
    nazwisko     TEXT NOT NULL
);

CREATE TABLE Ksiazki (
    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja
    tytul        VARCHAR(200) NOT NULL,
    rok          INTEGER CHECK (rok > 0),
    autor_id     INTEGER,
    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)
);
```

- W SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.
- W PostgreSQL SERIAL lub GENERATED ALWAYS AS IDENTITY.

W powyÅ¼szym przykÅ‚adzie tabela Autorzy przechowuje dane o autorach, a tabela Ksiazki â€“ dane o ksiÄ…Å¼kach.
Kolumna autor_id w tabeli Ksiazki jest kluczem obcym i wskazuje, ktÃ³ry autor napisaÅ‚ danÄ… ksiÄ…Å¼kÄ™.
DziÄ™ki wiÄ™zom integralnoÅ›ci baza pilnuje, aby kaÅ¼da ksiÄ…Å¼ka miaÅ‚a poprawnego autora.
Takie powiÄ…zania sÄ… podstawÄ… modelu relacyjnego.

## 5ï¸âƒ£ Modyfikacja i usuwanie tabel

```sql
ALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;

DROP TABLE Ksiazki;

```

## 6ï¸âƒ£ Wstawianie danych (DML â€“ Data Manipulation Language)

Polecenie INSERT INTO sÅ‚uÅ¼y do wprowadzania nowych wierszy (rekordÃ³w) do tabeli.
WartoÅ›ci muszÄ… byÄ‡ zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.).
MoÅ¼na dodaÄ‡ jeden lub wiele rekordÃ³w w jednym poleceniu.
PoniÅ¼ej wstawiamy kilku autorÃ³w oraz ich ksiÄ…Å¼ki do utworzonych wczeÅ›niej tabel.

```sql
INSERT INTO Autorzy (imie, nazwisko) VALUES
('Adam', 'Mickiewicz'),
('Henryk', 'Sienkiewicz'),
('BolesÅ‚aw', 'Prus');

INSERT INTO Ksiazki (tytul, rok, autor_id) VALUES
('Pan Tadeusz', 1834, 1),
('Quo Vadis', 1896, 2),
('Lalka', 1890, 3);
```

KaÅ¼dy rekord reprezentuje jednÄ… pozycjÄ™ w tabeli.
Polecenie INSERT wymaga podania wartoÅ›ci w tej samej kolejnoÅ›ci, w jakiej wymieniono kolumny.
JeÅ›li nie podamy jakiejÅ› kolumny, a ma ona zdefiniowanÄ… wartoÅ›Ä‡ domyÅ›lnÄ… (DEFAULT), baza wstawi jÄ… automatycznie.
DziÄ™ki temu moÅ¼emy stopniowo budowaÄ‡ zawartoÅ›Ä‡ naszej bazy danych.

## 7ï¸âƒ£ Wybieranie danych â€“ SELECT

### ğŸ§© Podstawowy SELECT

Polecenie SELECT jest najczÄ™Å›ciej uÅ¼ywanym poleceniem SQL i sÅ‚uÅ¼y do pobierania danych z tabel.
Pozwala okreÅ›liÄ‡, ktÃ³re kolumny chcemy zobaczyÄ‡ i z ktÃ³rych tabel dane majÄ… pochodziÄ‡.
JeÅ›li uÅ¼yjemy gwiazdki *, oznacza to, Å¼e wybieramy wszystkie kolumny.
PoniÅ¼sze zapytanie zwraca wszystkich autorÃ³w z tabeli Autorzy.

```sql
SELECT * FROM Autorzy;
```
### ğŸ§© WybÃ³r konkretnych kolumn

```sql
SELECT imie, nazwisko FROM Autorzy;
```

Wynik to peÅ‚na tabela z kolumnami autor_id, imie i nazwisko.
CzÄ™sto jednak potrzebujemy tylko czÄ™Å›ci danych, np. imienia i nazwiska â€“ wtedy podajemy konkretne kolumny:

### ğŸ§© Nadawanie aliasÃ³w

```sql
SELECT imie AS "ImiÄ™", nazwisko AS "Nazwisko" FROM Autorzy;
```

Takie zapytania pomagajÄ… ograniczyÄ‡ iloÅ›Ä‡ danych i zwiÄ™kszyÄ‡ czytelnoÅ›Ä‡ wynikÃ³w.
Warto teÅ¼ nadawaÄ‡ aliasy (AS), ktÃ³re pozwalajÄ… zmieniÄ‡ nazwÄ™ kolumn w wynikach i nadaÄ‡ im bardziej opisowy wyglÄ…d.


## 8ï¸âƒ£ Filtrowanie â€“ WHERE

Kiedy chcemy wybraÄ‡ tylko czÄ™Å›Ä‡ danych, uÅ¼ywamy klauzuli WHERE.
DziÄ™ki niej moÅ¼emy ustawiÄ‡ warunki, jakie muszÄ… speÅ‚niaÄ‡ rekordy, by pojawiÅ‚y siÄ™ w wyniku.
To bardzo potÄ™Å¼ne narzÄ™dzie, ktÃ³re pozwala np. wyszukiwaÄ‡ ksiÄ…Å¼ki z konkretnego roku lub autora.
W poniÅ¼szym przykÅ‚adzie wybieramy ksiÄ…Å¼ki wydane po roku 1850.


```sql
SELECT * FROM Ksiazki
WHERE rok > 1850;
```

### ğŸ§  Operatory:

MoÅ¼emy teÅ¼ stosowaÄ‡ inne operatory: 

- =, <>, <, >, <=, >=
- LIKE 'Q%' â†’ zaczyna siÄ™ na Q
- IN (...)
- BETWEEN 1800 AND 1900
- IS NULL, IS NOT NULL


Na przykÅ‚ad, aby znaleÅºÄ‡ wszystkie ksiÄ…Å¼ki, ktÃ³rych tytuÅ‚ zawiera literÄ™ â€aâ€, uÅ¼ywamy wzorca z LIKE:


```sql
SELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';
```

Klauzula WHERE pozwala wiÄ™c filtrowaÄ‡ dane na wiele sposobÃ³w, co czyni zapytania SQL bardzo elastycznymi.


## 9ï¸âƒ£ Sortowanie â€“ ORDER BY

Po pobraniu danych czÄ™sto chcemy uporzÄ…dkowaÄ‡ je wedÅ‚ug okreÅ›lonego kryterium.
Do tego sÅ‚uÅ¼y klauzula ORDER BY, dziÄ™ki ktÃ³rej moÅ¼emy sortowaÄ‡ rosnÄ…co (ASC) lub malejÄ…co (DESC).
Sortowanie dziaÅ‚a na dowolnej kolumnie, takÅ¼e tych, ktÃ³re nie sÄ… wyÅ›wietlane w wyniku.
W przykÅ‚adzie poniÅ¼ej porzÄ…dkujemy ksiÄ…Å¼ki wedÅ‚ug roku wydania od najnowszej do najstarszej.

```sql
SELECT * FROM Ksiazki ORDER BY rok DESC;
```

JeÅ›li nie podamy kierunku sortowania, domyÅ›lnie jest to ASC (rosnÄ…co).
MoÅ¼na teÅ¼ sortowaÄ‡ wedÅ‚ug kilku kolumn jednoczeÅ›nie, np. najpierw po autorze, a potem po roku.
Sortowanie poprawia czytelnoÅ›Ä‡ wynikÃ³w i pozwala szybciej analizowaÄ‡ dane.

## ğŸ”Ÿ Grupowanie i agregacja â€“ GROUP BY, HAVING

Czasem chcemy policzyÄ‡, ile danych naleÅ¼y do danej kategorii â€“ np. ilu autorÃ³w napisaÅ‚o wiÄ™cej niÅ¼ jednÄ… ksiÄ…Å¼kÄ™.
Do tego sÅ‚uÅ¼y GROUP BY, ktÃ³re grupuje dane wedÅ‚ug wybranej kolumny.
W poÅ‚Ä…czeniu z funkcjami agregujÄ…cymi, takimi jak COUNT(), AVG(), SUM(), MIN() czy MAX(), daje duÅ¼e moÅ¼liwoÅ›ci analizy.
Klauzula HAVING pozwala odfiltrowaÄ‡ grupy po obliczeniu agregacji.

```sql
SELECT autor_id, COUNT(*) AS liczba_ksiazek
FROM Ksiazki
GROUP BY autor_id
HAVING COUNT(*) > 1;
```

To zapytanie zwraca tylko tych autorÃ³w, ktÃ³rzy majÄ… wiÄ™cej niÅ¼ jednÄ… ksiÄ…Å¼kÄ™.
RÃ³Å¼nica miÄ™dzy WHERE a HAVING polega na tym, Å¼e WHERE filtruje pojedyncze wiersze przed grupowaniem, a HAVING filtruje caÅ‚e grupy po agregacji.
Wyniki moÅ¼na potem Å‚Ä…czyÄ‡ z innymi tabelami, by uzyskaÄ‡ bardziej opisowe raporty.


## 1ï¸âƒ£1ï¸âƒ£ ÅÄ…czenie tabel â€“ JOIN

W relacyjnym modelu danych informacje sÄ… rozproszone w rÃ³Å¼nych tabelach, ktÃ³re Å‚Ä…czy siÄ™ przy pomocy kluczy obcych.
Polecenie JOIN pozwala zestawiÄ‡ dane z kilku tabel na podstawie wspÃ³lnej kolumny.
NajczÄ™Å›ciej uÅ¼ywany jest INNER JOIN, ktÃ³ry zwraca tylko rekordy, dla ktÃ³rych istnieje dopasowanie w obu tabelach.
W przykÅ‚adzie Å‚Ä…czymy tabelÄ™ Ksiazki z Autorzy, aby zobaczyÄ‡ tytuÅ‚ ksiÄ…Å¼ki i jej autora.


### ğŸ”¹ INNER JOIN
```sql
SELECT k.tytul, a.imie, a.nazwisko
FROM Ksiazki k
JOIN Autorzy a ON k.autor_id = a.autor_id;
```

Wynikiem bÄ™dzie lista ksiÄ…Å¼ek wraz z imieniem i nazwiskiem autora.
JeÅ›li chcemy, aby w wynikach pojawiÅ‚y siÄ™ takÅ¼e ksiÄ…Å¼ki bez autora (lub autorzy bez ksiÄ…Å¼ek), uÅ¼ywamy odpowiednio LEFT JOIN lub RIGHT JOIN.
ÅÄ…czenie tabel to fundament relacyjnych baz danych â€“ dziÄ™ki niemu dane sÄ… spÃ³jne i nie trzeba ich powielaÄ‡.

### ğŸ”¹ LEFT JOIN
```sql
SELECT k.tytul, a.imie, a.nazwisko
FROM Ksiazki k
LEFT JOIN Autorzy a ON k.autor_id = a.autor_id;
```

## 1ï¸âƒ£2ï¸âƒ£ Aktualizacja i usuwanie danych

Polecenie UPDATE pozwala modyfikowaÄ‡ dane juÅ¼ istniejÄ…ce w tabeli.
Zawsze naleÅ¼y uÅ¼ywaÄ‡ klauzuli WHERE, aby zmiana nie objÄ™Å‚a wszystkich rekordÃ³w.
Z kolei DELETE sÅ‚uÅ¼y do usuwania rekordÃ³w â€“ rÃ³wnieÅ¼ z warunkiem, by nie usunÄ…Ä‡ wszystkiego przez pomyÅ‚kÄ™.
PrzykÅ‚ad poniÅ¼ej pokazuje, jak zmieniÄ‡ rok wydania ksiÄ…Å¼ki i usunÄ…Ä‡ starsze pozycje.

```sql
UPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';

DELETE FROM Ksiazki WHERE rok < 1850;
```

UPDATE pozwala teÅ¼ aktualizowaÄ‡ wiele kolumn naraz, a nawet wykonywaÄ‡ obliczenia.
Z kolei DELETE usuwa rekordy z tabeli, ale nie zmienia struktury bazy.
Warto zawsze testowaÄ‡ warunek WHERE wczeÅ›niej przy pomocy SELECT, by uniknÄ…Ä‡ niechcianych usuniÄ™Ä‡.


## Podsumowanie 

SQL jest jÄ™zykiem deklaratywnym â€“ opisujemy co chcemy uzyskaÄ‡, a nie jak to zrobiÄ‡.
DziÄ™ki temu uÅ¼ytkownik nie musi znaÄ‡ szczegÃ³Å‚Ã³w dziaÅ‚ania bazy danych, wystarczy, Å¼e opisze warunki i strukturÄ™ zapytania.
Poznane dziÅ› polecenia (CREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY) to fundament pracy z bazami danych.
Opanowanie ich pozwala budowaÄ‡ i analizowaÄ‡ nawet bardzo zÅ‚oÅ¼one systemy informacyjne.



## ğŸ¯ Temat: Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu?


## 1. Problemy zÅ‚ego projektu bazy danych

ZÅ‚e zaprojektowanie struktury bazy danych prowadzi do wielu problemÃ³w:

### ğŸ”¹ Redundancja danych

To **powielanie tych samych informacji** w rÃ³Å¼nych miejscach bazy. 

PrzykÅ‚ad: jeÅ›li w kaÅ¼dej tabeli z zamÃ³wieniami przechowujemy peÅ‚ne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordÃ³w.

### ğŸ”¹ Anomalie danych

BÅ‚Ä™dy i niekonsekwencje wynikajÄ…ce z nadmiarowej struktury danych.

- **Anomalia aktualizacji** â€“ zmiana jednej informacji wymaga wielu modyfikacji.  
  *Np. zmiana nazwiska wykÅ‚adowcy w kilku wierszach tabeli.*

- **Anomalia wstawiania** â€“ brak moÅ¼liwoÅ›ci dodania danych bez istnienia innych.  
  *Np. nie moÅ¼na dodaÄ‡ nowego kursu, dopÃ³ki nie zapisze siÄ™ na niego student.*

- **Anomalia usuwania** â€“ usuniÄ™cie rekordu powoduje utratÄ™ innych informacji.  
  *Np. usuniÄ™cie ostatniego studenta z kursu powoduje utratÄ™ danych o samym kursie.*

ğŸ‘‰ **Wniosek:** bÅ‚Ä™dy projektowe utrudniajÄ… utrzymanie spÃ³jnoÅ›ci danych.

---

## 2. ZaleÅ¼noÅ›ci funkcjonalne

### ğŸ”¹ Definicja

ZaleÅ¼noÅ›Ä‡ funkcjonalna (ang. *functional dependency*) opisuje **relacjÄ™ miÄ™dzy atrybutami** w tabeli.

MÃ³wimy, Å¼e atrybut *B* jest **funkcyjnie zaleÅ¼ny** od atrybutu *A* (zapis:  
**A â†’ B**), jeÅ›li kaÅ¼dej wartoÅ›ci *A* odpowiada dokÅ‚adnie jedna wartoÅ›Ä‡ *B*.

### ğŸ”¹ PrzykÅ‚ady
- NrIndeksu â†’ ImiÄ™, Nazwisko, Kierunek  
  (kaÅ¼dy numer indeksu jednoznacznie identyfikuje studenta)
- Kurs â†’ Sala, ProwadzÄ…cy  
  (dany kurs odbywa siÄ™ zawsze w tej samej sali, prowadzony przez tÄ™ samÄ… osobÄ™)

### ğŸ”¹ Klucze
- **Klucz gÅ‚Ã³wny (primary key)** â€“ jednoznacznie identyfikuje wiersz tabeli.  
- **Klucz kandydujÄ…cy (candidate key)** â€“ minimalny zestaw atrybutÃ³w, ktÃ³ry moÅ¼e byÄ‡ kluczem.  
- **Klucz obcy (foreign key)** â€“ wskazuje na klucz gÅ‚Ã³wny w innej tabeli i tworzy powiÄ…zanie miÄ™dzy tabelami.

### ğŸ”¹ Typy zaleÅ¼noÅ›ci
- **ZaleÅ¼noÅ›Ä‡ peÅ‚na** â€“ atrybut zaleÅ¼y od caÅ‚ego klucza zÅ‚oÅ¼onego.  
- **ZaleÅ¼noÅ›Ä‡ czÄ™Å›ciowa** â€“ atrybut zaleÅ¼y tylko od czÄ™Å›ci klucza.  
- **ZaleÅ¼noÅ›Ä‡ przechodnia** â€“ atrybut zaleÅ¼y poÅ›rednio od klucza (A â†’ B â†’ C).

---

## 3. Formy normalne (1NF â€“ 3NF, BCNF)

Normalizacja to proces przeksztaÅ‚cania tabel w taki sposÃ³b, aby **usunÄ…Ä‡ redundancjÄ™** i **zapobiec anomaliom**.

### ğŸ§© Pierwsza postaÄ‡ normalna (1NF)

- Wszystkie wartoÅ›ci w tabeli sÄ… **atomowe** (niepodzielne).  
- Brak list, zbiorÃ³w lub kolumn powtarzajÄ…cych siÄ™.  
  
âœ… *KaÅ¼da kolumna ma jednÄ… wartoÅ›Ä‡ w komÃ³rce.*

**PrzykÅ‚ad (naruszenie 1NF):**
| Student | NrIndeksu | Kursy |
|----------|------------|--------|
| Jan Nowak | 12345 | Bazy danych, Programowanie |

âœ… *Poprawnie:*  
Tworzymy osobnÄ… tabelÄ™ STUDENT_KURS, gdzie kaÅ¼dy kurs to osobny rekord.

---

### ğŸ§© Druga postaÄ‡ normalna (2NF)

- Tabela jest w 1NF **i** wszystkie atrybuty niekluczowe zaleÅ¼Ä… **w peÅ‚ni** od caÅ‚ego klucza gÅ‚Ã³wnego.  
- Dotyczy tabel z **kluczem zÅ‚oÅ¼onym**.

**PrzykÅ‚ad:**

Tabela ZAPISY(StudentID, KursID, Sala)  
â†’ atrybut *Sala* zaleÅ¼y tylko od *KursID*, a nie od caÅ‚ego klucza (StudentID, KursID).  
RozwiÄ…zanie: wydziel tabelÄ™ KURS(KursID, Sala).

---

### ğŸ§© Trzecia postaÄ‡ normalna (3NF)

- Tabela jest w 2NF **i** nie zawiera zaleÅ¼noÅ›ci przechodnich.  
- KaÅ¼dy atrybut niekluczowy zaleÅ¼y bezpoÅ›rednio od klucza gÅ‚Ã³wnego.

**PrzykÅ‚ad:**

NrIndeksu â†’ Kierunek, Kierunek â†’ Dziekan  
â¡ï¸ *Dziekan* zaleÅ¼y poÅ›rednio od *NrIndeksu*.  
RozwiÄ…zanie: osobna tabela KIERUNEK(Dziekan, Kierunek).

---

### ğŸ§© PostaÄ‡ Boyceâ€™a-Codda (BCNF)

- Dla kaÅ¼dej zaleÅ¼noÅ›ci A â†’ B, zbiÃ³r A musi byÄ‡ **kluczem kandydujÄ…cym**.  
- Bardziej restrykcyjna niÅ¼ 3NF â€“ eliminuje wszelkie potencjalne redundancje.

---

## 4. Diagramy ERD (Entityâ€“Relationship Diagram)

Diagram ERD jest graficznym sposobem przedstawienia **modelu konceptualnego** bazy danych.

### ğŸ”¹ GÅ‚Ã³wne elementy ERD

- **Encja (Entity)** â€“ obiekt, o ktÃ³rym przechowujemy dane (np. Student, Kurs).  
- **Atrybut (Attribute)** â€“ wÅ‚aÅ›ciwoÅ›Ä‡ encji (np. ImiÄ™, Nazwisko, NrIndeksu).  
- **Relacja (Relationship)** â€“ powiÄ…zanie miÄ™dzy encjami (np. Student zapisuje siÄ™ na Kurs).  
- **KardynalnoÅ›Ä‡ (Cardinality)** â€“ okreÅ›la licznoÅ›Ä‡ relacji:  
  - 1:1 (jeden do jednego)  
  - 1:N (jeden do wielu)  
  - N:M (wielu do wielu)  
- **Identyfikator (Primary Key)** â€“ atrybut jednoznacznie identyfikujÄ…cy encjÄ™.

### ğŸ”¹ PrzykÅ‚ad:

```sql
STUDENT (NrIndeksu, ImiÄ™, Nazwisko, Kierunek)
KURS (KursID, Nazwa, ProwadzÄ…cy)
ZAPIS (NrIndeksu, KursID, DataZapisu)

```

Relacja miÄ™dzy STUDENT a KURS: N:M poprzez encjÄ™ poÅ›redniczÄ…cÄ… ZAPIS.

---

## 5. Proces projektowania bazy danych

Projektowanie bazy to proces etapowy:

1. **Analiza wymagaÅ„** â€“ zrozumienie, jakie dane sÄ… potrzebne i jakie operacje bÄ™dÄ… wykonywane.  
2. **Model konceptualny** â€“ opis danych w postaci ERD.  
3. **Model logiczny** â€“ zamiana modelu ERD na relacyjny schemat tabel.  
4. **Model fizyczny** â€“ implementacja w konkretnym systemie DBMS (np. PostgreSQL, MySQL).




- Dokumentacja SQLite
- Dokumentacja PostgreSQL
- A. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts